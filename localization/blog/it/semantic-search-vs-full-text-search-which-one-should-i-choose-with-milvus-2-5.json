{"codeList":["use {\n    crate::args::LogArgs,\n    anyhow::{anyhow, Result},\n    simplelog::{Config, LevelFilter, WriteLogger},\n    std::fs::File,\n};\n\npub struct Logger;\n\nimpl Logger {\n    pub fn init(args: &impl LogArgs) -> Result<()> {\n        let filter: LevelFilter = args.log_level().into();\n        if filter != LevelFilter::Off {\n            let logfile = File::create(args.log_file())\n                .map_err(|e| anyhow!(\"Failed to open log file: {e:}\"))?;\n            WriteLogger::init(filter, Config::default(), logfile)\n                .map_err(|e| anyhow!(\"Failed to initalize logger: {e:}\"))?;\n        }\n        Ok(())\n    }\n}\n","##dense 0 0.7745316028594971 \n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"logunit.h\"\n#include <log4cxx/logger.h>\n#include <log4cxx/simplelayout.h>\n#include <log4cxx/fileappender.h>\n#include <log4cxx/helpers/absolutetimedateformat.h>\n\n\n\n ##dense 1 0.769859254360199 \n        void simple()\n        {\n                LayoutPtr layout = LayoutPtr(new SimpleLayout());\n                AppenderPtr appender = FileAppenderPtr(new FileAppender(layout, LOG4CXX_STR(\"output/simple\"), false));\n                root->addAppender(appender);\n                common();\n\n                LOGUNIT_ASSERT(Compare::compare(LOG4CXX_FILE(\"output/simple\"), LOG4CXX_FILE(\"witness/simple\")));\n        }\n\n        std::string createMessage(int i, Pool & pool)\n        {\n                std::string msg(\"Message \");\n                msg.append(pool.itoa(i));\n                return msg;\n        }\n\n        void common()\n        {\n                int i = 0;\n\n                // In the lines below, the logger names are chosen as an aid in\n                // remembering their level values. In general, the logger names\n                // have no bearing to level values.\n                LoggerPtr ERRlogger = Logger::getLogger(LOG4CXX_TEST_STR(\"ERR\"));\n                ERRlogger->setLevel(Level::getError());\n\n\n\n ##dense 2 0.7591114044189453 \n                log4cxx::spi::LoggingEventPtr logEvt = std::make_shared<log4cxx::spi::LoggingEvent>(LOG4CXX_STR(\"foo\"),\n                                                                                                                                                                                         Level::getInfo(),\n                                                                                                                                                                                         LOG4CXX_STR(\"A Message\"),\n                                                                                                                                                                                         log4cxx::spi::LocationInfo::getLocationUnavailable());\n                FMTLayout layout(LOG4CXX_STR(\"{d:%Y-%m-%d %H:%M:%S} {message}\"));\n                LogString output;\n                log4cxx::helpers::Pool pool;\n                layout.format( output, logEvt, pool);\n\n\n\n ##dense 3 0.7562235593795776 \n#include \"util/compare.h\"\n#include \"util/transformer.h\"\n#include \"util/absolutedateandtimefilter.h\"\n#include \"util/iso8601filter.h\"\n#include \"util/absolutetimefilter.h\"\n#include \"util/relativetimefilter.h\"\n#include \"util/controlfilter.h\"\n#include \"util/threadfilter.h\"\n#include \"util/linenumberfilter.h\"\n#include \"util/filenamefilter.h\"\n#include \"vectorappender.h\"\n#include <log4cxx/fmtlayout.h>\n#include <log4cxx/propertyconfigurator.h>\n#include <log4cxx/helpers/date.h>\n#include <log4cxx/spi/loggingevent.h>\n#include <iostream>\n#include <iomanip>\n\n#define REGEX_STR(x) x\n#define PAT0 REGEX_STR(\"\\\\[[0-9A-FXx]*]\\\\ (DEBUG|INFO|WARN|ERROR|FATAL) .* - Message [0-9]\\\\{1,2\\\\}\")\n#define PAT1 ISO8601_PAT REGEX_STR(\" \") PAT0\n#define PAT2 ABSOLUTE_DATE_AND_TIME_PAT REGEX_STR(\" \") PAT0\n#define PAT3 ABSOLUTE_TIME_PAT REGEX_STR(\" \") PAT0\n#define PAT4 RELATIVE_TIME_PAT REGEX_STR(\" \") PAT0\n#define PAT5 REGEX_STR(\"\\\\[[0-9A-FXx]*]\\\\ (DEBUG|INFO|WARN|ERROR|FATAL) .* : Message [0-9]\\\\{1,2\\\\}\")\n\n\n ##dense 4 0.7557586431503296 \n                std::string msg(\"Message \");\n\n                Pool pool;\n\n                // These should all log.----------------------------\n                LOG4CXX_FATAL(ERRlogger, createMessage(i, pool));\n                i++; //0\n                LOG4CXX_ERROR(ERRlogger, createMessage(i, pool));\n                i++;\n\n                LOG4CXX_FATAL(INF, createMessage(i, pool));\n                i++; // 2\n                LOG4CXX_ERROR(INF, createMessage(i, pool));\n                i++;\n                LOG4CXX_WARN(INF, createMessage(i, pool));\n                i++;\n                LOG4CXX_INFO(INF, createMessage(i, pool));\n                i++;\n\n                LOG4CXX_FATAL(INF_UNDEF, createMessage(i, pool));\n                i++; //6\n                LOG4CXX_ERROR(INF_UNDEF, createMessage(i, pool));\n                i++;\n                LOG4CXX_WARN(INF_UNDEF, createMessage(i, pool));\n                i++;\n                LOG4CXX_INFO(INF_UNDEF, createMessage(i, pool));\n                i++;\n\n                LOG4CXX_FATAL(INF_ERR, createMessage(i, pool));\n                i++; // 10\n                LOG4CXX_ERROR(INF_ERR, createMessage(i, pool));\n                i++;\n\n                LOG4CXX_FATAL(INF_ERR_UNDEF, createMessage(i, pool));\n                i++;\n                LOG4CXX_ERROR(INF_ERR_UNDEF, createMessage(i, pool));\n                i++;\n\n\n","##hybrid 0 0.016393441706895828 \nuse {\n    crate::args::LogArgs,\n    anyhow::{anyhow, Result},\n    simplelog::{Config, LevelFilter, WriteLogger},\n    std::fs::File,\n};\n\npub struct Logger;\n\nimpl Logger {\n    pub fn init(args: &impl LogArgs) -> Result<()> {\n        let filter: LevelFilter = args.log_level().into();\n        if filter != LevelFilter::Off {\n            let logfile = File::create(args.log_file())\n                .map_err(|e| anyhow!(\"Failed to open log file: {e:}\"))?;\n            WriteLogger::init(filter, Config::default(), logfile)\n                .map_err(|e| anyhow!(\"Failed to initalize logger: {e:}\"))?;\n        }\n        Ok(())\n    }\n}\n\n \n##hybrid 1 0.016393441706895828 \n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"logunit.h\"\n#include <log4cxx/logger.h>\n#include <log4cxx/simplelayout.h>\n#include <log4cxx/fileappender.h>\n#include <log4cxx/helpers/absolutetimedateformat.h>\n\n\n \n##hybrid 2 0.016129031777381897 \n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n    };\n}\n\n\n \n##hybrid 3 0.016129031777381897 \n        void simple()\n        {\n                LayoutPtr layout = LayoutPtr(new SimpleLayout());\n                AppenderPtr appender = FileAppenderPtr(new FileAppender(layout, LOG4CXX_STR(\"output/simple\"), false));\n                root->addAppender(appender);\n                common();\n\n                LOGUNIT_ASSERT(Compare::compare(LOG4CXX_FILE(\"output/simple\"), LOG4CXX_FILE(\"witness/simple\")));\n        }\n\n        std::string createMessage(int i, Pool & pool)\n        {\n                std::string msg(\"Message \");\n                msg.append(pool.itoa(i));\n                return msg;\n        }\n\n        void common()\n        {\n                int i = 0;\n\n                // In the lines below, the logger names are chosen as an aid in\n                // remembering their level values. In general, the logger names\n                // have no bearing to level values.\n                LoggerPtr ERRlogger = Logger::getLogger(LOG4CXX_TEST_STR(\"ERR\"));\n                ERRlogger->setLevel(Level::getError());\n\n\n \n##hybrid 4 0.01587301678955555 \nstd::vector<std::string> MakeStrings() {\n    return {\n        \"a\", \"ab\", \"abc\", \"abcd\",\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n","use {\n    crate::args::LogArgs,\n    anyhow::{anyhow, Result},\n    simplelog::{Config, LevelFilter, WriteLogger},\n    std::fs::File,\n};\n\npub struct Logger;\n\nimpl Logger {\n    pub fn init(args: &impl LogArgs) -> Result<()> {\n        let filter: LevelFilter = args.log_level().into();\n        if filter != LevelFilter::Off {\n            let logfile = File::create(args.log_file())\n                .map_err(|e| anyhow!(\"Failed to open log file: {e:}\"))?;\n            WriteLogger::init(filter, Config::default(), logfile)\n                .map_err(|e| anyhow!(\"Failed to initalize logger: {e:}\"))?;\n        }\n        Ok(())\n    }\n}\n","##sparse 0 10.17311954498291 \n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n    };\n}\n\n\n\n ##sparse 1 9.775702476501465 \nstd::vector<std::string> MakeStrings() {\n    return {\n        \"a\", \"ab\", \"abc\", \"abcd\",\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n\n\n ##sparse 2 7.638711452484131 \n//   union (\"x|y\"), grouping (\"(xy)\"), brackets (\"[xy]\"), and\n//   repetition count (\"x{5,7}\"), among others.\n//\n//   Below is the syntax that we do support.  We chose it to be a\n//   subset of both PCRE and POSIX extended regex, so it's easy to\n//   learn wherever you come from.  In the following: 'A' denotes a\n//   literal character, period (.), or a single \\\\ escape sequence;\n//   'x' and 'y' denote regular expressions; 'm' and 'n' are for\n\n\n ##sparse 3 7.1208391189575195 \n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"logunit.h\"\n#include <log4cxx/logger.h>\n#include <log4cxx/simplelayout.h>\n#include <log4cxx/fileappender.h>\n#include <log4cxx/helpers/absolutetimedateformat.h>\n\n\n\n ##sparse 4 7.066349029541016 \n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <log4cxx/filter/denyallfilter.h>\n#include <log4cxx/logger.h>\n#include <log4cxx/spi/filter.h>\n#include <log4cxx/spi/loggingevent.h>\n#include \"../logunit.h\"\n","\n ##hybrid 0 0.016393441706895828 \nuse {\n    crate::args::LogArgs,\n    anyhow::{anyhow, Result},\n    simplelog::{Config, LevelFilter, WriteLogger},\n    std::fs::File,\n};\n\npub struct Logger;\n\nimpl Logger {\n    pub fn init(args: &impl LogArgs) -> Result<()> {\n        let filter: LevelFilter = args.log_level().into();\n        if filter != LevelFilter::Off {\n            let logfile = File::create(args.log_file())\n                .map_err(|e| anyhow!(\"Failed to open log file: {e:}\"))?;\n            WriteLogger::init(filter, Config::default(), logfile)\n                .map_err(|e| anyhow!(\"Failed to initalize logger: {e:}\"))?;\n        }\n        Ok(())\n    }\n}\n\n \n##hybrid 1 0.016393441706895828 \n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n    };\n}\n\n\n \n##hybrid 2 0.016129031777381897 \nstd::vector<std::string> MakeStrings() {\n    return {\n        \"a\", \"ab\", \"abc\", \"abcd\",\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n        \"long string to test how those are handled. Here goes more text. \"\n\n \n##hybrid 3 0.016129031777381897 \n                LoggerPtr INF = Logger::getLogger(LOG4CXX_TEST_STR(\"INF\"));\n                INF->setLevel(Level::getInfo());\n\n                LoggerPtr INF_ERR = Logger::getLogger(LOG4CXX_TEST_STR(\"INF.ERR\"));\n                INF_ERR->setLevel(Level::getError());\n\n                LoggerPtr DEB = Logger::getLogger(LOG4CXX_TEST_STR(\"DEB\"));\n                DEB->setLevel(Level::getDebug());\n\n                // Note: categories with undefined level\n                LoggerPtr INF_UNDEF = Logger::getLogger(LOG4CXX_TEST_STR(\"INF.UNDEF\"));\n                LoggerPtr INF_ERR_UNDEF = Logger::getLogger(LOG4CXX_TEST_STR(\"INF.ERR.UNDEF\"));\n                LoggerPtr UNDEF = Logger::getLogger(LOG4CXX_TEST_STR(\"UNDEF\"));\n\n\n \n##hybrid 4 0.01587301678955555 \n//   union (\"x|y\"), grouping (\"(xy)\"), brackets (\"[xy]\"), and\n//   repetition count (\"x{5,7}\"), among others.\n//\n//   Below is the syntax that we do support.  We chose it to be a\n//   subset of both PCRE and POSIX extended regex, so it's easy to\n//   learn wherever you come from.  In the following: 'A' denotes a\n//   literal character, period (.), or a single \\\\ escape sequence;\n//   'x' and 'y' denote regular expressions; 'm' and 'n' are for\n","/** Integration tests for {@link BlobPuller}. */\npublic class BlobPullerIntegrationTest {\n\n  private final FailoverHttpClient httpClient = new FailoverHttpClient(true, false, ignored -> {});\n\n  @Test\n  public void testPull() throws IOException, RegistryException {\n    RegistryClient registryClient =\n        RegistryClient.factory(EventHandlers.NONE, \"gcr.io\", \"distroless/base\", httpClient)\n            .newRegistryClient();\n    V22ManifestTemplate manifestTemplate =\n        registryClient\n            .pullManifest(\n                ManifestPullerIntegrationTest.KNOWN_MANIFEST_V22_SHA, V22ManifestTemplate.class)\n            .getManifest();\n\n    DescriptorDigest realDigest = manifestTemplate.getLayers().get(0).getDigest();\n","\n \n\n##dense 0 0.7411458492279053 \n    Mockito.doThrow(mockRegistryUnauthorizedException)\n        .when(mockJibContainerBuilder)\n        .containerize(mockContainerizer);\n\n    try {\n      testJibBuildRunner.runBuild();\n      Assert.fail();\n\n    } catch (BuildStepsExecutionException ex) {\n      Assert.assertEquals(\n          TEST_HELPFUL_SUGGESTIONS.forHttpStatusCodeForbidden(\"someregistry/somerepository\"),\n          ex.getMessage());\n    }\n  }\n\n\n\n ##dense 1 0.7346029877662659 \n    verify(mockCredentialRetrieverFactory).known(knownCredential, \"credentialSource\");\n    verify(mockCredentialRetrieverFactory).known(inferredCredential, \"inferredCredentialSource\");\n    verify(mockCredentialRetrieverFactory)\n        .dockerCredentialHelper(\"docker-credential-credentialHelperSuffix\");\n  }\n\n\n\n ##dense 2 0.7285804748535156 \n    when(mockCredentialRetrieverFactory.dockerCredentialHelper(anyString()))\n        .thenReturn(mockDockerCredentialHelperCredentialRetriever);\n    when(mockCredentialRetrieverFactory.known(knownCredential, \"credentialSource\"))\n        .thenReturn(mockKnownCredentialRetriever);\n    when(mockCredentialRetrieverFactory.known(inferredCredential, \"inferredCredentialSource\"))\n        .thenReturn(mockInferredCredentialRetriever);\n    when(mockCredentialRetrieverFactory.wellKnownCredentialHelpers())\n        .thenReturn(mockWellKnownCredentialHelpersCredentialRetriever);\n\n\n\n ##dense 3 0.7279614210128784 \n  @Test\n  public void testBuildImage_insecureRegistryException()\n      throws InterruptedException, IOException, CacheDirectoryCreationException, RegistryException,\n          ExecutionException {\n    InsecureRegistryException mockInsecureRegistryException =\n        Mockito.mock(InsecureRegistryException.class);\n    Mockito.doThrow(mockInsecureRegistryException)\n        .when(mockJibContainerBuilder)\n        .containerize(mockContainerizer);\n\n    try {\n      testJibBuildRunner.runBuild();\n      Assert.fail();\n\n    } catch (BuildStepsExecutionException ex) {\n      Assert.assertEquals(TEST_HELPFUL_SUGGESTIONS.forInsecureRegistry(), ex.getMessage());\n    }\n  }\n\n\n\n ##dense 4 0.724872350692749 \n  @Test\n  public void testBuildImage_registryCredentialsNotSentException()\n      throws InterruptedException, IOException, CacheDirectoryCreationException, RegistryException,\n          ExecutionException {\n    Mockito.doThrow(mockRegistryCredentialsNotSentException)\n        .when(mockJibContainerBuilder)\n        .containerize(mockContainerizer);\n\n    try {\n      testJibBuildRunner.runBuild();\n      Assert.fail();\n\n    } catch (BuildStepsExecutionException ex) {\n      Assert.assertEquals(TEST_HELPFUL_SUGGESTIONS.forCredentialsNotSent(), ex.getMessage());\n    }\n  }\n","\n ##hybrid 0 0.016393441706895828 \n/** Integration tests for {@link BlobPuller}. */\npublic class BlobPullerIntegrationTest {\n\n  private final FailoverHttpClient httpClient = new FailoverHttpClient(true, false, ignored -> {});\n\n  @Test\n  public void testPull() throws IOException, RegistryException {\n    RegistryClient registryClient =\n        RegistryClient.factory(EventHandlers.NONE, \"gcr.io\", \"distroless/base\", httpClient)\n            .newRegistryClient();\n    V22ManifestTemplate manifestTemplate =\n        registryClient\n            .pullManifest(\n                ManifestPullerIntegrationTest.KNOWN_MANIFEST_V22_SHA, V22ManifestTemplate.class)\n            .getManifest();\n\n    DescriptorDigest realDigest = manifestTemplate.getLayers().get(0).getDigest();\n\n\n \n##hybrid 1 0.016393441706895828 \n    Mockito.doThrow(mockRegistryUnauthorizedException)\n        .when(mockJibContainerBuilder)\n        .containerize(mockContainerizer);\n\n    try {\n      testJibBuildRunner.runBuild();\n      Assert.fail();\n\n    } catch (BuildStepsExecutionException ex) {\n      Assert.assertEquals(\n          TEST_HELPFUL_SUGGESTIONS.forHttpStatusCodeForbidden(\"someregistry/somerepository\"),\n          ex.getMessage());\n    }\n  }\n\n\n \n##hybrid 2 0.016129031777381897 \n    verify(mockCredentialRetrieverFactory).known(knownCredential, \"credentialSource\");\n    verify(mockCredentialRetrieverFactory).known(inferredCredential, \"inferredCredentialSource\");\n    verify(mockCredentialRetrieverFactory)\n        .dockerCredentialHelper(\"docker-credential-credentialHelperSuffix\");\n  }\n\n\n \n##hybrid 3 0.016129031777381897 \n  @Test\n  public void testPull_unknownBlob() throws IOException, DigestException {\n    DescriptorDigest nonexistentDigest =\n        DescriptorDigest.fromHash(\n            \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\");\n\n    RegistryClient registryClient =\n        RegistryClient.factory(EventHandlers.NONE, \"gcr.io\", \"distroless/base\", httpClient)\n            .newRegistryClient();\n\n    try {\n      registryClient\n          .pullBlob(nonexistentDigest, ignored -> {}, ignored -> {})\n          .writeTo(ByteStreams.nullOutputStream());\n      Assert.fail(\"Trying to pull nonexistent blob should have errored\");\n\n    } catch (IOException ex) {\n      if (!(ex.getCause() instanceof RegistryErrorException)) {\n        throw ex;\n      }\n      MatcherAssert.assertThat(\n          ex.getMessage(),\n          CoreMatchers.containsString(\n              \"pull BLOB for gcr.io/distroless/base with digest \" + nonexistentDigest));\n    }\n  }\n}\n\n \n##hybrid 4 0.01587301678955555 \n    when(mockCredentialRetrieverFactory.dockerCredentialHelper(anyString()))\n        .thenReturn(mockDockerCredentialHelperCredentialRetriever);\n    when(mockCredentialRetrieverFactory.known(knownCredential, \"credentialSource\"))\n        .thenReturn(mockKnownCredentialRetriever);\n    when(mockCredentialRetrieverFactory.known(inferredCredential, \"inferredCredentialSource\"))\n        .thenReturn(mockInferredCredentialRetriever);\n    when(mockCredentialRetrieverFactory.wellKnownCredentialHelpers())\n        .thenReturn(mockWellKnownCredentialHelpersCredentialRetriever);\n"],"headingContent":"Discussion","anchorList":[{"label":"Caso 1: La ricerca ibrida supera la ricerca semantica","href":"Case-1-Hybrid-Search-Outperforms-Semantic-Search","type":2,"isActive":false},{"label":"Caso 2: la ricerca ibrida supera la ricerca full text","href":"Case-2-Hybrid-Search-Outperforms-Full-Text-Search","type":2,"isActive":false},{"label":"Caso 3: La ricerca ibrida (con l'aggiunta di stopword) supera la ricerca semantica","href":"Case-3-Hybrid-Search-with-Stopword-Addition-Outperforms-Semantic-Search","type":2,"isActive":false},{"label":"Conclusioni","href":"Conclusions","type":2,"isActive":false}]}