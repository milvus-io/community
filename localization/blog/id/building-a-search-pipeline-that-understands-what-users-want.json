{"codeList":["# Verify Python environment\nimport sys\nimport os\n\nprint(f\"Python version: {sys.version}\")\nprint(f\"Python executable: {sys.executable}\")\nprint(f\"Virtual environment: {os.environ.get('VIRTUAL_ENV', 'Not detected')}\")\n\nif hasattr(sys, 'real_prefix') or (hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix):\n    print(\"✓ Running in a virtual environment\")\nelse:\n    print(\"⚠ Warning: Not running in a virtual environment. Consider using uv or venv.\")\n","# Install required packages (only if you haven't used uv setup)\n# If you've already created the environment using 'uv' as shown above, you can skip this cell.\n%pip install -q pymilvus langextract google-genai pandas numpy python-dotenv pydantic jupyter ipykernel\n","import os\nimport json\nimport random\nimport textwrap\nfrom typing import List, Dict, Any, Optional\nfrom datetime import datetime\n\nimport pandas as pd\nimport numpy as np\nfrom pymilvus import MilvusClient, DataType\n\n# Google GenAI for embeddings\nfrom google import genai\nfrom google.genai.types import EmbedContentConfig\n\n# LangExtract for structured label extraction\nimport langextract as lx\n\nprint(\"All imports successful!\")\n","# Connect to Milvus (running in Docker)\nmilvus_client = MilvusClient(uri=\"http://localhost:19530\")\nprint(\"Connected to Milvus successfully!\")\n","# List of product descriptions \n# LangExtract will extract category, brand, price, rating, and stock_status from these\nPRODUCT_DESCRIPTIONS = [\"TechPro Wireless Bluetooth headphones with active noise cancellation, 30-hour battery life, premium sound quality. Price: $149. Rating: 4.5/5. In Stock.\", \n                        \"SmartGadget Smartwatch with fitness tracking, heart rate monitor, GPS, and water resistance up to 50 meters. Currently $199. Customer rating: 4.8 stars. Available now.\",\n                        \"ElectroMax 4K Ultra HD Smart TV with HDR, voice control, and streaming apps built-in. On sale for $299. Rated 4.2/5. Low Stock - only 3 left!\",\n                        \"DigitalPlus Laptop computer with fast processor, 16GB RAM, SSD storage, perfect for work and gaming. Price: $899. Rating: 4.7/5. In Stock.\", \n                        \"TechPro Wireless charging pad compatible with all smartphones, fast charging support. Just $29.99. 4.0 star rating. In Stock.\", \n                        \"StyleCo Comfortable cotton t-shirt, breathable fabric, available in multiple colors and sizes. Price: $24.99. Rating: 4.3/5. In Stock.\",\n                        \"FashionHub Running shoes with cushioned sole, lightweight design, perfect for daily jogging. $89. Customer rating: 4.6 stars. In Stock.\", \n                        \"StyleCo Yoga pants made from moisture-wicking material, flexible and comfortable. $39.99. Rating: 4.5/5. In Stock.\",  \n                        \"LiteraryPress Mystery thriller novel, bestselling author, paperback edition. $12.99. 4.3 star rating. In Stock.\",  \n                       ]\n\nprint(f\"Loaded {len(PRODUCT_DESCRIPTIONS)} product descriptions\")\nprint(\"\\nSample product description:\")\nprint(PRODUCT_DESCRIPTIONS[0])\n","# Initialize Gemini embedding model\ngenai_client = genai.Client()\n\nEMBEDDING_MODEL = \"gemini-embedding-001\"\nEMBEDDING_DIM = 3072  # Dimension for gemini-embedding-001\n\nprint(\"Gemini embedding model configured!\")\n","# Define the extraction prompt \nEXTRACTION_PROMPT = textwrap.dedent(\n    \"\"\"\\\n    Extract structured information from product descriptions.\n    Extract: category type, brand name, price value, rating value, stock status, features list, warranty info, and price range.\n\n    For the brand: Extract the brand name that appears at the beginning of the description.\n    For price: Extract just the numeric value (e.g., 149 from \"$149\")\n    For rating: Extract just the numeric value (e.g., 4.5 from \"4.5/5\")\n    For category: Identify the general product type (Electronics, Clothing, Books, etc.)\n    For stock: Extract \"In Stock\", \"Low Stock\", or \"Out of Stock\"\n    For features: Extract key product features as a comma-separated list (e.g., \"wireless, noise_cancellation, long_battery\")\n    For has_warranty: Determine if product has warranty (true/false based on context or price - electronics >$100 likely have warranty)\n    For price_range: Categorize as \"budget\" (<$50), \"mid\" ($50-$150), or \"premium\" (>$150)\n    \"\"\"\n    )\n\n# Provide examples with text span matching\nEXTRACTION_EXAMPLES = [\n    lx.data.ExampleData(\n        text=(\n            \"TechPro Wireless Bluetooth headphones with active noise cancellation, \"\n            \"30-hour battery life, premium sound quality. Price: $149.7 \"\n            \"Rating: 4.5/5. In Stock.\"\n        ),\n        extractions=[\n            lx.data.Extraction(\n                extraction_class=\"category\",\n                extraction_text=\"headphones\",\n                attributes={\"type\": \"Electronics\"}\n            ),\n            lx.data.Extraction(\n                extraction_class=\"brand\",\n                extraction_text=\"TechPro Wireless Bluetooth headphones with active noise cancellation, 30-hour battery life, premium sound quality\",\n                attributes={\"name\": \"TechPro\"}\n            ),\n            lx.data.Extraction(\n                extraction_class=\"price\",\n                extraction_text=\"149.7\",\n                attributes={\"value\": 149.7}\n            ),\n            lx.data.Extraction(\n                extraction_class=\"rating\",\n                extraction_text=\"4.5\",\n                attributes={\"value\": 4.5}\n            ),\n            lx.data.Extraction(\n                extraction_class=\"stock_status\",\n                extraction_text=\"In Stock\",\n                attributes={\"status\": \"In Stock\"}\n            ),\n            lx.data.Extraction(\n                extraction_class=\"features\",\n                extraction_text=\"Wireless Bluetooth headphones with active noise cancellation, 30-hour battery life, premium sound quality\",\n                attributes={\"list\": \"wireless, bluetooth, noise_cancellation, long_battery, premium_sound\"}\n            ),\n            lx.data.Extraction(\n                extraction_class=\"has_warranty\",\n                extraction_text=\"TechPro Wireless Bluetooth headphones\",\n                attributes={\"value\": True}\n            ),\n            lx.data.Extraction(\n                extraction_class=\"price_range\",\n                extraction_text=\"149.7\",\n                attributes={\"range\": \"mid\"}\n            ),\n        ]\n    ),\n    lx.data.ExampleData(\n        text=(\n            \"StyleCo Comfortable cotton t-shirt, breathable fabric, available in multiple colors \"\n            \"and sizes. Price: $24.99. Rating: 4.3/5. In Stock.\"\n        ),\n        extractions=[\n            lx.data.Extraction(\n                extraction_class=\"category\",\n                extraction_text=\"t-shirt\",\n                attributes={\"type\": \"Clothing\"}\n            ),\n            lx.data.Extraction(\n                extraction_class=\"brand\",\n                extraction_text=\"StyleCo Comfortable cotton t-shirt, breathable fabric, available in multiple colors and sizes\",\n                attributes={\"name\": \"StyleCo\"}\n            ),\n            lx.data.Extraction(\n                extraction_class=\"price\",\n                extraction_text=\"24.99\",\n                attributes={\"value\": 24.99}\n            ),\n            lx.data.Extraction(\n                extraction_class=\"rating\",\n                extraction_text=\"4.3\",\n                attributes={\"value\": 4.3}\n            ),\n            lx.data.Extraction(\n                extraction_class=\"stock_status\",\n                extraction_text=\"In Stock\",\n                attributes={\"status\": \"In Stock\"}\n            ),\n            lx.data.Extraction(\n                extraction_class=\"features\",\n                extraction_text=\"Comfortable cotton t-shirt, breathable fabric, available in multiple colors and sizes\",\n                attributes={\"list\": \"comfortable, cotton, breathable, multiple_colors\"}\n            ),\n            lx.data.Extraction(\n                extraction_class=\"has_warranty\",\n                extraction_text=\"t-shirt\",\n                attributes={\"value\": False}\n            ),\n            lx.data.Extraction(\n                extraction_class=\"price_range\",\n                extraction_text=\"24.99\",\n                attributes={\"range\": \"budget\"}\n            ),\n        ]\n    ),\n    lx.data.ExampleData(\n        text=(\n            \"ElectroMax 4K Ultra HD Smart TV with HDR, voice control, and streaming apps built-in. \"\n            \"On sale for $299. Rated 4.2/5. Low Stock - only 3 left!\"\n        ),\n        extractions=[\n            lx.data.Extraction(\n                extraction_class=\"category\",\n                extraction_text=\"Smart TV\",\n                attributes={\"type\": \"Electronics\"}\n            ),\n            lx.data.Extraction(\n                extraction_class=\"brand\",\n                extraction_text=\"ElectroMax 4K Ultra HD Smart TV with HDR, voice control, and streaming apps built-in\",\n                attributes={\"name\": \"ElectroMax\"}\n            ),\n            lx.data.Extraction(\n                extraction_class=\"price\",\n                extraction_text=\"299\",\n                attributes={\"value\": 299}\n            ),\n            lx.data.Extraction(\n                extraction_class=\"rating\",\n                extraction_text=\"4.2\",\n                attributes={\"value\": 4.2}\n            ),\n            lx.data.Extraction(\n                extraction_class=\"stock_status\",\n                extraction_text=\"Low Stock\",\n                attributes={\"status\": \"Low Stock\"}\n            ),\n            lx.data.Extraction(\n                extraction_class=\"features\",\n                extraction_text=\"4K Ultra HD Smart TV with HDR, voice control, and streaming apps built-in\",\n                attributes={\"list\": \"4k, hd, hdr, voice_control, streaming, smart_tv\"}\n            ),\n            lx.data.Extraction(\n                extraction_class=\"has_warranty\",\n                extraction_text=\"Smart TV\",\n                attributes={\"value\": True}\n            ),\n            lx.data.Extraction(\n                extraction_class=\"price_range\",\n                extraction_text=\"299\",\n                attributes={\"range\": \"premium\"}\n            ),\n        ]\n    ),\n]\n\n\ndef extract_labels_with_langextract(\n    text: str, \n    model_id: str = \"gemini-2.5-flash-lite\" \n) -> Dict[str, Any]:\n    \"\"\"\n    Extract structured labels from product text using LangExtract.\n\n    Args:\n        text: Product description text.\n        model_id: LangExtract model to use (default: \"gemini-2.5-flash-lite\").\n\n    Returns:\n        Dictionary with extracted labels: category, brand, price, rating, stock_status.\n    \"\"\"\n    try:\n        # Check if API key is set\n        if \"GEMINI_API_KEY\" not in os.environ and \"GOOGLE_API_KEY\" not in os.environ:\n            print(\"⚠️  Warning: GEMINI_API_KEY not found in environment.\")\n            print(\"   Get your API key from https://aistudio.google.com/app/apikey\")\n            print(\"   Falling back to default values.\")\n\n            return {\n                \"category\": \"Unknown\",\n                \"brand\": \"Unknown\",\n                \"price\": 0,\n                \"rating\": 0,\n                \"stock_status\": \"Unknown\",\n                \"features\": \"\",\n                \"has_warranty\": False,\n                \"price_range\": \"Unknown\"\n            }\n\n        # Run LangExtract extraction\n        result = lx.extract(\n            text_or_documents=text,\n            prompt_description=EXTRACTION_PROMPT,\n            examples=EXTRACTION_EXAMPLES,\n            model_id=model_id,\n        )\n\n        # Defaults\n        category = \"Unknown\"\n        brand = \"Unknown\"\n        price = 0\n        rating = 0\n        stock_status = \"Unknown\"\n        features = \"\"\n        has_warranty = False\n        price_range = \"Unknown\"\n\n        # Parse extraction results\n        if hasattr(result, \"extractions\") and result.extractions:\n            for extraction in result.extractions:\n                if extraction.extraction_class == \"category\":\n                    category = extraction.attributes.get(\"type\", \"Unknown\")\n\n                elif extraction.extraction_class == \"brand\":\n                    brand = extraction.attributes.get(\"name\", \"Unknown\")\n\n                elif extraction.extraction_class == \"price\":\n                    price_value = extraction.attributes.get(\"value\", 0)\n                    # Handle both numeric and string values, keep as float for decimal prices\n                    if isinstance(price_value, (int, float)):\n                        price = float(price_value)\n                    elif isinstance(price_value, str):\n                        try:\n                            # Remove $ and commas, then convert\n                            clean_price = price_value.replace('$', '').replace(',', '')\n                            price = float(clean_price)\n                        except:\n                            price = 0.0\n\n                elif extraction.extraction_class == \"rating\":\n                    rating_value = extraction.attributes.get(\"value\", 0)\n                    # Handle both numeric and string values, keep as float for decimal ratings\n                    if isinstance(rating_value, (int, float)):\n                        rating = float(rating_value)\n                    elif isinstance(rating_value, str):\n                        try:\n                            rating = float(rating_value)\n                        except:\n                            rating = 0.0\n\n                elif extraction.extraction_class == \"stock_status\":\n                    stock_status = extraction.attributes.get(\"status\", \"Unknown\")\n\n                elif extraction.extraction_class == \"features\":\n                    features = extraction.attributes.get(\"list\", \"\")\n\n                elif extraction.extraction_class == \"has_warranty\":\n                    warranty_value = extraction.attributes.get(\"value\", False)\n                    if isinstance(warranty_value, bool):\n                        has_warranty = warranty_value\n                    elif isinstance(warranty_value, str):\n                        has_warranty = warranty_value.lower() in [\"true\", \"yes\", \"1\"]\n\n                elif extraction.extraction_class == \"price_range\":\n                    price_range = extraction.attributes.get(\"range\", \"Unknown\")\n\n        return {\n            \"category\": category,\n            \"brand\": brand,\n            \"price\": price,\n            \"rating\": rating,\n            \"stock_status\": stock_status,\n            \"features\": features,\n            \"has_warranty\": has_warranty,\n            \"price_range\": price_range,\n        }\n\n    except Exception as e:\n        print(f\"⚠️  Error extracting labels with LangExtract: {e}\")\n\n        return {\n            \"category\": \"Unknown\",\n            \"brand\": \"Unknown\",\n            \"price\": 0,\n            \"rating\": 0,\n            \"stock_status\": \"Unknown\",\n            \"features\": \"\",\n            \"has_warranty\": False,\n            \"price_range\": \"Unknown\"\n        }\n\n\nprint(\"Label extraction function with LangExtract defined!\")\n","# Collection name\nCOLLECTION_NAME = \"product_search\"\n\n# Drop collection if it exists\nif milvus_client.has_collection(COLLECTION_NAME):\n    milvus_client.drop_collection(COLLECTION_NAME)\n    print(f\"Dropped existing collection: {COLLECTION_NAME}\")\n\n# Create the collection schema\nschema = milvus_client.create_schema(auto_id=False, enable_dynamic_field=False)\n# Define the schema fields\nschema.add_field(field_name=\"id\", datatype=DataType.INT64, is_primary=True)\nschema.add_field(field_name=\"text\", datatype=DataType.VARCHAR, max_length=1000)\nschema.add_field(field_name=\"embedding\", datatype=DataType.FLOAT_VECTOR, dim=EMBEDDING_DIM)  # gemini-embedding-001\nschema.add_field(field_name=\"category\", datatype=DataType.VARCHAR, max_length=100)\nschema.add_field(field_name=\"brand\", datatype=DataType.VARCHAR, max_length=100)\nschema.add_field(field_name=\"price\", datatype=DataType.DOUBLE)\nschema.add_field(field_name=\"rating\", datatype=DataType.DOUBLE)  # supports decimal ratings like 4.5\nschema.add_field(field_name=\"stock_status\", datatype=DataType.VARCHAR, max_length=50)\nschema.add_field(field_name=\"features\", datatype=DataType.VARCHAR, max_length=500)  # comma-separated feature list\nschema.add_field(field_name=\"has_warranty\", datatype=DataType.BOOL)\nschema.add_field(field_name=\"price_range\", datatype=DataType.VARCHAR, max_length=50)  # budget, mid, premium\n\n# Create the collection\ncollection = Collection(\n    name=COLLECTION_NAME,\n    schema=schema\n)\n\n# Create index on the embedding field for faster searches\nindex_params = milvus_client.prepare_index_params()\nindex_params.add_index(\n    field_name=\"embedding\",\n    index_type=\"IVF_FLAT\",\n    metric_type=\"L2\",\n    params={\"nlist\": 128},\n)\nmilvus_client.create_collection(\n    collection_name=COLLECTION_NAME,\n    schema=schema,\n    index_params=index_params,\n)\nprint(f\"Collection '{COLLECTION_NAME}' created successfully!\")\n","# Suppress absl prompt alignment warnings (non-critical fuzzy match warnings)\nimport warnings\nimport logging\nwarnings.filterwarnings(\"ignore\", message=\".*Prompt alignment: non-exact match.*\", category=UserWarning)\nlogging.getLogger(\"absl\").setLevel(logging.ERROR)\n","# Extract structured labels from descriptions using LangExtract\ndef prepare_data_for_insertion(\n    product_descriptions: List[str],\n    genai_client,\n    embedding_model: str,\n    embedding_dim: int\n) -> List[List]:\n    \"\"\"Prepares products for insertion into Milvus by extracting labels from descriptions.\"\"\"\n    \n    ids = []\n    texts = []\n    embeddings = []\n    categories = []\n    brands = []\n    prices = []\n    ratings = []\n    stock_statuses = []\n    features_list = []\n    warranties = []\n    price_ranges = []\n\n    # Extract structured labels from each description using LangExtract\n    print(\"Extracting structured labels from product descriptions using LangExtract...\")\n\n    products = []\n    for idx, description in enumerate(product_descriptions):\n\n        # Extract labels using LangExtract\n        labels = extract_labels_with_langextract(description)\n\n        # Create product dict with extracted labels\n        product = {\n            \"id\": idx + 1,\n            \"text\": description,\n            \"category\": labels.get(\"category\", \"Unknown\"),\n            \"brand\": labels.get(\"brand\", \"Unknown\"),\n            \"price\": labels.get(\"price\", 0),\n            \"rating\": labels.get(\"rating\", 0),\n            \"stock_status\": labels.get(\"stock_status\", \"Unknown\"),\n            \"features\": labels.get(\"features\", \"\"),\n            \"has_warranty\": labels.get(\"has_warranty\", False),\n            \"price_range\": labels.get(\"price_range\", \"Unknown\")\n        }\n        products.append(product)\n\n        if (idx + 1) % 10 == 0:\n            print(f\"  Processed {idx + 1}/{len(product_descriptions)} products...\")\n\n    print(f\"\\nExtracted labels from {len(products)} products\")\n    print(\"\\nSample extracted product:\")\n    print(json.dumps(products[0], indent=2))\n\n    # Get all the text descriptions for embedding generation\n    product_texts = [p[\"text\"] for p in products]\n\n    # Generate embeddings using Gemini API\n    print(\"\\nGenerating embeddings...\")\n    embedding_response = genai_client.models.embed_content(\n        model=embedding_model,\n        contents=product_texts,\n        config=EmbedContentConfig(\n            task_type=\"SEMANTIC_SIMILARITY\",\n            output_dimensionality=embedding_dim,\n        ),\n    )\n\n    # Extract embeddings from response\n    product_embeddings = [emb.values for emb in embedding_response.embeddings]\n\n    # Build arrays\n    for i, product in enumerate(products):\n        ids.append(product[\"id\"])\n        texts.append(product[\"text\"])\n        embeddings.append(product_embeddings[i])\n        categories.append(product[\"category\"])\n        brands.append(product[\"brand\"])\n        prices.append(product[\"price\"])\n        ratings.append(product[\"rating\"])\n        stock_statuses.append(product[\"stock_status\"])\n        features_list.append(product[\"features\"])\n        warranties.append(product[\"has_warranty\"])\n        price_ranges.append(product[\"price_range\"])\n\n    return [\n        ids,\n        texts,\n        embeddings,\n        categories,\n        brands,\n        prices,\n        ratings,\n        stock_statuses,\n        features_list,\n        warranties,\n        price_ranges\n    ]\n\n\n# Prepare the data by extracting labels from descriptions\nmilvus_client.insert(collection_name=COLLECTION_NAME, data=rows_to_insert)\n\nprint(f\"\\nInserted {len(PRODUCT_DESCRIPTIONS)} products into Milvus!\")\n","# Main search function - combines semantic search with filters\ndef semantic_search_with_filters(\n    query: str,\n    milvus_client: MilvusClient,\n    collection_name: str,\n    genai_client,\n    embedding_model: str,\n    embedding_dim: int,\n    top_k: int = 10,\n    category: Optional[str] = None,\n    brand: Optional[str] = None,\n    max_price: Optional[int] = None,\n    min_price: Optional[int] = None,\n    min_rating: Optional[int] = None,\n    stock_status: Optional[str] = None\n) -> List[Dict[str, Any]]:\n    \"\"\"\n    Does semantic search with optional filters on structured fields.\n    Returns list of products matching the query.\n    \"\"\"\n    \n    # First, convert the query to an embedding vector using Gemini\n    query_embedding_response = genai_client.models.embed_content(\n        model=embedding_model,\n        contents=[query],\n        config=EmbedContentConfig(\n            task_type=\"RETRIEVAL_QUERY\",\n            output_dimensionality=embedding_dim,\n        ),\n    )\n    query_vec = query_embedding_response.embeddings[0].values\n    \n    # Build up the filter expression piece by piece\n    filters = []\n    \n    if category:\n        filters.append(f'category == \"{category}\"')\n    \n    if brand:\n        filters.append(f'brand == \"{brand}\"')\n    \n    # Handle price range filters\n    if min_price is not None:\n        filters.append(f\"price >= {min_price}\")\n    if max_price is not None:\n        filters.append(f\"price <= {max_price}\")\n    \n    if min_rating is not None:\n        filters.append(f\"rating >= {min_rating}\")\n    \n    if stock_status:\n        filters.append(f'stock_status == \"{stock_status}\"')\n    \n    # Join all filters with AND - could also do OR if needed\n    filter_str = \" and \".join(filters) if filters else None\n    \n    try:\n        # Try search with output_fields first\n        search_results = milvus_client.search(\n            data=[query_vec],\n            anns_field=\"embedding\",\n            param={\"metric_type\": \"L2\", \"params\": {\"nprobe\": 10}},\n            limit=top_k,\n            filter=filter_str,\n            output_fields=[\"text\", \"category\", \"brand\", \"price\", \"rating\", \"stock_status\", \"features\", \"has_warranty\", \"price_range\"]\n        )\n        \n        # Format the results into a nicer structure\n        output = []\n        for hits in search_results:\n            for hit in hits:\n                output.append({\n                    \"id\": hit.id,\n                    \"score\": hit.distance,\n                    \"text\": hit.entity.get(\"text\"),\n                    \"category\": hit.entity.get(\"category\"),\n                    \"brand\": hit.entity.get(\"brand\"),\n                    \"price\": hit.entity.get(\"price\"),\n                    \"rating\": hit.entity.get(\"rating\"),\n                    \"stock_status\": hit.entity.get(\"stock_status\")\n                })\n        \n        return output\n        \n    except Exception as e:\n        # Handle Milvus compatibility issue: \"Unsupported field type: 0\"\n        if \"Unsupported field type\" in str(e) or \"field type: 0\" in str(e):\n            # Fallback: search without output_fields, then query entities separately\n            search_results = client.search(\n                data=[query_vec],\n                anns_field=\"embedding\",\n                param={\"metric_type\": \"L2\", \"params\": {\"nprobe\": 10}},\n                limit=top_k,\n                filter=filter_str\n            )\n            \n            # Extract entity IDs from search results\n            entity_ids = []\n            scores_map = {}\n            for hits in search_results:\n                for hit in hits:\n                    entity_ids.append(hit.id)\n                    scores_map[hit.id] = hit.distance\n            \n            # Query entities by IDs to get the field data\n            if entity_ids:\n                # Format IDs for the query expression (Milvus uses parentheses for 'in')\n                ids_str = \"(\" + \",\".join(str(id) for id in entity_ids) + \")\"\n                entities = client.query(\n                    filter=f\"id in {ids_str}\",\n                    output_fields=[\"id\", \"text\", \"category\", \"brand\", \"price\", \"rating\", \"stock_status\", \"features\", \"has_warranty\", \"price_range\"]\n                )\n                \n                # Create a mapping of id to entity data\n                entity_map = {e[\"id\"]: e for e in entities}\n                \n                # Format results with entity data, preserving search order\n                output = []\n                for entity_id in entity_ids:\n                    if entity_id in entity_map:\n                        entity_data = entity_map[entity_id]\n                        output.append({\n                            \"id\": entity_id,\n                            \"score\": scores_map.get(entity_id, 0.0),\n                            \"text\": entity_data.get(\"text\", \"\"),\n                            \"category\": entity_data.get(\"category\", \"\"),\n                            \"brand\": entity_data.get(\"brand\", \"\"),\n                            \"price\": entity_data.get(\"price\", 0),\n                            \"rating\": entity_data.get(\"rating\", 0),\n                            \"stock_status\": entity_data.get(\"stock_status\", \"\"),\n                            \"features\": entity_data.get(\"features\", \"\"),\n                            \"has_warranty\": entity_data.get(\"has_warranty\", False),\n                            \"price_range\": entity_data.get(\"price_range\", \"\")\n                        })\n                \n                return output\n            else:\n                return []\n        else:\n            # Re-raise if it's a different error\n            raise\n\nprint(\"Search function defined!\")\n","# Example 1: Simple semantic search\nprint(\"=\" * 80)\nprint(\"Example 1: Simple Semantic Search\")\nprint(\"=\" * 80)\n\n# Try a simple query without any filters\nquery1 = \"comfortable running shoes\"\nresults1 = semantic_search_with_filters(query1, milvus_client, COLLECTION_NAME, genai_client, EMBEDDING_MODEL, EMBEDDING_DIM, top_k=5)\n\n# Print out the results\nfor i, result in enumerate(results1, 1):\n    print(f\"\\n{i}. Score: {result['score']:.4f}\")\n    print(f\"   Product: {result['text']}\")\n    print(f\"   Category: {result['category']} | Brand: {result['brand']} | Price: ${result['price']} | Rating: {result['rating']}*\")\n","# Example 2: Add a price filter\nprint(\"=\" * 80)\nprint(\"Example 2: Semantic Search with Price Filter\")\nprint(\"=\" * 80)\n\nquery2 = \"wireless headphones\"\n# Only show results under $150\nresults2 = semantic_search_with_filters(\n    query2, \n    milvus_client,\n    COLLECTION_NAME,\n    genai_client, \n    EMBEDDING_MODEL, \n    EMBEDDING_DIM,\n    top_k=5,\n    max_price=150\n)\n\nfor i, result in enumerate(results2, 1):\n    print(f\"\\n{i}. Score: {result['score']:.4f}\")\n    print(f\"   Product: {result['text']}\")\n    print(f\"   Category: {result['category']} | Brand: {result['brand']} | Price: ${result['price']} | Rating: {result['rating']}*\")\n","# Example 3: Multiple filters at once\nprint(\"=\" * 80)\nprint(\"Example 3: Semantic Search with Multiple Filters\")\nprint(\"=\" * 80)\n\nquery3 = \"smartwatch fitness tracking\"\n# Combine multiple filters: category, rating, and stock status\nresults3 = semantic_search_with_filters(\n    query3, \n    milvus_client,\n    COLLECTION_NAME,\n    genai_client, \n    EMBEDDING_MODEL, \n    EMBEDDING_DIM,\n    top_k=5,\n    category=\"Electronics\",\n    min_rating=4,\n    stock_status=\"In Stock\"\n)\n\nfor i, result in enumerate(results3, 1):\n    print(f\"\\n{i}. Score: {result['score']:.4f}\")\n    print(f\"   Product: {result['text']}\")\n    print(f\"   Category: {result['category']} | Brand: {result['brand']} | Price: ${result['price']} | Rating: {result['rating']}* | Stock: {result['stock_status']}\")\n","# RAG (Retrieval-Augmented Generation) for natural language answer generation\ntry:\n    import google.generativeai as genai\n    GEMINI_AVAILABLE = True\nexcept ImportError:\n    GEMINI_AVAILABLE = False\n    print(\"⚠️  Note: google-generativeai not installed. Install with: pip install google-generativeai\")\n    print(\"   RAG will use template-based generation. For LLM-powered RAG, install the package.\")\n\ndef rag_answer_generation(\n    query: str,\n    search_results: List[Dict[str, Any]],\n    use_llm: bool = True,\n    model: str = \"gemini-2.5-flash-lite\"\n) -> tuple:\n    \"\"\"\n    Generate a natural language answer from search results using RAG.\n    \n    Uses Gemini API for LLM-powered generation when available, falls back to template-based.\n    \n    Args:\n        query: User's search query\n        search_results: Results from semantic search\n        use_llm: Whether to use LLM (default: True, falls back to template if unavailable)\n        model: Gemini model identifier (default: \"gemini-2.5-flash-lite\")\n    \n    Returns:\n        Tuple of (answer, llm_used) where llm_used indicates if LLM was actually used\n    \"\"\"\n    \n    if not search_results:\n        return \"I couldn't find any products matching your search.\", False\n    \n    # Try LLM-based generation if requested and available\n    if use_llm and GEMINI_AVAILABLE:\n        try:\n            # Check for API key (can use GEMINI_API_KEY or GOOGLE_API_KEY)\n            api_key = os.environ.get(\"GEMINI_API_KEY\") or os.environ.get(\"GOOGLE_API_KEY\")\n            \n            if not api_key:\n                print(\"⚠️  Warning: No API key found. Set GEMINI_API_KEY or GOOGLE_API_KEY for LLM-powered RAG.\")\n                print(\"   Falling back to template-based generation.\")\n                use_llm = False\n            else:\n                # Configure Gemini\n                genai.configure(api_key=api_key)\n                \n                # Format search results as context\n                context_items = []\n                for i, result in enumerate(search_results[:5], 1):\n                    context_items.append(\n                        f\"Product {i}: {result['text']}\\n\"\n                        f\"  Category: {result['category']} | Brand: {result['brand']}\\n\"\n                        f\"  Price: ${result['price']} | Rating: {result['rating']}/5 | Stock: {result['stock_status']}\"\n                    )\n                \n                context = \"\\n\\n\".join(context_items)\n                \n                # Create the prompt\n                prompt = f\"\"\"You are a helpful e-commerce assistant. Based on the following product search results, \nprovide a natural, conversational answer to the user's query. Be concise but informative.\n\nUser Query: {query}\n\nSearch Results:\n{context}\n\nProvide a helpful answer that summarizes the best matching products. Highlight key features, prices, and ratings. \nIf there are multiple good options, mention a few. Keep the tone friendly and helpful.\"\"\"\n\n                # Generate answer using Gemini\n                gemini_model = genai.GenerativeModel(model)\n                response = gemini_model.generate_content(prompt)\n                \n                if response and response.text:\n                    return response.text.strip(), True\n                else:\n                    print(\"⚠️  Warning: Empty response from LLM. Falling back to template-based generation.\")\n                    use_llm = False\n                    \n        except Exception as e:\n            print(f\"⚠️  Error generating RAG answer with LLM: {e}\")\n            print(\"   Falling back to template-based generation.\")\n            use_llm = False\n    \n    # Template-based answer generation (fallback)\n    if len(search_results) == 1:\n        result = search_results[0]\n        answer = f\"I found a great match for '{query}':\\n\\n\"\n        answer += f\"{result['text']}\\n\"\n        answer += f\"Price: ${result['price']} | Rating: {result['rating']}/5 | Stock: {result['stock_status']}\"\n    else:\n        answer = f\"Based on your search for '{query}', I found {len(search_results)} relevant products:\\n\\n\"\n        for i, result in enumerate(search_results[:3], 1):\n            answer += f\"{i}. {result['text']}\\n\"\n            answer += f\"   ${result['price']} | {result['rating']}/5 stars | {result['stock_status']}\\n\\n\"\n        \n        if len(search_results) > 3:\n            answer += f\"... and {len(search_results) - 3} more results available.\"\n    \n    return answer, False\n\nprint(\"RAG function with LLM support defined!\")\n","# Wrapper function that combines search + RAG\ndef complete_search_pipeline(\n    query: str,\n    milvus_client,\n    COLLECTION_NAME,\n    genai_client,\n    embedding_model: str,\n    embedding_dim: int,\n    top_k: int = 10,\n    category: Optional[str] = None,\n    brand: Optional[str] = None,\n    max_price: Optional[int] = None,\n    min_price: Optional[int] = None,\n    min_rating: Optional[int] = None,\n    stock_status: Optional[str] = None,\n    use_rag: bool = False\n) -> Dict[str, Any]:\n    \"\"\"\n    Full pipeline: search + optional RAG answer generation.\n    Combines semantic_search_with_filters and rag_answer_generation in one function.\n    \"\"\"\n    \n    # Do the actual search first\n    search_results = semantic_search_with_filters(\n        query=query,\n        milvus_client,\n        COLLECTION_NAME,\n        genai_client=genai_client,\n        embedding_model=embedding_model,\n        embedding_dim=embedding_dim,\n        top_k=top_k,\n        category=category,\n        brand=brand,\n        max_price=max_price,\n        min_price=min_price,\n        min_rating=min_rating,\n        stock_status=stock_status\n    )\n    \n    # Generate a natural language answer\n    rag_answer = None\n    used_llm = False\n    \n    if use_rag:\n        # Try to use LLM, falls back to template if API key missing\n        rag_answer, used_llm = rag_answer_generation(\n            query, \n            search_results, \n            use_llm=True, \n            model=\"gemini-2.5-flash-lite\"\n        )\n    \n    # Return everything in a dict\n    return {\n        \"query\": query,\n        \"results\": search_results,\n        \"count\": len(search_results),\n        \"answer\": rag_answer,\n        \"rag_used\": use_rag,\n        \"rag_llm_used\": used_llm\n    }\n\nprint(\"Complete pipeline function defined!\")\n","# Test the complete pipeline\nprint(\"=\" * 80)\nprint(\"Complete Search Pipeline Demo\")\nprint(\"=\" * 80)\n# Run the full pipeline with RAG enabled\nresult = complete_search_pipeline(\n        query=\"affordable fitness equipment\",\n        milvus_client,\n        COLLECTION_NAME,\n        genai_client=genai_client,\n        embedding_model=EMBEDDING_MODEL,\n        embedding_dim=EMBEDDING_DIM,\n        top_k=5,\n        category=\"Clothing\",\n        max_price=80,\n        min_rating=3,\n        use_rag=True\n    )\n# Display the results\nprint(f\"\\nQuery: {result['query']}\")\nprint(f\"Found {result['count']} results\")\n# print(f\"RAG used: {result['rag_used']}\")\nprint(f\"RAG LLM used: {result['rag_llm_used']}\")\nprint(f\"\\nResults:\\n\")\n\nfor i, product in enumerate(result['results'], 1):\n    print(f\"{i}. {product['text']}\")\n    print(f\"   ${product['price']} | {product['rating']}* | {product['stock_status']}\\n\")\n\nif result['answer']:\n    print(f\"\\nRAG Answer:\\n{result['answer']}\")\n"],"headingContent":"","anchorList":[{"label":"Why Semantic Search?","href":"Why-Semantic-Search","type":2,"isActive":false},{"label":"Building the Intent Aware Search Pipeline","href":"Building-the-Intent-Aware-Search-Pipeline","type":2,"isActive":false},{"label":"Setting Up Search Pipeline","href":"Setting-Up-Search-Pipeline","type":2,"isActive":false},{"label":"Connecting to Milvus: Vector database","href":"Connecting-to-Milvus-Vector-database","type":2,"isActive":false},{"label":"Creating Real World Product Dataset","href":"Creating-Real-World-Product-Dataset","type":2,"isActive":false},{"label":"Extracting Structure from Chaos","href":"Extracting-Structure-from-Chaos","type":2,"isActive":false},{"label":"Building Our Search Index: Creating the Milvus Collection","href":"Building-Our-Search-Index-Creating-the-Milvus-Collection","type":2,"isActive":false},{"label":"Semantic + Structured Filtering","href":"Semantic-+-Structured-Filtering","type":2,"isActive":false},{"label":"Putting It to the Test: Real-World Search Scenarios","href":"Putting-It-to-the-Test-Real-World-Search-Scenarios","type":2,"isActive":false},{"label":"RAG-Powered Answer Generation","href":"RAG-Powered-Answer-Generation","type":2,"isActive":false},{"label":"Wrapping Up","href":"Wrapping-Up","type":2,"isActive":false},{"label":"About the author","href":"About-the-author","type":2,"isActive":false}]}