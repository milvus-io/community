---
id: milvus2.0-redefining-vector-database.md
title: Milvus 2.0 ベクターデータベースの再定義
author: Xiaofan Luan
date: 2021-08-01T00:00:00.000Z
desc: >-
  Milvus
  2.0がリリースされました。このリファクタリングされたクラウドネイティブなバージョンは、画像/動画検索、チャットボット、その他多くのAIアプリケーションを強化します。
cover: assets.zilliz.com/2_0_cover_bbc582b347.jpg
tag: Engineering
origin: null
---
<custom-h1>Milvus 2.0：ベクター・データベースの再定義</custom-h1><p>2018年10月にMilvusの最初のコードを書いたのが昨日のことのようです。2021年3月、世界中の1,000人以上のユーザーによってテストされた19回の繰り返しの後、私たちはMilvus 1.0をリリースしました。世界で最も人気のあるオープンソースのベクターデータベースとして、Milvus 1.0はCRUD操作やデータの永続性など、ベクター管理における根本的な問題を解決することに成功しました。しかし、新たなシナリオや要件が出現するにつれ、まだまだ解決すべき課題が山積していることに気づき始めました。本記事では、過去3年間で私たちが気づいたこと、Milvus 2.0に期待される課題、そしてなぜMilvus 2.0がそのような課題に対するより良いソリューションであると考えられるのかについて振り返ります。 Milvus 2.0が提供するものについての詳細は、<a href="https://milvus.io/docs/v2.0.x/release_notes.md">Milvus 2.0リリースノートを</a>ご覧ください。</p>
<h2 id="Challenges-Milvus-1x-is-faced-with" class="common-anchor-header">Milvus 1.xが直面している課題<button data-href="#Challenges-Milvus-1x-is-faced-with" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p><strong>データのサイロ化：</strong>Milvus 1.0は、非構造化データから生成されたベクトル埋め込みのみを扱うことができ、スカラークエリをほとんどサポートしていない。また、ベクトルデータとスカラーデータのハイブリッド検索は、統一されたオプティマイザがないため、満足のいくものではありません。</p>
<p><strong>適時性と効率性のジレンマ：</strong>Milvus1.0はほぼリアルタイムのシステムであり、データの可視性を確保するために定期的または強制的なフラッシュに依存している。このアプローチは、ストリーム・データ処理の複雑さと不確実性を多くのレベルで増大させる。また、このバッチ挿入アプローチは処理効率を向上させると言われているが、それでも多くのリソースを消費する。そのため、バルクロード・アプローチが必要となる。</p>
<p><strong>スケーラビリティと弾力性に欠ける：</strong>Milvus 1.0は、拡張性を実現するためにシャーディング・ミドルウェア・ソリューションであるMishardsに依存し、データの永続化のためにネットワーク・アタッチド・ストレージ（NAS）に依存している。共有ストレージ上に構築されたこの古典的なアーキテクチャは、以下の理由により全体的なスケーラビリティにあまり寄与していない：</p>
<ol>
<li>ミシャードでは1つの書き込みノードしかサポートされておらず、スケーリングできない。</li>
<li>Mishardsの読み込みノードのスケーリングは、一貫性のあるハッシュベースのルーティングを使用して実装されています。一貫性のあるハッシュは実装が簡単で、データ分布の均一性の問題を解決するのに役立ちますが、データスケジューリングの柔軟性に欠け、データサイズと計算能力のミスマッチを解決するには不十分です。</li>
<li>Milvus1.0はメタデータの管理にMySQLを利用しているが、スタンドアローンのMySQLサーバーが扱えるクエリーやデータセットのサイズはかなり限られている。</li>
</ol>
<p><strong>高可用性に欠ける：</strong>Milvus 1.xはインメモリレプリカやディザスタリカバリのような機能を備えておらず、高可用性という点では十分ではありません。そのため、高可用性を実現するためにある程度の精度を犠牲にする可能性を探っている。</p>
<p><strong>コストが高すぎる：</strong>Milvus1.0はデータの永続性をNASに依存しており、そのコストは通常ローカルストレージやオブジェクトストレージの10倍である。ベクトル検索はコンピューティングリソースとメモリに大きく依存するため、大規模なデータセットや複雑なビジネスシナリオでは、高いコストがさらなる探索の障害となる可能性がある。</p>
<p><strong>直感的でないユーザーエクスペリエンス：</strong></p>
<ol>
<li>複雑な分散デプロイメントには高い運用コストがかかる。</li>
<li>デザイン性の高いグラフィカル・ユーザー・インターフェイス（GUI）は利用できない。</li>
<li>直感的でないAPIは、アプリケーション開発の足かせとなっている。</li>
</ol>
<p>パッチから移行するか、ゼロから始めるかは大きな問題だ。Milvusの生みの親であるチャールズ・謝は、多くの伝統的な自動車メーカーがテスラを進歩的に変えることができなかったように、Milvusが成功するためには、非構造化データ処理と分析の分野でゲームチェンジャーにならなければならないと考えている。この信念が、リファクタリングされたクラウドネイティブなベクトル・データベースであるMilvus 2.0をスタートさせる原動力となった。</p>
<h2 id="The-Making-of-Milvus-20" class="common-anchor-header">Milvus 2.0の制作過程<button data-href="#The-Making-of-Milvus-20" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><h3 id="Design-principles" class="common-anchor-header">設計原則</h3><p>次世代のクラウドネイティブなベクターデータベースとして、Milvus 2.0は以下の3つの原則に基づいて構築されています：</p>
<p><strong>クラウドネイティブファースト</strong>私たちは、ストレージとコンピューティングの分離をサポートするアーキテクチャのみが、オンデマンドでスケールし、クラウドの弾力性を最大限に活用できると信じています。また、Milvus 2.0のマイクロサービス設計にもご注目いただきたい。この設計では、読み取りと書き込みの分離、増分データと履歴データの分離、CPU集中タスク、メモリ集中タスク、IO集中タスクの分離を特徴としている。マイクロサービスは、刻々と変化する異種ワークロードに対するリソースの割り当てを最適化するのに役立ちます。</p>
<p><strong>データとしてのログ：</strong>Milvus 2.0では、ログブローカーがシステムのバックボーンとして機能する：すべてのデータの挿入と更新操作はログブローカーを経由する必要があり、ワーカーノードはログをサブスクライブして消費することでCRUD操作を実行します。この設計は、データの永続化やフラッシュバックなどのコア機能をストレージレイヤーに移すことでシステムの複雑性を軽減し、ログパブサブによってシステムの柔軟性を高め、将来のスケーリングに対応できるようにします。</p>
<p><strong>バッチ処理とストリーム処理の統合：</strong>Milvus 2.0は、インクリメンタルデータとヒストリカルデータの処理を統合した統合Lambdaアーキテクチャを実装している。Kappaアーキテクチャと比較して、Milvus 2.0はログバックフィルを導入しており、ログスナップショットとインデックスをオブジェクトストレージに保存することで、障害回復効率とクエリパフォーマンスを向上させている。Milvusは、非束縛（ストリーム）データを束縛されたウィンドウに分解するために、新しい透かし機構を採用している。この透かし機構は、ストリームデータを書き込み時間やイベント時間に応じて複数のメッセージパックにスライスし、ユーザーが時間ごとにクエリできるようにタイムラインを維持する。</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/2_0_image_1_59d7316324.png" alt="2.0 image 1.png" class="doc-image" id="2.0-image-1.png" />
   </span> <span class="img-wrapper"> <span>2.0 イメージ 1.png</span> </span></p>
<h3 id="System-architecture" class="common-anchor-header">システム・アーキテクチャ</h3><p>前述したように、Milvus 2.0の設計は、ストレージとコンピューティングの分離、コントロールプレーンとデータプレーンの分離という原則に厳格に従っている。システムは、アクセスレイヤー、コーディネータサービス、ワーカーノード、ストレージの4つのレイヤーに分かれている。</p>
<p><strong>アクセス層</strong>インターフェース：アクセスレイヤーはシステムのフロントレイヤーであり、ユーザーに対するエンドポイントである。リクエストの転送と結果の収集を担当する。</p>
<p><strong>コーディネーター・サービス：</strong>ワーカーノードにタスクを割り当て、システムの頭脳として機能する。ルート・コーディネータ（root coordinator）、データ・コーディネータ（data coordinator）、クエリ・コーディネータ（query coordinator）、インデックス・コーディネータ（index coordinator）の4種類がある。</p>
<p><strong>ワーカーノード：</strong>手足。ワーカーノードは、コーディネータサービスからの指示に従い、アクセスレイヤーからの読み書き要求に応答するダムエグゼキュータです。ワーカーノードには、データノード、クエリーノード、インデックスノードの3種類がある。</p>
<p><strong>ストレージ：</strong>骨。ストレージには、メタ・ストレージ、ログ・ブローカー、オブジェクト・ストレージの3種類がある。</p>
<ul>
<li>etcdによって実装されるメタ・ストレージは、コーディネータ・サービスのコレクションやチェックポイントなどのメタデータを格納するために使用される。</li>
<li>Pulsarによって実装されるログ・ブローカーは、主に増分ログを保存し、信頼性の高い非同期通知を実装するために使用される。</li>
<li>MinIOまたはS3によって実装されるオブジェクト・ストレージは、主にログのスナップショットとインデックス・ファイルを格納するために使用される。</li>
</ul>
<p>以下はMilvus 2.0のシステムアーキテクチャ図である。<span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/2_0_image_2_2cc7d7fc9c.png" alt="2.0 image 2.png" class="doc-image" id="2.0-image-2.png" />2.<span>0 image 2.png</span> </span></p>
<h3 id="Key-features" class="common-anchor-header">主な特徴</h3><p>データベースの運用コストには、実行時のリソース消費だけでなく、潜在的な学習コストや運用・保守コストも含まれる。実用的に言えば、データベースがユーザーフレンドリーであればあるほど、そのような潜在的なコストを削減できる可能性が高くなります。Milvusは初日から、使いやすさを常に最優先しており、最新のMilvus 2.0には、そのようなコストを削減するための要素が数多く含まれています。</p>
<h4 id="Always-online" class="common-anchor-header">常時オンライン</h4><p>データの信頼性とサービスの持続性はデータベースの基本要件であり、私たちの戦略は「安く、小さく、頻繁に失敗する」ことです。</p>
<ul>
<li>「フェイル・チープ」とは、ストレージとコンピューティングを分離することで、ノードの障害復旧を簡単かつ低コストで処理できるようにすることです。</li>
<li>「フェイル・スモール」とは「分割統治」戦略のことで、各コーディネータ・サービスがリード／ライト／インクリメンタル／ヒストリカル・データのごく一部だけを処理することで、設計の複雑さを単純化する。</li>
<li>「Fail often（頻繁に失敗する）」とは、カオス・テストの導入のことで、テスト環境でフォールト・インジェクションを使用することで、ハードウェア障害や依存関係障害などの状況をシミュレートし、バグ発見を加速させる。</li>
</ul>
<h4 id="Hybrid-search-between-scalar-and-vector-data" class="common-anchor-header">スカラーデータとベクトルデータのハイブリッド検索</h4><p>構造化データと非構造化データの相乗効果を活用するため、Milvus 2.0はスカラーデータとベクトルデータの両方をサポートし、それらの間のハイブリッド検索を可能にした。ハイブリッド検索は、フィルタ条件に一致する近似最近傍データの検索を支援します。現在、MilvusはEQUAL、GREATER THAN、LESS THANなどの関係演算とNOT、AND、OR、INなどの論理演算をサポートしています。</p>
<h4 id="Tunable-consistency" class="common-anchor-header">調整可能な一貫性</h4><p>PACELCの定理に従った分散データベースとして、Milvus 2.0は一貫性と可用性およびレイテンシをトレードオフしなければなりません。ほとんどのシナリオにおいて、実運用においてデータの一貫性を強調しすぎることはやりすぎになる可能性があります。それでも、我々は、<em>strong、bounded staleness、sessionの</em>ような一貫性レベルにはそれぞれ独自の用途があると考えています。そのため、Milvusはリクエストレベルで一貫性を調整することができます。テストを例にとると、ユーザはテスト結果が絶対に正しいことを保証するために<em>強い</em>一貫性を必要とするかもしれません。</p>
<h4 id="Time-travel" class="common-anchor-header">タイムトラベル</h4><p>データエンジニアはしばしば、汚れたデータやコードのバグを修正するためにデータのロールバックを行う必要があります。従来のデータベースでは、スナップショットやデータの再トレーニングによってデータのロールバックを行うのが一般的でした。これは過剰なオーバーヘッドとメンテナンスコストをもたらす可能性があります。Milvusは全てのデータ挿入・削除操作のタイムラインを保持し、ユーザはクエリでタイムスタンプを指定することで、指定した時点のデータビューを取得することができます。タイムトラベルにより、Milvusは軽量なデータバックアップやデータクローンを実装することもできます。</p>
<h4 id="ORM-Python-SDK" class="common-anchor-header">ORM Python SDK</h4><p>オブジェクトリレーショナルマッピング(ORM)は、ユーザが基礎となるデータモデルよりも上位のビジネスモデルに集中できるようにし、開発者がコレクション、フィールド、プログラム間のリレーションを管理しやすくします。AIアルゴリズムの概念実証（PoC）と本番展開の間のギャップを埋めるために、組み込みライブラリ、スタンドアロン展開、分散クラスタ、あるいはクラウドサービスでも動作可能なPyMilvus ORM APIを設計した。統一されたAPIセットにより、ユーザーに一貫したユーザーエクスペリエンスを提供し、コードの移行や適応のコストを削減します。</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/2_0_image_3_55394d6e80.png" alt="2.0 image 3.png" class="doc-image" id="2.0-image-3.png" />
   </span> <span class="img-wrapper"> <span>2.0イメージ 3.png</span> </span></p>
<h4 id="Supporting-tools" class="common-anchor-header">サポートツール</h4><ul>
<li>Milvus Insightは、クラスタの状態管理、メタ管理、データクエリなどの実用的な機能を提供するMilvusのグラフィカルユーザインタフェースです。Milvus Insightのソースコードも独立したプロジェクトとしてオープンソース化される予定です。私たちはこの取り組みに参加してくださる貢献者を募集しています。</li>
<li>OOBE（アウト・オブ・ボックス・エクスペリエンス）、より迅速なデプロイメント：Milvus 2.0はhelmまたはdocker-composeを使ってデプロイできます。</li>
<li>Milvus 2.0は、オープンソースの時系列データベースであるPrometheusを使用してパフォーマンスと監視データを保存し、オープンな観測可能性プラットフォームであるGrafanaを使用してメトリクスを可視化します。</li>
</ul>
<h2 id="Looking-to-the-future" class="common-anchor-header">将来に向けて<button data-href="#Looking-to-the-future" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>振り返ってみると、ビッグデータ＋AI活用を前提としたシステム・アーキテクチャは複雑すぎると考えている。Milvusコミュニティの最優先事項は、常にMilvusをより使いやすくすることです。今後、Milvusプロジェクトは以下の分野に注力していく：</p>
<p><strong>AIのためのDB：</strong>基本的なCRUD機能に加えて、Milvusはデータベースシステムとして、よりスマートなクエリオプティマイザ、より強力なデータクエリ機能、より包括的なデータ管理機能を持つ必要があります。次の段階では、Milvus 2.0ではまだ利用できないデータ操作言語（DML）関数やデータ型に焦点を当て、削除や更新操作の追加、文字列データ型のサポートなどを行う予定です。</p>
<p><strong>AI for DB:</strong>インデックスの種類、システム構成、ユーザの作業負荷、ハードウェアの種類などのパラメータをノブチューニングすることは、Milvusの使用を複雑にするため、できるだけ避けるべきです。システム負荷の分析とデータのアクセス頻度の収集に着手し、将来的には自動チューニングを導入して学習コストを削減する予定です。</p>
<p><strong>コストの最適化</strong>ベクトル検索の最大の課題は、膨大なデータセットを限られた時間内に処理する必要があることだ。これはCPU集約型であると同時にメモリ集約型でもある。物理層にGPUとFPGAのヘテロジニアスハードウェアアクセラレーションを導入することで、CPUのオーバーヘッドを大幅に削減することができる。また、オンディスクとインメモリーのハイブリッドANNインデックス作成アルゴリズムを開発し、限られたメモリーで巨大データセットに対する高性能クエリーを実現している。さらに、ScaNNやNGTといった既存のオープンソースのベクトルインデキシングアルゴリズムの性能評価も行っている。</p>
<p><strong>使いやすさ</strong>Milvusは、クラスタ管理ツール、多言語SDK、デプロイツール、運用ツールなどを提供することで、使いやすさを改善し続けています。</p>
<p>Milvusのリリース計画については、<a href="https://milvus.io/docs/v2.0.x/roadmap.md">Milvusロードマップを</a>ご覧ください。</p>
<p>Milvus2.0はMilvusコミュニティの貢献者の皆様のおかげで実現することができました。Milvusコミュニティへの<a href="https://github.com/milvus-io/milvus">課題の提出や</a> <a href="https://github.com/milvus-io/milvus">コードの貢献は</a>お気軽にどうぞ！</p>
<p><br/></p>
<p><em>作者について</em></p>
<p><em>Xiaofan Luanは現在、MilvusプロジェクトのR&amp;Dを管理するエンジニアリングディレクターとしてZillizで働いている。データベース/ストレージシステムの構築を中心に7年の実務経験を持つ。コーネル大学卒業後、オラクル、HEDVIG、アリババクラウドに連続勤務。</em></p>
