---
id: milvus-supports-apache-parquet-file-supports.md
title: >-
  Milvus unterstützt den Import von Apache Parquet-Dateien für eine effizientere
  Datenverarbeitung
author: 'Cai Zhang, Fendy Feng'
date: 2024-3-8
desc: >-
  Durch den Einsatz von Apache Parquet können Benutzer ihre Datenimportprozesse
  rationalisieren und erhebliche Einsparungen bei den Speicher- und Rechenkosten
  erzielen.
metaTitle: Milvus Supports Imports of Apache Parquet Files
cover: assets.zilliz.com/Milvus_Supports_the_Imports_of_Parquet_Files_3288e755b8.png
tag: Engineering
tags: >-
  Data science, Database, Tech, Artificial Intelligence, Vector Management,
  Milvus
recommend: true
canonicalUrl: 'https://milvus.io/blog/milvus-supports-apache-parquet-file-supports.md'
---
<p><a href="https://zilliz.com/what-is-milvus">Milvus</a>, die hoch skalierbare Vektordatenbank, die für ihre Fähigkeit bekannt ist, große Datenmengen zu verarbeiten, macht einen bedeutenden Schritt nach vorn, indem sie in <a href="https://zilliz.com/blog/what-is-new-in-milvus-2-3-4">Version 2.3.4</a> die Unterstützung von Parquet-Dateien einführt. Durch den Einsatz von Apache Parquet können Benutzer ihre Datenimportprozesse rationalisieren und erhebliche Einsparungen bei den Speicher- und Berechnungskosten erzielen.</p>
<p>In unserem letzten Beitrag gehen wir auf die Vorteile von Parquet und die Vorteile für Milvus-Benutzer ein. Wir erörtern die Beweggründe für die Integration dieser Funktion und bieten eine Schritt-für-Schritt-Anleitung für den nahtlosen Import von Parquet-Dateien in Milvus, wodurch neue Möglichkeiten für eine effiziente Datenverwaltung und -analyse erschlossen werden.</p>
<h2 id="What-Is-Apache-Parquet" class="common-anchor-header">Was ist Apache Parquet?<button data-href="#What-Is-Apache-Parquet" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p><a href="https://parquet.apache.org/">Apache Parquet</a> ist ein beliebtes, spaltenorientiertes Open-Source-Datendateiformat, das die Effizienz der Speicherung und Verarbeitung großer Datensätze verbessern soll. Im Gegensatz zu herkömmlichen zeilenorientierten Datenformaten wie CSV oder JSON speichert Parquet Daten spaltenweise und bietet effizientere Datenkomprimierungs- und Kodierungsverfahren. Dieser Ansatz führt zu einer verbesserten Leistung, einem geringeren Speicherbedarf und einer verbesserten Verarbeitungsleistung und ist damit ideal für die Verarbeitung komplexer Daten in großen Mengen.</p>
<h2 id="How-Milvus-Users-Benefit-from-the-Support-for-Parquet-File-Imports" class="common-anchor-header">Wie Milvus-Benutzer von der Unterstützung für Parquet-Datei-Importe profitieren<button data-href="#How-Milvus-Users-Benefit-from-the-Support-for-Parquet-File-Imports" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Milvus erweitert die Unterstützung für Parquet-Datei-Importe und bietet den Anwendern optimierte Erfahrungen und verschiedene Vorteile, einschließlich geringerer Speicher- und Rechenkosten, rationalisierter Datenverwaltung und eines vereinfachten Importprozesses.</p>
<h3 id="Optimized-Storage-Efficiency-and-Streamlined-Data-Management" class="common-anchor-header">Optimierte Speichereffizienz und gestrafftes Datenmanagement</h3><p>Parquet bietet flexible Komprimierungsoptionen und effiziente Kodierungsschemata für unterschiedliche Datentypen, die eine optimale Speichereffizienz gewährleisten. Diese Flexibilität ist besonders in Cloud-Umgebungen wertvoll, wo jedes Gramm Speicherplatzersparnis direkt mit einer spürbaren Kostenreduzierung korreliert. Mit dieser neuen Funktion in Milvus können Benutzer mühelos all ihre unterschiedlichen Daten in einer einzigen Datei konsolidieren, was die Datenverwaltung rationalisiert und die allgemeine Benutzererfahrung verbessert. Besonders vorteilhaft ist diese Funktion für Benutzer, die mit Array-Datentypen mit variabler Länge arbeiten, da diese nun von einem vereinfachten Datenimportprozess profitieren können.</p>
<h3 id="Improved-Query-Performance" class="common-anchor-header">Verbesserte Abfrageleistung</h3><p>Das spaltenförmige Speicherdesign von Parquet und die fortschrittlichen Komprimierungsmethoden verbessern die Abfrageleistung erheblich. Bei der Durchführung von Abfragen können sich die Benutzer ausschließlich auf die relevanten Daten konzentrieren, ohne die irrelevanten Daten zu durchsuchen. Dieses selektive Spaltenlesen minimiert die CPU-Auslastung, was zu schnelleren Abfragezeiten führt.</p>
<h3 id="Broad-Language-Compatibility" class="common-anchor-header">Breite Sprachkompatibilität</h3><p>Parquet ist in mehreren Sprachen wie Java, C++ und Python verfügbar und mit einer großen Anzahl von Datenverarbeitungswerkzeugen kompatibel. Durch die Unterstützung von Parquet-Dateien können Milvus-Benutzer, die verschiedene SDKs verwenden, nahtlos Parquet-Dateien zum Parsen innerhalb der Datenbank erzeugen.</p>
<h2 id="How-to-Import-Parquet-Files-into-Milvus" class="common-anchor-header">Wie man Parquet-Dateien in Milvus importiert<button data-href="#How-to-Import-Parquet-Files-into-Milvus" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Wenn Ihre Daten bereits im Parquet-Dateiformat vorliegen, ist das Importieren einfach. Laden Sie die Parquet-Datei in ein Objektspeichersystem wie MinIO hoch, und schon können Sie importieren.</p>
<p>Das folgende Code-Snippet ist ein Beispiel für den Import von Parquet-Dateien in Milvus.</p>
<pre><code translate="no">remote_files = []
<span class="hljs-keyword">try</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Prepare upload files&quot;</span>)
    minio_client = Minio(endpoint=MINIO_ADDRESS, access_key=MINIO_ACCESS_KEY, secret_key=MINIO_SECRET_KEY,
                         secure=<span class="hljs-literal">False</span>)
    found = minio_client.bucket_exists(bucket_name)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> found:
        minio_client.make_bucket(bucket_name)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;MinIO bucket &#x27;{}&#x27; doesn&#x27;t exist&quot;</span>.<span class="hljs-built_in">format</span>(bucket_name))
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>, []

    <span class="hljs-comment"># set your remote data path</span>
    remote_data_path = <span class="hljs-string">&quot;milvus_bulkinsert&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">upload_file</span>(<span class="hljs-params">f: <span class="hljs-built_in">str</span></span>):
        file_name = os.path.basename(f)
        minio_file_path = os.path.join(remote_data_path, <span class="hljs-string">&quot;parquet&quot;</span>, file_name)
        minio_client.fput_object(bucket_name, minio_file_path, f)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Upload file &#x27;{}&#x27; to &#x27;{}&#x27;&quot;</span>.<span class="hljs-built_in">format</span>(f, minio_file_path))
        remote_files.append(minio_file_path)

    upload_file(data_file)

<span class="hljs-keyword">except</span> S3Error <span class="hljs-keyword">as</span> e:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Failed to connect MinIO server {}, error: {}&quot;</span>.<span class="hljs-built_in">format</span>(MINIO_ADDRESS, e))
    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>, []

<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Successfully upload files: {}&quot;</span>.<span class="hljs-built_in">format</span>(remote_files))
<span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>, remote_files
<button class="copy-code-btn"></button></code></pre>
<p>Wenn Ihre Daten keine Parquet-Dateien sind oder dynamische Felder haben, können Sie BulkWriter, unser Datenformat-Konvertierungstool, nutzen, um Parquet-Dateien zu erzeugen. BulkWriter hat nun Parquet als Standard-Ausgabeformat übernommen, was eine intuitivere Erfahrung für Entwickler gewährleistet.</p>
<p>Das folgende Code-Snippet ist ein Beispiel für die Verwendung von BulkWriter zur Erzeugung von Parquet-Dateien.</p>
<pre><code translate="no"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> json

<span class="hljs-keyword">from</span> pymilvus <span class="hljs-keyword">import</span> (
    RemoteBulkWriter,
    BulkFileType,
)

remote_writer = RemoteBulkWriter(
        schema=your_collection_schema,
        remote_path=<span class="hljs-string">&quot;your_remote_data_path&quot;</span>,
        connect_param=RemoteBulkWriter.ConnectParam(
            endpoint=YOUR_MINIO_ADDRESS,
            access_key=YOUR_MINIO_ACCESS_KEY,
            secret_key=YOUR_MINIO_SECRET_KEY,
            bucket_name=<span class="hljs-string">&quot;a-bucket&quot;</span>,
        ),
        file_type=BulkFileType.PARQUET,
)

<span class="hljs-comment"># append your data</span>
batch_count = <span class="hljs-number">10000</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(batch_count):
    row = {
        <span class="hljs-string">&quot;id&quot;</span>: i,
        <span class="hljs-string">&quot;bool&quot;</span>: <span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> i % <span class="hljs-number">5</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span>,
        <span class="hljs-string">&quot;int8&quot;</span>: i % <span class="hljs-number">128</span>,
        <span class="hljs-string">&quot;int16&quot;</span>: i % <span class="hljs-number">1000</span>,
        <span class="hljs-string">&quot;int32&quot;</span>: i % <span class="hljs-number">100000</span>,
        <span class="hljs-string">&quot;int64&quot;</span>: i,
        <span class="hljs-string">&quot;float&quot;</span>: i / <span class="hljs-number">3</span>,
        <span class="hljs-string">&quot;double&quot;</span>: i / <span class="hljs-number">7</span>,
        <span class="hljs-string">&quot;varchar&quot;</span>: <span class="hljs-string">f&quot;varchar_<span class="hljs-subst">{i}</span>&quot;</span>,
        <span class="hljs-string">&quot;json&quot;</span>: {<span class="hljs-string">&quot;dummy&quot;</span>: i, <span class="hljs-string">&quot;ok&quot;</span>: <span class="hljs-string">f&quot;name_<span class="hljs-subst">{i}</span>&quot;</span>},
        <span class="hljs-string">&quot;vector&quot;</span>: gen_binary_vector() <span class="hljs-keyword">if</span> bin_vec <span class="hljs-keyword">else</span> gen_float_vector(),
        <span class="hljs-string">f&quot;dynamic_<span class="hljs-subst">{i}</span>&quot;</span>: i,
    }
    remote_writer.append_row(row)

<span class="hljs-comment"># append rows by numpy type</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(batch_count):
    remote_writer.append_row({
        <span class="hljs-string">&quot;id&quot;</span>: np.int64(i + batch_count),
        <span class="hljs-string">&quot;bool&quot;</span>: <span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span>,
        <span class="hljs-string">&quot;int8&quot;</span>: np.int8(i % <span class="hljs-number">128</span>),
        <span class="hljs-string">&quot;int16&quot;</span>: np.int16(i % <span class="hljs-number">1000</span>),
        <span class="hljs-string">&quot;int32&quot;</span>: np.int32(i % <span class="hljs-number">100000</span>),
        <span class="hljs-string">&quot;int64&quot;</span>: np.int64(i),
        <span class="hljs-string">&quot;float&quot;</span>: np.float32(i / <span class="hljs-number">3</span>),
        <span class="hljs-string">&quot;double&quot;</span>: np.float64(i / <span class="hljs-number">7</span>),
        <span class="hljs-string">&quot;varchar&quot;</span>: <span class="hljs-string">f&quot;varchar_<span class="hljs-subst">{i}</span>&quot;</span>,
        <span class="hljs-string">&quot;json&quot;</span>: json.dumps({<span class="hljs-string">&quot;dummy&quot;</span>: i, <span class="hljs-string">&quot;ok&quot;</span>: <span class="hljs-string">f&quot;name_<span class="hljs-subst">{i}</span>&quot;</span>}),
        <span class="hljs-string">&quot;vector&quot;</span>: gen_binary_vector() <span class="hljs-keyword">if</span> bin_vec <span class="hljs-keyword">else</span> gen_float_vector(),
        <span class="hljs-string">f&quot;dynamic_<span class="hljs-subst">{i}</span>&quot;</span>: i,
    })

<span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">{remote_writer.total_row_count}</span> rows appends&quot;</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">{remote_writer.buffer_row_count}</span> rows in buffer not flushed&quot;</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Generate data files...&quot;</span>)
remote_writer.commit()
<span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Data files have been uploaded: <span class="hljs-subst">{remote_writer.batch_files}</span>&quot;</span>)
remote_files = remote_writer.batch_files
<button class="copy-code-btn"></button></code></pre>
<p>Anschließend können Sie damit beginnen, Ihre Parquet-Dateien in Milvus zu importieren.</p>
<pre><code translate="no">remote_files = [remote_file_path]
task_id = utility.do_bulk_insert(collection_name=collection_name,
                                 files=remote_files)

task_ids = [task_id]         
states = wait_tasks_to_state(task_ids, BulkInsertState.ImportCompleted)
complete_count = 0
for state in states:
    if state.state == BulkInsertState.ImportCompleted:
        complete_count = complete_count + 1
<button class="copy-code-btn"></button></code></pre>
<p>Jetzt sind Ihre Daten nahtlos in Milvus integriert.</p>
<h2 id="Whats-Next" class="common-anchor-header">Was kommt als nächstes?<button data-href="#Whats-Next" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Da Milvus immer größere Datenmengen unterstützt, ergibt sich die Herausforderung, große Importe zu verwalten, insbesondere wenn die Parquet-Dateien 10 GB überschreiten. Um diese Herausforderung zu bewältigen, planen wir, die Importdaten in skalare und vektorielle Spalten aufzuteilen und zwei Parquet-Dateien pro Import zu erstellen, um den E/A-Druck zu verringern. Bei Datensätzen, die mehrere hundert Gigabyte überschreiten, empfehlen wir, die Daten mehrfach zu importieren.</p>
