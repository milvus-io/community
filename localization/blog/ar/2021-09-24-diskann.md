---
id: 2021-09-24-diskann.md
title: >-
  DiskANN، حل ANNS قائم على الأقراص مع استرجاع عالٍ وجودة عالية في الثانية على
  مجموعة بيانات بمليار دولار
author: Zilliz
date: 2021-09-24T00:00:00.000Z
desc: >-
  قراءة ورقة بحثية مع مهندسي Zilliz لمعرفة المزيد حول كيفية أداء DiskANN على
  مجموعة بيانات بمليار دولار.
cover: assets.zilliz.com/medium_1_10cebc1e50.png
tag: Engineering
---
<custom-h1>DiskANN: حل ANNS قائم على الأقراص مع استرجاع عالٍ وجودة عالية في الثانية على مجموعة بيانات بمليار دولار</custom-h1><blockquote>
<p>تخرج تشينجمينج لي، مهندس البحث والتطوير في شركة Zilliz، من جامعة ساوث إيست بدرجة الماجستير في علوم الكمبيوتر. ينصب تركيزه الحالي على مشاكل ANNS على البيانات عالية الأبعاد، بما في ذلك الحلول القائمة على الرسم البياني والحلول القائمة على التكميم.</p>
</blockquote>
<p>"DiskANN: بحث دقيق سريع دقيق بمليار نقطة لأقرب جار على عقدة واحدة" هي ورقة بحثية نُشرت على NeurIPS في عام 2019. تقدم هذه الورقة البحثية طريقة متطورة لإجراء بناء الفهرس والبحث على مجموعة بيانات بمليار نقطة باستخدام جهاز واحد بسعة 64 جيجابايت فقط من ذاكرة الوصول العشوائي (RAM) وذاكرة وصول عشوائي كبيرة بما يكفي. علاوةً على ذلك، فهي تفي بالمتطلبات الثلاثة لـ ANNS (البحث التقريبي لأقرب جار) على مجموعة البيانات واسعة النطاق: الاستدعاء العالي، والكمون المنخفض، والكثافة العالية (عدد العقد في جهاز واحد). تُنشئ هذه الطريقة فهرسًا قائمًا على الرسم البياني على مجموعة بيانات SIFT-1B بمقياس مليار باستخدام جهاز واحد مزود بذاكرة وصول عشوائي سعة 64 جيجابايت ووحدة معالجة مركزية ذات 16 نواة، وتصل إلى 5000 QPS (استعلام في الثانية) بنسبة استدعاء تزيد عن 95% @1، ومتوسط زمن انتقال أقل من 3 مللي ثانية.</p>
<h2 id="Authors" class="common-anchor-header">المؤلفون<button data-href="#Authors" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p><strong>سوهاس جايارام سوبرامانيا</strong>: موظف سابق في معهد مايكروسوفت الهند للأبحاث، وطالب دكتوراه في جامعة كارولينا الحكومية. اهتماماته البحثية الرئيسية هي الحوسبة عالية الأداء وخوارزميات التعلم الآلي للبيانات واسعة النطاق.</p>
<p><strong>ديفريت</strong>: مساعد باحث دراسات عليا في جامعة تكساس في أوستن. اهتماماته البحثية هي علوم الحاسوب النظرية والتعلم الآلي والتعلم العميق.</p>
<p><strong>روهان كاديكودي</strong>: طالب دكتوراه في جامعة تكساس. اتجاهه البحثي هو النظام والتخزين، بما في ذلك بشكل أساسي التخزين الدائم، ونظام الملفات، والتخزين بالكيلو فولت.</p>
<p><strong>رافيشانكار كريشاسوامي</strong>: باحث رئيسي في معهد أبحاث مايكروسوفت الهندي. دكتوراه من جامعة CMU. اتجاه البحث هو خوارزمية التقريب القائمة على الرسم البياني والتجميع.</p>
<p><strong>هارشا فاردهان سيمهادري</strong>: باحث رئيسي في معهد مايكروسوفت الهندي للأبحاث. دكتوراه من جامعة CMU. درس في الماضي الخوارزميات المتوازية وأنظمة وقت التشغيل. ويتمثل عمله الرئيسي الآن في تطوير خوارزميات جديدة وكتابة نماذج البرمجة.</p>
<h2 id="Motivations" class="common-anchor-header">الدوافع<button data-href="#Motivations" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>تقوم معظم خوارزميات ANNS السائدة بإجراء بعض المفاضلات بين أداء بناء الفهرس وأداء البحث والاسترجاع. وتُعد الخوارزميات القائمة على الرسم البياني مثل HNSW وNSG من أحدث الأساليب من حيث أداء البحث والاستدعاء في الوقت الحاضر. ونظرًا لأن طريقة الفهرسة القائمة على الرسم البياني المستندة إلى الذاكرة تشغل الكثير من الذاكرة، فمن الصعب نسبيًا فهرسة مجموعة بيانات واسعة النطاق والبحث فيها باستخدام جهاز واحد بموارد ذاكرة محدودة.</p>
<p>تتطلب العديد من التطبيقات استجابات سريعة من ANNS المستندة إلى المسافة الإقليدية على مجموعة بيانات بمليار نطاق. فيما يلي حلان رئيسيان:</p>
<ol>
<li>الفهرس المقلوب + التكميم: لتجميع مجموعة البيانات في أقسام M وضغط مجموعة البيانات باستخدام مخططات التكميم مثل PQ (التكميم الكمي للمنتج). ينتج عن هذا الحل استرجاع منخفض بسبب فقدان الدقة الناجم عن ضغط البيانات. تساعد زيادة التوب كيه في تحسين الاستدعاء بينما تنخفض دقة QPS في المقابل.</li>
<li>التقسيم والفهرسة: لتقسيم مجموعة البيانات إلى عدة أجزاء منفصلة وإنشاء فهرس في الذاكرة لكل جزء. عند ورود طلبات الاستعلام، سيتم إجراء البحث على فهارس كل جزء وسيتم إرجاع النتائج بعد الدمج. يؤدي هذا الحل إلى التوسع المفرط في نطاق مجموعة البيانات، وبالتالي هناك حاجة إلى المزيد من الأجهزة بسبب تقييد موارد الذاكرة في الجهاز الواحد، مما يؤدي إلى انخفاض معدل الاستجابة في الثانية.</li>
</ol>
<p>كلا الحلين المذكورين أعلاه مقيدان بسبب تقييد ذاكرة الجهاز الواحد. تقترح هذه الورقة البحثية تصميم آلية فهرسة مقيمة على قرص SSD لحل هذه المشكلة. ويتمثل التحدي الذي تواجهه الفهرسة المقيمة على قرص SSD في تقليل عدد مرات الوصول العشوائي إلى القرص وعدد طلبات الوصول إلى القرص.</p>
<h2 id="Contributions" class="common-anchor-header">المساهمات<button data-href="#Contributions" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>تقدم هذه الورقة البحثية مخطط فهرسة ANNS مقيم على قرص SSD يسمى DiskANN، والذي يمكن أن يدعم البحث بفعالية على مجموعات البيانات واسعة النطاق. ويستند هذا المخطط إلى خوارزمية قائمة على الرسم البياني مقدمة في هذه الورقة: Vamana. تتضمن مساهمات هذه الورقة ما يلي:</p>
<ol>
<li>يمكن ل DiskANN فهرسة والبحث في مجموعة بيانات بمليار حجم لأكثر من 100 بُعد على جهاز واحد بذاكرة وصول عشوائي سعتها 64 جيجابايت، مما يوفر أكثر من 95% استرجاع@1 مع زمن استجابة أقل من 5 مللي ثانية.</li>
<li>اقتُرحت خوارزمية جديدة قائمة على الرسم البياني تُدعى Vamana بنصف قطر بحث أصغر من تلك الخاصة ب NSG وHNSW لتقليل عدد مرات الوصول إلى القرص.</li>
<li>يمكن أن تعمل Vamana في الذاكرة وأداؤها ليس أبطأ من NSG و HNSW.</li>
<li>يمكن دمج فهارس Vamana الأصغر حجمًا المبنية على أقسام متداخلة من مجموعة البيانات الكبيرة في رسم بياني واحد دون فقدان الاتصال.</li>
<li>يمكن دمج Vamana مع مخططات التكميم مثل PQ. يتم تخزين بنية الرسم البياني والبيانات الأصلية على القرص بينما يتم الاحتفاظ بالبيانات المضغوطة في الذاكرة.</li>
</ol>
<h2 id="Vamana" class="common-anchor-header">فامانا<button data-href="#Vamana" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>هذه الخوارزمية مشابهة لفكرة NSG [2] [4] (لمن لا يفهم NSG، يرجى الرجوع إلى المرجع [2]، وإذا كنت لا تريد قراءة الأوراق، يمكنك الرجوع إلى المرجع [4]). يكمن الاختلاف الرئيسي بينهما في استراتيجية التشذيب. على وجه الدقة، تمت إضافة مفتاح ألفا إلى استراتيجية التشذيب في NSG. تتمثل الفكرة الرئيسية لاستراتيجية التشذيب الخاصة بمجموعة NSG في أن يكون اختيار جيران النقطة المستهدفة متنوعًا قدر الإمكان. إذا كان الجار الجديد أقرب إلى جار للنقطة الهدف من النقطة المستهدفة من النقطة المستهدفة، فلا نحتاج إلى إضافة هذه النقطة إلى مجموعة النقاط المجاورة. بعبارة أخرى، لكل جار للنقطة الهدف، لا يمكن أن تكون هناك نقاط مجاورة أخرى داخل نصف القطر المحيط (النقطة الهدف، النقطة المجاورة). تتحكم استراتيجية التشذيب هذه بفعالية في الدرجة الخارجية للرسم البياني، وهي جذرية نسبيًا. فهي تقلل من بصمة ذاكرة الفهرس، وتحسّن سرعة البحث، ولكنها تقلل أيضًا من دقة البحث. تتمثل استراتيجية التشذيب في فامانا في التحكم بحرية في مقياس التشذيب من خلال المعلمة ألفا. مبدأ العمل هو مضاعفة المسافة (نقطة جارة، نقطة مرشحة) في حالة التشذيب بمعامل ألفا (لا يقل عن 1). وفقط عندما تكون المسافة (النقطة المستهدفة، نقطة مرشحة معينة) أكبر من المسافة المرجعية المضاعفة يتم اعتماد استراتيجية التشذيب، مما يزيد من تفاوت الاستبعاد المتبادل بين جيران النقطة المستهدفة.</p>
<p>عملية فهرسة فامانا بسيطة نسبيًا:</p>
<ol>
<li>تهيئة رسم بياني عشوائي;</li>
<li>حساب نقطة البداية، والتي تشبه نقطة التنقل في NSG. أولاً، ابحث عن النقطة المركزية العالمية، ثم ابحث عن النقطة الأقرب إلى النقطة المركزية العالمية كنقطة ملاحة. يتمثل الفرق بين Vamana وNSG في أن مدخلات NSG هي بالفعل أقرب رسم بياني للجار، لذلك يمكن للمستخدمين ببساطة إجراء بحث تقريبي لأقرب جار على نقطة مركزية مباشرة على الرسم البياني المجاور الأولي. ومع ذلك، يقوم Vamana بتهيئة رسم بياني عشوائي لأقرب رسم بياني عشوائي، وبالتالي لا يمكن للمستخدمين إجراء بحث تقريبي مباشرة على الرسم البياني العشوائي. فهم بحاجة إلى إجراء مقارنة شاملة للحصول على نقطة تنقل كنقطة بداية للتكرارات اللاحقة. الغرض من هذه النقطة هو تقليل متوسط نصف قطر البحث;</li>
<li>إجراء بحث تقريبي لأقرب جار على كل نقطة استنادًا إلى الرسم البياني العشوائي المجاور المهيأ ونقطة بداية البحث المحددة في الخطوة 2، وجعل جميع النقاط على مسار البحث مجموعات الجيران المرشحة، وتنفيذ استراتيجية تشذيب الحواف باستخدام ألفا = 1. على غرار ما حدث في NSG، سيؤدي اختيار مجموعة النقاط على مسار البحث بدءًا من نقطة التنقل كمجموعة جيران مرشحة إلى زيادة بعض الحواف الطويلة وتقليل نصف قطر البحث بشكل فعال.</li>
<li>اضبط ألفا &gt; 1 (توصي الورقة بـ 1.2) وكرر الخطوة 3. في حين أن الخطوة 3 تعتمد على رسم بياني عشوائي لأقرب جار عشوائي، فإن الرسم البياني يكون منخفض الجودة بعد التكرار الأول. لذلك، هناك حاجة إلى تكرار آخر لتحسين جودة الرسم البياني، وهو أمر مهم جدًا لمعدل الاستدعاء.</li>
</ol>
<p>تقارن هذه الورقة بين فهارس الرسوم البيانية الثلاثة، أي Vamana وNSG وHNSW. فيما يتعلق بأداء الفهرسة والاستعلام، فإن فامانا و NSG متقاربان نسبيًا، وكلاهما يتفوقان على HNSW بشكل طفيف. راجع قسم التجارب أدناه للاطلاع على البيانات.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/2_906f6a4def.png" alt="2.png" class="doc-image" id="2.png" />
   </span> <span class="img-wrapper"> <span>2.png</span> </span></p>
<p>لتصور عملية بناء فهرس Vamana، تقدم الورقة رسمًا بيانيًا تستخدم فيه 200 نقطة ثنائية الأبعاد لمحاكاة جولتين من التكرار. يستخدم الصف الأول ألفا = 1 لتشذيب الحواف. يمكن ملاحظة أن استراتيجية التشذيب جذرية نسبيًا، ويتم تشذيب عدد كبير من الحواف. بعد زيادة القيمة ألفا وتخفيف شروط التشذيب، من الواضح أنه تتم إضافة الكثير من الحواف مرة أخرى. في الرسم البياني النهائي، تتم إضافة بعض الحواف الطويلة. يمكن أن يقلل بشكل فعال من نصف قطر البحث.</p>
<h2 id="DiskANN" class="common-anchor-header">DiskANN<button data-href="#DiskANN" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>لن يستوعب حاسوب شخصي بسعة 64 جيجابايت فقط من الذاكرة مليار قطعة من البيانات الخام، ناهيك عن الفهرس المبني عليها. هناك تحديان أمامنا 1. كيف يمكن فهرسة مثل هذه المجموعة الكبيرة من البيانات بموارد ذاكرة محدودة؟ 2. كيف يمكن حساب المسافة عند البحث إذا تعذر تحميل البيانات الأصلية في الذاكرة؟</p>
<p>اقترحت الورقة الحلول التالية:</p>
<ol>
<li>بالنسبة للتحدي الأول: أولاً، تقسيم البيانات إلى مجموعات k باستخدام k-means، ثم تخصيص كل نقطة في أقرب i مجموعات. بشكل عام، تكفي 2 للعدد i. بناء فهرس فامانا قائم على الذاكرة لكل مجموعة، وأخيرًا دمج فهارس k فامانا في فهرس واحد.</li>
<li>بالنسبة للتحدي الثاني: بناء فهرس على المتجهات الأصلية والاستعلام عن المتجهات المضغوطة. يضمن بناء الفهارس على المتجه الأصلي جودة الرسم البياني، بينما يمكن تحميل المتجه المضغوط في الذاكرة للبحث الخشن. على الرغم من أن البحث باستخدام المتجهات المضغوطة قد يتسبب في فقدان الدقة، إلا أن الاتجاه العام سيكون صحيحًا طالما أن جودة الرسم البياني عالية بما يكفي. سيتم حساب نتيجة المسافة النهائية باستخدام المتجه الأصلي.</li>
</ol>
<p>يتشابه تخطيط فهرس DiskANN مع تلك الخاصة بفهارس الرسم البياني العام. يتم تخزين المجموعة المجاورة لكل نقطة وبيانات المتجه الأصلي معًا. وهذا يحقق استفادة أفضل من موقع البيانات.</p>
<p>كما ذكرنا سابقًا، إذا تم تخزين بيانات الفهرس على قرص SSD، فيجب تقليل عدد عمليات الوصول إلى القرص وطلبات القراءة والكتابة على القرص قدر الإمكان لضمان تأخير بحث منخفض. لذلك يقترح DiskANN استراتيجيتين للتحسين:</p>
<ol>
<li>النقطة الساخنة للتخزين المؤقت: تخزين جميع النقاط داخل C يقفز من نقطة البداية في الذاكرة. من الأفضل تعيين قيمة C في حدود 3 إلى 4.</li>
<li>البحث بالشعاع: ببساطة، هو التحميل المسبق لمعلومات الجار. عند البحث عن النقطة p، يجب تحميل النقطة المجاورة للنقطة p من القرص إذا لم تكن موجودة في الذاكرة. ونظرًا لأن عملية الوصول العشوائي على القرص الصلب يستغرق نفس الوقت الذي تستغرقه عملية الوصول إلى القرص الصلب أحادي القطاع تقريبًا، يمكن تحميل المعلومات المجاورة للنقاط W التي لم تتم معالجتها في كل مرة. لا يمكن تعيين W كبيرة جداً أو صغيرة جداً. سيؤدي W الكبير إلى إهدار موارد الحوسبة وعرض النطاق الترددي لـ SSD، بينما سيؤدي الصغير إلى زيادة تأخير البحث.</li>
</ol>
<h2 id="Experiment" class="common-anchor-header">التجربة<button data-href="#Experiment" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>تتكون التجربة من ثلاث مجموعات:</p>
<h4 id="Comparison-among-memory-based-indexes-Vamana-VS-NSG-VS-HNSW" class="common-anchor-header">مقارنة بين الفهارس القائمة على الذاكرة: Vamana VS. NSG VS. HNSW</h4><p>مجموعات البيانات: SIFT1M (128 بُعدًا)، وGIST1M (960 بُعدًا)، وDEEP1M (96 بُعدًا)، ومجموعة بيانات 1M مأخوذة عشوائيًا من DEEP1B.</p>
<p>معلمات الفهرس (تستخدم جميع مجموعات البيانات نفس مجموعة المعلمات):</p>
<p>HNSW：M = 128، efc = 512.</p>
<p>فامانا: R = 70، L = 75، ألفا = 1.2.</p>
<p>إن إس جي: ص = 60، ل = 70، ج = 500.</p>
<p>لم يتم توفير معلمات البحث في الورقة، والتي قد تكون متسقة مع معلمات الفهرسة. بالنسبة لاختيار المعلمة، تستند معلمات NSG المذكورة في المقالة إلى المعلمات المدرجة في مستودع GitHub الخاص بـ NSG لتحديد المجموعة ذات الأداء الأفضل. إن Vamana و NSG متقاربان نسبيًا، لذلك يتم تعيين المعلمات أيضًا بشكل متقارب. ومع ذلك، لم يتم إعطاء سبب اختيار معلمات HNSW. نعتقد أن المعلمة M لـ HNSW تم تعيينها بشكل كبير نسبيًا. قد يؤدي ذلك إلى مقارنة أقل إقناعًا بين الفهارس القائمة على الرسم البياني إذا لم يتم تعيين درجاتها الخارجية على نفس المستوى.</p>
<p>في ظل معلمات الفهرسة المذكورة أعلاه، يبلغ زمن فهرسة Vamana وHNSW وNSG 129 ثانية و219 ثانية و480 ثانية على التوالي. يتضمن وقت فهرسة NSG وقت إنشاء الرسم البياني المجاور الأولي باستخدام EFANN [3].</p>
<p>منحنى الاسترجاع-QPS:</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/3_dcdb9452ca.png" alt="3.png" class="doc-image" id="3.png" />
   </span> <span class="img-wrapper"> <span>3.png</span> </span></p>
<p>يمكن أن نرى من الشكل 3 أن Vamana يتمتع بأداء ممتاز على مجموعات البيانات الثلاث، وهو مشابه لـ NSG وأفضل قليلًا من HNSW.</p>
<p>مقارنة نصف قطر البحث:</p>
<p>من الشكل 2 ج، يمكننا أن نرى أن Vamana لديه أقصر متوسط مسار بحث تحت نفس معدل الاستدعاء مقارنةً بمتوسطي مسار البحث NSG و HNSW.</p>
<h4 id="Comparison-between-a-one-time-built-index-and-a-large-merged-index" class="common-anchor-header">مقارنة بين الفهرس المدمج لمرة واحدة والفهرس المدمج الكبير</h4><p>مجموعة البيانات: SIFT1B</p>
<p>معلمات الفهرس المدمج لمرة واحدة L = 50، R = 128، ألفا = 1.2. بعد تشغيله لمدة يومين على جهاز DDR3 سعة 1800G، تبلغ ذروة الذاكرة حوالي 1100G، ومتوسط الدرجة الخارجية 113.9.</p>
<p>إجراء الفهرسة على أساس الدمج:</p>
<ol>
<li>تدريب 40 مجموعة على مجموعة البيانات باستخدام kmeans;</li>
<li>يتم توزيع كل نقطة في أقرب مجموعتين;</li>
<li>بناء مؤشر فامانا مع L = 50، R = 64، و alpha = 1.2 لكل مجموعة;</li>
<li>دمج فهارس كل مجموعة.</li>
</ol>
<p>أنشأ هذا الفهرس فهرسًا بسعة 384 جيجابايت بمتوسط درجة خارج الدرجة 92.1. تم تشغيل هذا الفهرس لمدة 5 أيام على جهاز DDR4 بسعة 64 جيجابايت.</p>
<p>فيما يلي نتائج المقارنة (الشكل 2 أ): 
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/4_ea421b98c3.png" alt="4.png" class="doc-image" id="4.png" />
   </span> <span class="img-wrapper"> <span>4.png</span> </span></p>
<p>في الختام:</p>
<ol>
<li>الفهرس المبني لمرة واحدة أفضل بكثير من الفهرس القائم على الدمج;</li>
<li>الفهرس القائم على الدمج ممتاز أيضًا;</li>
<li>مخطط الفهرسة القائم على الدمج قابل للتطبيق أيضًا على مجموعة بيانات DEEP1B (الشكل 2 ب).</li>
</ol>
<h4 id="Disk-based-index-DiskANN-VS-FAISS-VS-IVF-OADC+G+P" class="common-anchor-header">الفهرس القائم على القرص: DiskANN مقابل. FAISS مقابل. IVF-OADC+G+P</h4><p>IVFOADC+G+P هي خوارزمية مقترحة في المرجع [5].</p>
<p>تقارن هذه الورقة البحثية فقط بين DiskANN و IVFOADC+G+P، حيث أثبت المرجع [5] أن IVFOADC+G+P أفضل من FAISS. بالإضافة إلى ذلك، يتطلب FAISS موارد وحدة معالجة الرسومات، والتي لا تدعمها جميع المنصات.</p>
<p>يبدو أن IVF-OADC+G+P هو مزيج من HNSW و IVF-PQ. فهو يحدد المجموعات باستخدام HNSW، ويقوم بالبحث عن طريق إضافة بعض استراتيجيات التقليم إلى المجموعة المستهدفة.</p>
<p>النتيجة في الشكل 2أ. يمثل الرقمان 16 و32 في الشكل حجم دفتر الرموز. مجموعة البيانات هي SIFT1B، مقيسة كمياً بواسطة OPQ.</p>
<h4 id="Code-implementation-details" class="common-anchor-header">تفاصيل تنفيذ الكود</h4><p>شفرة مصدر DiskANN مفتوحة المصدر على https://github.com/microsoft/DiskANN</p>
<p>في يناير 2021، تم فتح الكود المصدري لحل القرص في المصدر.</p>
<p>يقدم ما يلي بشكل أساسي عملية الفهرسة وعملية البحث.</p>
<p><strong>بناء الفهرس</strong></p>
<p>هناك 8 معلمات لبناء الفهرس:</p>
<p>نوع_البيانات: تشمل الخيارات عوامة/int8/uint8.</p>
<p>data_file.bin: ملف ثنائي البيانات الأصلي. يمثل أول عددين صحيحين في الملف على التوالي العدد الإجمالي n لمتجه مجموعة البيانات والبعد المتجه dim. يمثل آخر n <em>dim dim</em> sizeof(data_type) بايت بيانات المتجه المستمر.</p>
<p>فهرس_بادئة_المسار: بادئة مسار ملف الإخراج. بعد إنشاء الفهرس، سيتم إنشاء عدة ملفات متعلقة بالفهرس. هذه المعلمة هي البادئة المشتركة للدليل حيث يتم تخزينها.</p>
<p>R: الحد الأقصى للدرجة الخارجية للفهرس العام.</p>
<p>L: المعلمة L لفهرس فامانا، الحد الأعلى لحجم المجموعة المرشحة.</p>
<p>B: عتبة الذاكرة عند الاستعلام. يتحكم في حجم دفتر رموز PQ، بالجيجابايت.</p>
<p>M: عتبة الذاكرة عند إنشاء فهرس. يحدد حجم الجزء، بالجيجابايت.</p>
<p>T: عدد الخيوط.</p>
<p>عملية الفهرسة (دالة الإدخال: aux_utils.cpp::build_disk_index):</p>
<ol>
<li>توليد أسماء ملفات الإخراج المختلفة وفقًا لـ index_prefix_path.</li>
<li>التحقق من المعلمة.</li>
<li>قراءة البيانات الوصفية لملف data_file.bin للحصول على n و dim. تحديد رقم الفضاء الفرعي لدفتر الرموز m من PQ وفقًا لـ B و n.</li>
<li>توليد_pq_pivots: أخذ عينة من النقطة المركزية لمجموعة تدريب PQ باستخدام معدل أخذ العينات p = 1500000/n بشكل موحد لتدريب PQ على مستوى العالم.</li>
<li>توليد_pq_data_from_pivots: إنشاء دفتر رموز PQ عالمي، وحفظ النقطة المركزية ودفتر الرموز بشكل منفصل.</li>
<li>إنشاء_فهرس_فامانا_مدمج: تقطيع مجموعة البيانات الأصلية، وإنشاء فهارس فامانا في أجزاء، وأخيرًا دمج الفهارس في جزء واحد.</li>
</ol>
<ul>
<li>التقسيم_مع_ميزانية_رام: تحديد عدد الأجزاء k وفقًا للمعامل M. أخذ عينة من مجموعة البيانات باستخدام kmeans، وتوزيع كل نقطة إلى أقرب مجموعتين. تجزئة مجموعة البيانات، ويُنتج كل جزء ملفين: ملف بيانات وملف معرّف. يتوافق ملف المعرف وملف البيانات مع بعضهما البعض، ويتوافق كل معرف في ملف المعرف مع متجه في ملف البيانات. يتم الحصول على المعرف عن طريق ترقيم كل متجه من البيانات الأصلية من 0 إلى n-1. المعرف مهم نسبيًا ويرتبط بالدمج.<ul>
<li>قم بأخذ عينة موحدة من مجموعة التدريب عالميًا بمعدل أخذ عينات 1500000 / n;</li>
<li>قم بتهيئة num_parts = 3. كرر من 3:<ul>
<li>قم بإجراء num_parts-means-means++ على مجموعة التدريب في الخطوة i;</li>
<li>استخدم معدل أخذ العينات 0.01 لأخذ عينة من مجموعة الاختبار بشكل موحد على مستوى العالم، وقسم مجموعة الاختبار إلى أقرب مجموعتين;</li>
<li>احسب عدد النقاط في كل مجموعة واقسمها على معدل أخذ العينات لتقدير عدد النقاط في كل مجموعة;</li>
<li>تقدير الذاكرة التي تتطلبها أكبر مجموعة في الخطوة 3 وفقًا لحجم فهرس فامانا، إذا لم تتجاوز المعامل M، فانتقل إلى الخطوة iii، وإلا فعد إلى الخطوة 2;</li>
</ul></li>
<li>قسّم مجموعة البيانات الأصلية إلى ملفات مجموعة num_parts، تتضمن كل مجموعة من الملفات ملفات بيانات مجزأة وملفات معرفات تتوافق مع البيانات المجزأة.</li>
</ul></li>
<li>إنشاء فهارس فامانا بشكل منفصل لجميع الشرائح في الخطوة أ وحفظها على القرص;</li>
<li>دمج_الشرائح: دمج num_parts شريحة num_parts Vamana في فهرس عام:<ul>
<li>قراءة ملف معرف شظايا num_parts في idmap. خريطة المعرف هذه تعادل إنشاء تعيين أمامي للجزء-&gt; معرف;</li>
<li>إنشاء تعيين عكسي لـ id-&gt; الأجزاء وفقًا لـ idmap، ومعرفة أي جزأين يوجد كل متجه في كل جزء;</li>
<li>استخدم قارئًا ذا ذاكرة تخزين مؤقت سعة 1 جيجابايت لفتح فهارس شريحة num_parts Vamana، واستخدم كاتبًا ذا ذاكرة تخزين مؤقت سعة 1 جيجابايت لفتح ملف الإخراج، جاهزًا للدمج;</li>
<li>ضع نقاط التنقل num_parts من فهرس فامانا في ملف النقطة المركزية، والتي سيتم استخدامها عند البحث;</li>
<li>ابدأ الدمج وفقًا للمعرف من الصغير إلى الكبير، واقرأ مجموعة النقاط المجاورة لكل متجه أصلي في كل جزء بدوره وفقًا للتخطيط العكسي، وقم بإلغاء التكرار، وخلط الأوراق، وخلطها، واقتطاعها، والكتابة إلى ملف الإخراج. نظرًا لأن التجزئة كانت في الأصل مرتبة عالميًا، والآن يتم الدمج بالترتيب أيضًا، لذا فإن المعرف في الفهرس النهائي الذي تم مسحه ومعرف البيانات الأصلية يكونان متطابقين واحد لواحد.</li>
<li>احذف الملفات المؤقتة، بما في ذلك ملفات الأجزاء، وفهارس الأجزاء، وملفات معرفات الأجزاء.</li>
</ul></li>
</ul>
<ol start="7">
<li><p>إنشاء_تخطيط_القرص: يحتوي الفهرس العام الذي تم إنشاؤه في الخطوة 6 فقط على جدول ترابط مضغوط. هذه الخطوة هي لمحاذاة الفهرس. يتم تخزين الجدول المجاور والبيانات الأصلية معًا. عند البحث، قم بتحميل جدول التجاور وقراءة المتجه الأصلي معًا لحساب المسافة بدقة. هناك أيضًا مفهوم SECTOR، والحجم الافتراضي هو 4096. يحتوي كل قطاع SECTOR على 4096 / عقدة_حجم فقط من معلومات المتجه. node_size = حجم المتجه الفردي + حجم جدول ترابط العقدة الواحدة.</p></li>
<li><p>أخيرًا، قم بأخذ عينة موحدة عالمية بحجم 150000 / n، واحفظها واستخدمها للإحماء عند البحث.</p></li>
</ol>
<p><strong>البحث</strong></p>
<p>هناك 10 معلمات بحث:</p>
<ul>
<li>نوع_الفهرس: تتضمن الخيارات Float/int8/uint8، على غرار المعلمة الأولى data_type عند إنشاء فهرس.</li>
<li>مسار_بادئة_الفهرس: ارجع إلى معلمة الفهرس index_prefix_path.</li>
<li>num_nodes_to_cache: عدد النقاط الساخنة لذاكرة التخزين المؤقت.</li>
<li>num_threads: عدد خيوط البحث.</li>
<li>عرض الشعاع: الحد الأعلى لعدد نقاط التحميل المسبق. يحدد النظام إذا تم تعيينه 0.</li>
<li>query_file.bin: ملف مجموعة الاستعلام.</li>
<li>truthset.bin: ملف مجموعة النتيجة، "فارغ" يعني أن مجموعة النتائج غير متوفرة، يقوم البرنامج بحسابها بنفسه;</li>
<li>K: topk;</li>
<li>result_output_prefix: مسار لحفظ نتائج البحث;</li>
<li>L*: قائمة معلمات البحث. يمكن إضافة قيم متعددة. لكل L، سيتم إعطاء معلومات إحصائية أثناء البحث باستخدام L مختلفة.</li>
</ul>
<p>عملية البحث:</p>
<ol>
<li>تحميل البيانات ذات الصلة: تحميل مجموعة الاستعلام، وبيانات النقطة المركزية PQ، وبيانات دفتر الرموز، ونقطة بداية البحث وبيانات أخرى، وقراءة الفهرس الوصفية.</li>
<li>استخدام مجموعة البيانات التي تم أخذ عينات منها أثناء الفهرسة للقيام بالبحث_في_ذاكرة_مخبأة مؤقتة، وحساب أوقات الوصول لكل نقطة، وتحميل عدد_نقاط_نقاط_إلى_ذاكرة_مخبأة ذات أعلى تردد وصول إلى ذاكرة التخزين المؤقت.</li>
<li>هناك عملية WARMUP افتراضيًا. كما في الخطوة 2، تُستخدم مجموعة البيانات النموذجية هذه أيضًا لإجراء بحث_بحث_مخبأ_في_ذاكرة_مخبأة.</li>
<li>وفقًا لعدد المعلمات L المعطاة، سيتم إجراء كل L مع cached_beam_beam_search مرة أخرى مع مجموعة الاستعلام، وسيتم إخراج إحصائيات مثل معدل الاستدعاء وQPS. لا يتم احتساب عملية الإحماء وإحصائيات بيانات النقاط الساخنة في وقت الاستعلام.</li>
</ol>
<p>حول cached_beam_search:</p>
<ol>
<li>ابحث عن أقرب مرشح لنقطة الاستعلام من نقطة البداية المرشحة. تُستخدم هنا مسافة PQ، وتُضاف نقطة البداية إلى قائمة انتظار البحث.</li>
<li>ابدأ البحث:</li>
</ol>
<ul>
<li>من قائمة انتظار البحث، لا يوجد أكثر من نقطة شعاع_عرض + 2 نقاط غير مزورة. إذا كانت هذه النقاط موجودة في ذاكرة التخزين المؤقت، أضفها إلى قائمة انتظار إصابة ذاكرة التخزين المؤقت. إذا لم يتم ضربها، فأضفها إلى قائمة انتظار الفقد. احرص على ألا يتجاوز حجم قائمة انتظار النقاط التي لم يتم الوصول إليها حجم قائمة انتظار النقاط التي لم تتم زيارتها.</li>
<li>أرسل طلبات الوصول إلى القرص غير المتزامن إلى النقاط الموجودة في قائمة انتظار الفائتة.</li>
<li>بالنسبة للنقاط التي ضربتها ذاكرة التخزين المؤقت، استخدم البيانات الأصلية وبيانات الاستعلام لحساب المسافة الدقيقة وأضفها إلى قائمة انتظار النتائج، ثم استخدم PQ لحساب المسافة إلى النقاط المجاورة التي لم تتم زيارتها قبل إضافتها إلى قائمة انتظار البحث. يكون طول قائمة انتظار البحث محدودًا بالمعلمات.</li>
<li>معالجة النقاط المفقودة المخبأة في الخطوة أ، على غرار الخطوة ج.</li>
<li>عندما تكون قائمة انتظار البحث فارغة، ينتهي البحث، ويتم إرجاع قائمة انتظار النتائج topk.</li>
</ul>
<h4 id="Summarize" class="common-anchor-header">تلخيص</h4><p>على الرغم من أن هذا العمل طويل نسبيًا، إلا أنه ممتاز بشكل عام. أفكار الورقة البحثية والرمز واضحة: تقسيم عدد من الدلاء المتداخلة من خلال k-means، ثم تقسيم الدلاء لبناء فهرس خريطة، وأخيرًا دمج الفهارس، وهي فكرة جديدة نسبيًا. أما بالنسبة إلى فهرس الرسم البياني القائم على الذاكرة Vamana، فهو في الأساس نسخة مهيأة عشوائيًا من NSG يمكنها التحكم في دقة التشذيب. عند الاستعلام، فإنه يستفيد بشكل كامل من ذاكرة التخزين المؤقت + خط الأنابيب، ويغطي جزءًا من وقت الاستعلام، ويحسن من QPS. ومع ذلك، وفقًا للورقة، حتى لو لم تكن حالة الآلة غير عادية، فإن وقت التدريب يستغرق ما يصل إلى 5 أيام، وقابلية الاستخدام منخفضة نسبيًا. من الضروري بالتأكيد إجراء تحسينات على التدريب في المستقبل. ومن منظور الكود، فإن الجودة عالية نسبيًا ويمكن استخدامها مباشرة في بيئة الإنتاج.</p>
<h4 id="References" class="common-anchor-header">المراجع</h4><ol>
<li><a href="https://www.microsoft.com/en-us/research/publication/diskann-fast-accurate-billion-point-nearest-neighbor-search-on-a-single-node/">سوهاس جايارام سوبرامانيا، وفنو ديفريت وهارشا فاردهان سيمهادري، ورافيشانكار كريشناوامي، وروهان كاديكودي. DiskANN: بحث سريع ودقيق بمليار نقطة لأقرب جار على عقدة واحدة. NeurIPS 2019.</a></li>
<li>[كونغ فو، وتشاو شيانغ، وتشانغشو وانغ، ودنغ تساي. بحث سريع تقريبي تقريبي لأقرب جار مع التنقل في الرسوم البيانية المنتشرة. PVLDB, 12(5):461 - 474، 2019. doi: 10.14778/3303753.3303754.]. (http://www.vldb.org/pvldb/vol12/p461-fu.pdf)</li>
<li>كونغ فو ودنغ كاي. <a href="https://github.com/ZJULearning/efanna">GitHub - ZJULearning/إيفانا: مكتبة سريعة للبحث في الشبكة العصبية الاصطناعية وبناء الرسم البياني KNN.</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/50143204">محرك بحث لـ AI高 ： ™ ™ İPP</a></li>
</ol>
<p>5.<a href="https://arxiv.org/abs/1802.02422"> ديمتري بارانشوك وأرتيم بابينكو ويوري مالاكوف. إعادة النظر في المؤشرات المقلوبة لأقرب الجيران التقريبي بمليار.</a></p>
