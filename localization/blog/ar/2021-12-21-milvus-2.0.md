---
id: 2021-12-21-milvus-2.0.md
title: تطور قاعدة بيانات ميلفوس السحابية القابلة للتطوير في السحابة
author: Jun Gu
date: 2021-12-21T00:00:00.000Z
desc: عملية التفكير في كيفية تصميمنا لبنية مجموعة قواعد بيانات Milvus الجديدة.
cover: assets.zilliz.com/Evolution_dd677ce3be.png
tag: Engineering
---
<blockquote>
<p>سنشارك في هذه المقالة عملية التفكير في كيفية تصميمنا لبنية مجموعة قواعد بيانات Milvus الجديدة.</p>
</blockquote>
<h2 id="Objectives-of-Milvus-vector-database" class="common-anchor-header">أهداف قاعدة بيانات ميلفوس المتجهة<button data-href="#Objectives-of-Milvus-vector-database" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>عندما خطرت فكرة <a href="https://github.com/milvus-io/milvus">قاعدة بيانات Milvus vector</a> لأول مرة في أذهاننا، أردنا بناء بنية تحتية للبيانات يمكن أن تساعد الناس على تسريع تبني الذكاء الاصطناعي في مؤسساتهم.</p>
<p>وقد وضعنا هدفين أساسيين لمشروع Milvus لتحقيق هذه المهمة.</p>
<h3 id="Ease-of-use" class="common-anchor-header">سهولة الاستخدام</h3><p>الذكاء الاصطناعي/التعلم الآلي هو مجال ناشئ حيث تستمر التقنيات الجديدة في الظهور. معظم المطورين ليسوا على دراية كاملة بتقنيات وأدوات الذكاء الاصطناعي سريعة النمو. لقد استهلك المطورون بالفعل معظم طاقاتهم في إيجاد النماذج وتدريبها وضبطها. من الصعب عليهم بذل جهود إضافية في التعامل مع الكميات الكبيرة من متجهات التضمين التي تولدها النماذج. ناهيك عن أن التعامل مع حجم كبير من البيانات هو دائمًا مهمة صعبة للغاية.</p>
<p>وبالتالي فإننا نعطي "سهولة الاستخدام" أولوية عالية جدًا لأنها يمكن أن تقلل بشكل كبير من تكلفة التطوير.</p>
<h3 id="Low-running-costs" class="common-anchor-header">انخفاض تكاليف التشغيل</h3><p>تتمثل إحدى العقبات الأساسية للذكاء الاصطناعي في الإنتاج في تبرير عائد الاستثمار. سيكون لدينا المزيد من الفرص لوضع تطبيقات الذكاء الاصطناعي في الإنتاج بتكاليف تشغيل أقل. وسيؤدي ذلك إلى رفع هامش الفوائد المحتملة.</p>
<h3 id="Design-principles-of-Milvus-20" class="common-anchor-header">مبادئ تصميم ميلفوس 2.0</h3><p>لقد بدأنا في تحقيق هذه الأهداف في Milvus 1.0. لكن ذلك لم يكن كافياً، خاصة في قابلية التوسع والتوافر. ثم بدأنا في تطوير Milvus 2.0 لتحسين هذه النقاط. تتضمن المبادئ التي وضعناها لهذا الإصدار الجديد ما يلي:</p>
<ul>
<li>استهداف قابلية التوسع والتوافر العاليين</li>
<li>البناء على البنية التحتية والممارسات السحابية الناضجة</li>
<li>الحد الأدنى من التنازل عن الأداء في السحابة</li>
</ul>
<p>وبعبارة أخرى، نريد أن نجعل مجموعة قواعد بيانات Milvus سحابية أصلية في السحابة.</p>
<h2 id="The-evolution-of-database-clusters" class="common-anchor-header">تطور مجموعات قواعد البيانات<button data-href="#The-evolution-of-database-clusters" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>قاعدة البيانات المتجهة هي نوع جديد من قواعد البيانات، لأنها تتعامل مع أنواع جديدة من البيانات (المتجهات). لكنها لا تزال تشترك في نفس التحديات التي تواجه قواعد البيانات الأخرى، مع بعض المتطلبات الخاصة بها. في بقية هذه المقالة، سأركز على ما تعلمناه من تطبيقات مجموعات قواعد البيانات الحالية وعملية التفكير في كيفية تصميمنا لبنية مجموعة ميلفوس الجديدة.</p>
<p>إذا كنت مهتمًا بتفاصيل تنفيذ مكونات مجموعة Milvus، يُرجى متابعة وثائق Milvus. سننشر باستمرار مقالات تقنية في ريبو Milvus GitHub وموقع Milvus الإلكتروني ومدونة Milvus.</p>
<h3 id="The-ideal-database-cluster" class="common-anchor-header">مجموعة قواعد البيانات المثالية</h3><blockquote>
<p>"صوّب صغيرًا، أخطأ صغيرًا."</p>
</blockquote>
<p>دعونا أولاً ندرج أولاً القدرات الهامة التي يجب أن تتمتع بها مجموعة قواعد البيانات <strong>المثالية</strong>.</p>
<ol>
<li>التزامن وعدم وجود نقطة فشل واحدة: يمكن للمستخدمين المتصلين بأعضاء مجموعة مختلفة الوصول للقراءة/الكتابة في نفس الوقت إلى نفس الجزء من البيانات.</li>
<li>الاتساق: يجب أن يرى أعضاء المجموعة المختلفون البيانات نفسها.</li>
<li>قابلية التوسع: يمكننا إضافة أو إزالة أعضاء المجموعة أثناء التنقل.</li>
</ol>
<p>بصراحة، من الصعب الحصول على كل هذه الإمكانيات معًا. في التطبيقات الحديثة لمجموعات قواعد البيانات، يضطر الناس إلى التنازل عن بعض هذه القدرات. لا يتوقع الناس مجموعة قواعد بيانات مثالية طالما أنها تتناسب مع سيناريوهات المستخدم. ومع ذلك، كانت مجموعة قواعد البيانات المشتركة كل شيء قريبة جدًا من مجموعة قواعد البيانات المثالية. إذا أردنا أن نتعلم شيئًا ما، يجب أن نبدأ من هنا.</p>
<h3 id="The-key-considerations-of-a-database-cluster" class="common-anchor-header">الاعتبارات الرئيسية لمجموعة قواعد البيانات</h3><p>تتمتع مجموعة مشاركة كل شيء المشتركة بتاريخ ممتد أكثر مقارنةً بالتطبيقات الحديثة الأخرى. تعتبر مجموعة مشاركة البيانات Db2 و Oracle RAC نموذجًا لمجموعات مشاركة كل شيء. يعتقد الكثير من الناس أن مشاركة كل شيء تعني مشاركة الأقراص. الأمر أكثر من ذلك بكثير.</p>
<p>تحتوي مجموعة مشاركة كل شيء على نوع واحد فقط من أعضاء قاعدة البيانات في المجموعة. يمكن للمستخدمين الاتصال بأي عضو من هؤلاء الأعضاء المتماثلين للوصول إلى أي بيانات. ما هو "كل شيء" الذي يجب مشاركته لإنجاح هذا الأمر؟</p>
<h4 id="The-sequence-of-events-in-the-group" class="common-anchor-header">تسلسل الأحداث في المجموعة</h4><p>أولاً، تسلسل أحداث المجموعة أمر بالغ الأهمية لحل التعارضات المحتملة الناجمة عن الوصول المتزامن من أعضاء المجموعات المختلفة. نستخدم عادةً رقم تسلسل سجل سجل قاعدة البيانات لتمثيل تسلسل الأحداث. في الوقت نفسه، يتم إنشاء رقم تسلسل سجل السجل بشكل عام من الطابع الزمني.</p>
<p>وبالتالي فإن شرط تسلسل أحداث المجموعة يساوي الحاجة إلى مؤقت عالمي. إذا كان بإمكاننا الحصول على ساعة ذرية للمجموعة، فسيكون ذلك رائعًا. ومع ذلك، فإن ميلفوس هو مشروع برمجيات مفتوح المصدر، مما يعني أننا يجب أن نعتمد على الموارد المتاحة بشكل عام. حتى الآن، لا تزال الساعة الذرية خيارًا ممتازًا للشركات الكبيرة.</p>
<p>لقد قمنا بتنفيذ مكون مزامنة الوقت في مجموعة قاعدة بيانات Milvus 2.0 Milvus 2.0. يمكنك العثور على الرابط في الملحق.</p>
<h4 id="Global-locking" class="common-anchor-header">القفل العالمي</h4><p>تحتوي قاعدة البيانات على آلية قفل لحل تعارضات الوصول المتزامن، سواء كانت أقفال متفائلة أو متشائمة. وبالمثل، نحتاج إلى تأمين عام لحل تعارضات الوصول المتزامن بين أعضاء المجموعة المختلفة.</p>
<p>يعني القفل العام أنه يجب على أعضاء المجموعة المختلفة التحدث مع بعضهم البعض للتفاوض بشأن طلبات القفل. ستؤثر عدة عوامل حيوية على كفاءة عملية تفاوض القفل العالمي هذه:</p>
<ul>
<li>سرعة الاتصالات بين الأنظمة</li>
<li>عدد أعضاء المجموعة الذين يحتاجون إلى المشاركة في عملية التفاوض</li>
<li>تكرار تعارضات المجموعة</li>
</ul>
<p>لا يزيد حجم المجموعة النموذجي عن 100 عضو. على سبيل المثال، Db2 DSG هو 32؛ وOracle RAC هو 100. سيتم وضع أعضاء المجموعة هؤلاء في غرفة خادم واحدة متصلة بالألياف الضوئية لتقليل زمن انتقال البيانات. هذا هو السبب في أنها تسمى أحيانًا مجموعة مركزية. نظرًا لمحدودية حجم المجموعة، سيختار الأشخاص الخوادم المتطورة (الحواسيب المركزية أو الحواسيب الصغيرة، التي تتمتع بسعة أكبر بكثير من حيث وحدة المعالجة المركزية والذاكرة وقنوات الإدخال/الإخراج، إلخ) لتكوين مجموعات المجموعات المشتركة لكل شيء.</p>
<p>لقد تغير هذا الافتراض الخاص بالأجهزة بشكل كبير في البيئة السحابية الحديثة. في الوقت الحاضر، تتألف مراكز البيانات السحابية من غرف خوادم عالية الكثافة مليئة (بالآلاف) من خوادم X86 السلعية المزودة باتصالات TCP/IP. إذا كنا نعتمد على خوادم X86 هذه لبناء مجموعة قواعد البيانات، فيجب أن يزيد حجم المجموعة إلى مئات (حتى آلاف) الأجهزة. وفي بعض سيناريوهات العمل، سنحتاج إلى انتشار هذه المئات من أجهزة X86 في مناطق مختلفة. وبالتالي فإن تنفيذ القفل العام قد لا يستحق العناء بعد الآن، لأن أداء القفل العام لن يكون جيدًا بما فيه الكفاية.</p>
<p>في Milvus 2.0، لن ننفذ مرفق القفل العالمي. فمن ناحية، لا يوجد تحديث للبيانات المتجهة. (يجب أن يفضل الناس الحذف-الإدراج بدلاً من التحديث.) لذا لا داعي للقلق بشأن تعارضات تعدد الكتّاب على نفس الجزء من البيانات في مجموعة Milvus مع ترتيب التجزئة. في هذه الأثناء، يمكننا استخدام MVCC (التحكم في التزامن متعدد الإصدارات، وهي طريقة التحكم في التزامن لتجنب القفل) لحل التعارضات بين القارئ والكاتب.</p>
<p>من ناحية أخرى، تستهلك معالجة البيانات المتجهة بصمة ذاكرة أعلى بكثير من معالجة البيانات المنظمة. يبحث الناس عن قابلية توسع أعلى بكثير في قواعد البيانات المتجهة.</p>
<h4 id="Shared-in-memory-data-cache" class="common-anchor-header">ذاكرة التخزين المؤقت للبيانات المشتركة في الذاكرة</h4><p>يمكننا تقسيم محرك قاعدة البيانات بإيجاز إلى قسمين: محرك التخزين ومحرك الحوسبة. محرك التخزين مسؤول عن مهمتين هامتين:</p>
<ul>
<li>كتابة البيانات إلى التخزين الدائم لأغراض المتانة.</li>
<li>تحميل البيانات من وحدة التخزين الدائمة إلى ذاكرة التخزين المؤقت للبيانات في الذاكرة (المعروف أيضًا باسم تجمع المخزن المؤقت)؛ هذا هو المكان الوحيد الذي يصل فيه محرك الحوسبة إلى البيانات.</li>
</ul>
<p>في سيناريو مجموعة قواعد البيانات، ماذا لو قام العضو A بتحديث البيانات المخزنة مؤقتًا في العضو B؟ كيف يمكن للعضو B معرفة انتهاء صلاحية بياناته في الذاكرة؟ تحتوي المجموعة الكلاسيكية المشتركة لكل شيء على آلية إبطال تقاطع المخزن المؤقت لحل هذه المشكلة. ستعمل آلية الإبطال التبادلي للمخزن المؤقت بشكل مشابه للتأمين العام إذا حافظنا على اتساق قوي بين أعضاء المجموعة. وكما ذكرنا من قبل، فإن ذلك ليس عملياً في البيئة السحابية الحديثة. <strong>لذلك قررنا تخفيض مستوى الاتساق في مجموعة ميلفوس القابلة للتطوير السحابي إلى مستوى اتساق نهائي.</strong> بهذه الطريقة، يمكن أن تكون آلية الإبطال المتقاطع للمخزن المؤقت في Milvus 2.0 عملية غير متزامنة.</p>
<h4 id="Shared-storage" class="common-anchor-header">التخزين المشترك</h4><p>ربما يكون التخزين المشترك أول ما قد يفكر فيه الناس عند مناقشة مجموعة قواعد البيانات.</p>
<p>كما تغيرت خيارات التخزين بشكل كبير في السنوات الأخيرة من تطور التخزين السحابي. كانت الشبكة المتصلة بالتخزين (SAN) (ولا تزال) هي أساس التخزين لمجموعة التخزين المشتركة لكل شيء. ولكن في بيئة السحابة، لا توجد شبكة SAN. يجب أن تستخدم قاعدة البيانات القرص المحلي المتصل بالأجهزة الافتراضية السحابية. يقدم استخدام القرص المحلي تحدي اتساق البيانات عبر أعضاء المجموعة. وعلينا أيضًا أن نقلق بشأن التوافر العالي لأعضاء المجموعة.</p>
<p>ثم قدم Snowflake نموذجًا رائعًا لقواعد البيانات السحابية باستخدام التخزين السحابي المشترك (تخزين S3). وهو يلهم ميلفوس 2.0 أيضًا. كما ذكرنا من قبل، نعتزم الاعتماد على البنية التحتية السحابية الناضجة. ولكن قبل أن نتمكن من استخدام التخزين السحابي المشترك، علينا التفكير في أمرين.</p>
<p>أولاً، تخزين S3 رخيص وموثوق به، ولكنه غير مصمم للوصول الفوري R/W مثل سيناريوهات قواعد البيانات. نحن بحاجة إلى إنشاء مكونات البيانات (التي نسميها عقد البيانات في Milvus 2.0) لربط الذاكرة/ القرص المحلي وتخزين S3. هناك بعض الأمثلة (مثل Alluxio و JuiceFS وغيرها) التي يمكننا تعلمها. السبب في أننا لا نستطيع دمج هذه المشاريع مباشرة هو أننا نركز على دقة بيانات مختلفة. تم تصميم Alluxio و JuiceFS لمجموعات البيانات أو ملفات POSIX، بينما نركز نحن على مستوى سجل البيانات (المتجه).</p>
<p>عندما تستقر البيانات المتجهة على تخزين S3، فإن الإجابة بالنسبة للبيانات الوصفية سهلة: تخزينها في ETCD. ماذا عن بيانات السجل إذن؟ في التطبيقات الكلاسيكية، يعتمد مخزن السجل أيضًا على شبكة SAN. تتم مشاركة ملفات السجل الخاصة بأحد أعضاء مجموعة قواعد البيانات داخل مجموعة قواعد البيانات لأغراض استرداد الأعطال. لذلك لم تكن هذه مشكلة حتى وصلنا إلى بيئة السحابة.</p>
<p>في ورقة Spanner البحثية، أوضحت Google كيفية تنفيذهم لقاعدة البيانات (المجموعة) الموزعة عالميًا باستخدام خوارزمية إجماع Paxos. أنت بحاجة إلى برمجة مجموعة قاعدة البيانات كمجموعة نسخ متماثل لآلة الحالة. عادةً ما يكون سجل الإعادة هو "الحالة" التي سيتم نسخها عبر المجموعة.</p>
<p>يعد النسخ المتماثل لسجل الإعادة بواسطة خوارزميات الإجماع أداة قوية، ولها مزايا كبيرة في بعض سيناريوهات العمل. ولكن بالنسبة لقاعدة بيانات Milvus vector، لا نجد حوافز كافية لإنشاء مجموعة نسخ متماثل لآلة الحالة ككل. لقد قررنا استخدام طابور/منصة المراسلة السحابية (Apache Pulsar، Apache Kafka، إلخ) كمخزن سحابي مشترك بديل لمخزن السجل. من خلال تفويض مخزن السجل إلى منصة المراسلة، نحصل على الفوائد التالية.</p>
<ul>
<li>المجموعة أكثر اعتمادًا على الأحداث، مما يعني أن العديد من العمليات يمكن أن تكون غير متزامنة. يحسن قابلية التوسع.</li>
<li>المكونات مقترنة بشكل أكثر مرونة، مما يجعل من الأسهل بكثير إجراء ترقيات متجددة عبر الإنترنت. يحسن التوافر وقابلية التشغيل.</li>
</ul>
<p>سنعيد النظر في هذا الموضوع في قسم لاحق.</p>
<p>لقد انتهينا حتى الآن من الاعتبارات الحاسمة لمجموعة قواعد البيانات. قبل أن ننتقل إلى المناقشة حول بنية ميلفوس 2.0، دعوني أولاً أشرح كيف ندير النواقل في ميلفوس.</p>
<h3 id="Data-management-and-performance-predictability" class="common-anchor-header">إدارة البيانات وإمكانية التنبؤ بالأداء</h3><p>يخزن ميلفوس المتجهات في مجموعات. "المجموعة" هي مفهوم منطقي، يعادل "الجدول" في قواعد بيانات SQL. يمكن أن تحتوي "المجموعة" على ملفات فعلية متعددة لحفظ المتجهات. الملف الفعلي هو &quot;مقطع&quot;. "المقطع" هو مفهوم مادي مثل ملف مساحة الجدول في قواعد بيانات SQL. عندما يكون حجم البيانات صغيرًا، يمكننا حفظ كل شيء في مقطع واحد/ملف مادي واحد. ولكن في الوقت الحاضر، نواجه باستمرار بيانات كبيرة. عندما يكون هناك العديد من المقاطع/الملفات الفيزيائية، كيف يجب أن ننشر البيانات في أقسام بيانات مختلفة؟</p>
<p>على الرغم من أن البيانات تأتي في المقام الأول بدلاً من الفهارس، إلا أنه يتعين علينا تخزين البيانات بالطريقة التي تفضلها خوارزمية الفهرس لجعل الوصول إلى البيانات بكفاءة في معظم الحالات. الاستراتيجية المستخدمة بشكل متكرر في قواعد بيانات SQL هي التقسيم حسب نطاق قيم مفاتيح التقسيم. عادةً ما ينشئ الأشخاص فهرسًا مجمعًا لفرض مفتاح التقسيم. بشكل عام، هذا نهج لائق لقواعد بيانات SQL. يتم تخزين البيانات في شكل جيد، ومحسّن للإدخال/الإخراج (الجلب المسبق). ولكن لا تزال هناك عيوب.</p>
<ul>
<li>انحراف البيانات. قد تحتوي بعض الأقسام على بيانات أكثر بكثير من غيرها. توزيع البيانات في العالم الحقيقي ليس بسيطًا مثل النطاق الرقمي.</li>
<li>الوصول إلى النقاط الساخنة. قد يذهب المزيد من عبء العمل إلى بعض أقسام البيانات.</li>
</ul>
<p>تخيل أن المزيد من عبء العمل يذهب إلى الأقسام التي تحتوي على بيانات أكثر. نحتاج إلى إعادة توازن البيانات عبر الأقسام عند حدوث هذه الحالات. (هذه هي الحياة اليومية المملة لمدير إدارة الأعمال).</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/clustered_index_f4a3322668.png" alt="The Clustered index for vectors" class="doc-image" id="the-clustered-index-for-vectors" />
   </span> <span class="img-wrapper"> <span>الفهرس المجمّع للمتجهات</span> </span></p>
<p>يمكننا أيضًا إنشاء فهرس مجمع للمتجهات (فهرس قائمة مقلوب). ولكن هذه ليست نفس حالة قواعد بيانات SQL. فبمجرد إنشاء الفهرس في قواعد بيانات SQL، يكون الوصول إلى البيانات من خلال الفهرس فعالاً للغاية، مع عمليات حسابية أقل وعمليات إدخال/إخراج أقل. ولكن بالنسبة للبيانات المتجهة، سيكون هناك عمليات حسابية وعمليات إدخال/إخراج أكثر بكثير حتى مع وجود فهرس. لذا فإن العيوب المذكورة من قبل سيكون لها تأثير أكثر حدة على مجموعات قواعد البيانات المتجهة. علاوة على ذلك، فإن تكلفة إعادة موازنة المتجهات عبر قطاعات مختلفة مرتفعة للغاية بسبب حجم البيانات وتعقيد الحوسبة.</p>
<p>في Milvus، نستخدم استراتيجية التقسيم حسب النمو. عندما نقوم بإدخال البيانات في مجموعة متجهات، يقوم Milvus بإلحاق المتجهات الجديدة بأحدث مقطع في المجموعة. سيغلق Milvus المقطع بمجرد أن يصبح حجمه كبيرًا بما فيه الكفاية (الحد الأدنى قابل للتكوين) وينشئ فهرسًا للمقطع المغلق. في غضون ذلك، سيتم إنشاء مقطع جديد لتخزين البيانات القادمة. هذه الاستراتيجية البسيطة أكثر توازناً لمعالجة المتجهات.</p>
<p>الاستعلام المتجه هو عملية للبحث عن المرشحين الأكثر تشابهًا في مجموعة المتجهات. إنه إجراء MapReduce نموذجي. على سبيل المثال، نريد البحث عن أفضل 20 نتيجة متشابهة من مجموعة متجهات تحتوي على عشرة مقاطع. يمكننا البحث عن أفضل 20 نتيجة في كل مقطع من المقاطع ثم دمج النتائج العشرين * 10 في النتائج العشرين النهائية. نظرًا لأن كل مقطع يحتوي على نفس الكمية من المتجهات والفهرس المتشابه، فإن وقت المعالجة على كل مقطع يكون متطابقًا تقريبًا. يمنحنا ذلك ميزة إمكانية التنبؤ بالأداء، وهو أمر ضروري عند التخطيط لحجم مجموعات قاعدة البيانات.</p>
<h3 id="New-paradigms-in-Milvus-20" class="common-anchor-header">النماذج الجديدة في ملفوس 2.0</h3><p>في Milvus 1.0، قمنا في Milvus 1.0 بتنفيذ مجموعة تجزئة تقسيم القراءة/الكتابة مثل معظم قواعد بيانات SQL. كانت محاولة جيدة لتوسيع نطاق مجموعة قواعد بيانات Milvus. لكن المشاكل واضحة تمامًا أيضًا.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/milvus_1_0_9b7441a58f.png" alt="Milvus database 1.0" class="doc-image" id="milvus-database-1.0" />
   </span> <span class="img-wrapper"> <span>قاعدة بيانات Milvus 1.0</span> </span></p>
<p>في Milvus 1.0، يجب أن تتولى عقدة R/W العناية الكاملة بالجزء الأخير، بما في ذلك إلحاق المتجهات، والبحث في هذا الجزء غير المفهرس، وبناء الفهرس، وما إلى ذلك. نظرًا لأن كل مجموعة تحتوي على كاتب واحد فقط، فإن الكاتب يكون مشغولاً للغاية إذا تم تدفق البيانات باستمرار إلى النظام. كما يمثل أداء مشاركة البيانات بين عقدة R/W وعقد القارئ مشكلة أيضًا. إلى جانب ذلك، يجب أن نعتمد إما على NFS (غير مستقر) أو التخزين السحابي المتميز (مكلف للغاية) لتخزين البيانات المشتركة.</p>
<p>من الصعب معالجة هذه المشاكل الحالية في بنية ميلفوس 1.0. وبالتالي، قمنا بإدخال نماذج جديدة في تصميم Milvus 2.0 Milvus 2.0 لحل هذه المشاكل.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/Milvus_architecture_feaccc489d.png" alt="Milvus architecture" class="doc-image" id="milvus-architecture" />
   </span> <span class="img-wrapper"> <span>بنية ميلفوس</span> </span></p>
<h4 id="Actor-model" class="common-anchor-header">نموذج الممثل</h4><p>هناك نموذجين لبرمجة أنظمة الحوسبة المتزامنة.</p>
<ul>
<li>الذاكرة المشتركة التي تعني التحكم في التزامن (القفل) والمعالجة المتزامنة</li>
<li>نموذج الممثل (المعروف أيضًا باسم تمرير الرسائل) يعني المعالجة القائمة على الرسائل والمعالجة غير المتزامنة</li>
</ul>
<p>يمكننا أيضًا تطبيق هذين النموذجين في مجموعات قواعد البيانات الموزعة.</p>
<p>كما ذكرنا من قبل، تستخدم معظم قواعد البيانات الموزعة رفيعة المستوى نفس الطريقة: تكرار سجل الإعادة بواسطة خوارزميات الإجماع. هذه هي المعالجة المتزامنة باستخدام خوارزميات الإجماع لبناء ذاكرة مشتركة موزعة لسجلات سجلات سجلات الإعادة. استثمرت الشركات المختلفة ورؤوس الأموال الاستثمارية مليارات الدولارات في هذه التقنية. لم أكن أرغب في التعليق على هذا الأمر حتى بدأنا العمل على Milvus 2.0. يعتبر الكثير من الناس أن هذه التقنية هي الطريقة الوحيدة لتحقيق أنظمة قواعد البيانات الموزعة. وهذا أمر مزعج. إذا لم أقل شيئًا، فقد يسيء الناس فهم أننا كنا متهورين في تصميم قواعد البيانات الموزعة.</p>
<p>في السنوات الأخيرة، كان النسخ المتماثل لإعادة التسجيل بواسطة خوارزميات الإجماع أكثر تقنيات قواعد البيانات المبالغة في تقديرها. هناك مشكلتان رئيسيتان.</p>
<ul>
<li>الافتراض بأن النسخ المتماثل لسجلات الإعادة أفضل هو افتراض هش.</li>
<li>تضليل البائعين لتوقعات الناس بشأن قدرة خوارزميات الإجماع.</li>
</ul>
<p>لنفترض أن لدينا عقدتين لقاعدة البيانات، العقدة المصدر والعقدة الهدف. في البداية، لديهم نسخة طبق الأصل من البيانات. لدينا بعض عمليات التغيير (عبارات SQL (I/U/D) على العقدة المصدر، ونريد تحديث العقدة الهدف. ماذا علينا أن نفعل؟ أبسط طريقة هي إعادة تشغيل العمليات على العقدة الهدف. لكن هذه ليست الطريقة الأكثر فعالية.</p>
<p>بالتفكير في التكلفة التشغيلية لبيان I/U/D، يمكننا تقسيمها إلى جزء إعداد التنفيذ وجزء العمل الفعلي. يتضمن جزء إعداد التنفيذ عمل محلل SQL، ومحسن SQL، وما إلى ذلك. بغض النظر عن عدد سجلات البيانات التي ستتأثر، فهي تكلفة ثابتة. تعتمد تكلفة جزء العمل الفعلي على عدد سجلات البيانات التي ستتأثر؛ فهي تكلفة عائمة. تكمن الفكرة وراء تكرار سجلات الإعادة في توفير التكلفة الثابتة على العقدة الهدف؛ فنحن نقوم فقط بإعادة تشغيل سجلات الإعادة (العمل المادي) على العقدة الهدف.</p>
<p>النسبة المئوية لتوفير التكلفة هي مقلوب عدد سجلات سجلات الإعادة. إذا كانت عملية واحدة تؤثر على سجل واحد فقط، يجب أن أرى وفورات كبيرة من تكرار سجلات الإعادة. ماذا لو كانت 10,000 سجل؟ عندها يجب أن نقلق بشأن موثوقية الشبكة. أيهما أكثر موثوقية: إرسال عملية واحدة أم 10,000 سجل سجلات سجلات إعادة التسجيل؟ ماذا عن مليون سجل؟ يعد نسخ سجلات إعادة التسجيل فائقة في سيناريوهات مثل أنظمة الدفع وأنظمة البيانات الوصفية وما إلى ذلك. في هذه السيناريوهات، تؤثر كل عملية إعادة/إعادة تشغيل/إعادة سجل في قاعدة البيانات على عدد صغير فقط من السجلات (1 أو 2). ولكن من الصعب العمل مع أعباء العمل المكثفة للإدخال/الإخراج مثل المهام المجمعة.</p>
<p>يدعي البائعون دائمًا أن خوارزميات الإجماع يمكن أن توفر اتساقًا قويًا لمجموعات قواعد البيانات. لكن الناس لا يستخدمون خوارزميات الإجماع إلا لتكرار سجلات سجلات سجلات الإعادة. تكون سجلات سجلات سجلات الإعادة متسقة على عقد مختلفة، ولكن هذا لا يعني أن طرق عرض البيانات على العقد الأخرى متسقة أيضًا. علينا دمج سجلات سجلات سجلات الإعادة في سجلات الجدول الفعلية. لذا، حتى مع هذه المعالجة المتزامنة، لا يزال بإمكاننا الحصول على الاتساق النهائي فقط على طرق عرض البيانات.</p>
<p>يجب علينا استخدام تكرار سجلات سجلات الإعادة بواسطة خوارزميات الإجماع في الأماكن المناسبة. لقد قام نظام البيانات الوصفية (ETCD) ومنصة المراسلة (على سبيل المثال، Apache Pulsar) المستخدمة في Milvus 2.0 بتطبيق خوارزميات الإجماع. ولكن كما قلت من قبل، "بالنسبة لقاعدة بيانات Milvus المتجهة، لا نجد ما يكفي من الحوافز لكونها مجموعة نسخ متماثلة لآلة الحالة ككل."</p>
<p>في ميلفوس 2.0، نستخدم نموذج الممثل لتنظيم العقد العاملة. العقد العاملة وحيدة. يتحدثون فقط إلى منصة المراسلة ويتلقون الأوامر ويرسلون النتائج. يبدو الأمر مملًا.</p>
<blockquote>
<p>&quot;الممل هو الأفضل دائمًا.&quot; - الحارس الشخصي للقاتل المأجور (2017)</p>
</blockquote>
<p>نموذج الممثل غير متزامن. وهو مناسب لقابلية التوسع والتوافر. نظرًا لأن العقد العاملة لا تعرف بعضها البعض، فلا يوجد تأثير على العقد العاملة الأخرى إذا انضمت بعض العقد العاملة أو تمت إزالتها.</p>
<h4 id="Separation-of-availability-and-durability" class="common-anchor-header">الفصل بين التوافر والمتانة</h4><p>في Milvus 2.0، نقوم بإعادة تشغيل العملية بدلاً من إعادة تشغيل السجل، لأنه في قاعدة البيانات المتجهة، لا يوجد فرق كبير بين إعادة تشغيل العملية وإعادة تشغيل السجل. ليس لدينا دالة التحديث ولا دالة الإدراج مع تحديد. كما أنه من الأسهل بكثير إجراء إعادة التشغيل مع نموذج الممثل.</p>
<p>لذا قد تنفذ عدة عقد عاملة نفس العملية من منصة المراسلة وفقًا لمسؤوليتها. لقد ذكرت من قبل أننا قررنا استخدام التخزين السحابي S3 كطبقة تخزين مشتركة لمجموعة قاعدة بيانات Milvus. تخزين S3 موثوق للغاية. ثم هل من الضروري أن تقوم العقد العاملة المختلفة بكتابة نفس البيانات على التخزين المشترك؟</p>
<p>وهكذا صممنا ثلاثة أدوار للعقد العاملة.</p>
<ul>
<li>تحافظ عقدة الاستعلام على عرض البيانات في الذاكرة وفقًا للتعيين. يتضمن عمل عقدة الاستعلام إجراء بحث متجه والحفاظ على تحديث البيانات داخل الذاكرة. لكنها لا تحتاج إلى كتابة أي شيء إلى مخزن S3. إنها العقدة الأكثر حساسية للذاكرة في المجموعة.</li>
<li>عقدة البيانات مسؤولة عن كتابة البيانات الجديدة إلى مخزن S3. لا تحتاج عقدة البيانات إلى الحفاظ على عرض البيانات في الذاكرة، لذا فإن تكوين الأجهزة لعقدة البيانات يختلف تمامًا عن عقدة الاستعلام.</li>
<li>تنشئ عقدة الفهرس فهارس للمقاطع التي أغلقتها عقدة البيانات عندما يصل حجم المقاطع إلى الحد الأدنى. هذا هو العمل الأكثر استهلاكًا لوحدة المعالجة المركزية في المجموعة.</li>
</ul>
<p>تمثل هذه الأنواع الثلاثة من العقد أنواعًا مختلفة من أعباء العمل. ويمكنها التوسع بشكل مستقل. نحن نسميها فصل التوافر والمتانة المستفادة من قاعدة بيانات Microsoft Socrates السحابية.</p>
<h2 id="The-end-also-the-beginning" class="common-anchor-header">النهاية والبداية أيضًا<button data-href="#The-end-also-the-beginning" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>استعرضت هذه المقالة العديد من قرارات تصميم قاعدة بيانات ميلفوس المتجهة 2.0.  دعونا نختتم هذه النقاط بسرعة هنا.</p>
<ul>
<li>لقد اخترنا الاتساق النهائي لمجموعة ميلفوس السحابية 2.0.</li>
<li>لقد قمنا بدمج المكونات السحابية الناضجة في ميلفوس 2.0 بقدر ما نستطيع. قمنا بالتحكم بالمكونات الجديدة التي أدخلها ميلفوس 2.0 في بيئات إنتاج المستخدمين.</li>
<li>من خلال اتباع نموذج الممثل والفصل بين التوافر والمتانة، أصبح من السهل توسيع نطاق ميلفوس 2.0 في البيئة السحابية.</li>
</ul>
<p>لقد شكلنا حتى الآن العمود الفقري لقاعدة بيانات Milvus 2.0 القابلة للتوسع في السحابة، ولكن لدينا العديد من المتطلبات المتراكمة من مجتمع Milvus التي يجب تلبيتها. إذا كانت لديك نفس المهمة ("بناء المزيد من برمجيات البنية التحتية مفتوحة المصدر لتسريع التحول في مجال الذكاء الاصطناعي"، فمرحبًا بك للانضمام إلى مجتمع Milvus.</p>
<p>Milvus هو مشروع تخرج من مؤسسة LF AI &amp; Data Foundation. أنت لست بحاجة إلى التوقيع على أي اتفاقية قانونية لميلفوس!</p>
<h2 id="Appendix" class="common-anchor-header">الملحق<button data-href="#Appendix" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><h3 id="Milvus-design-doc" class="common-anchor-header">مستند تصميم ميلفوس</h3><p><a href="https://github.com/milvus-io/milvus/tree/master/docs/design_docs">https://github.com/milvus-io/milvus/tree/master/docs/design_docs</a></p>
<ul>
<li><a href="https://github.com/milvus-io/milvus/blob/master/docs/design_docs/20211215-milvus_timesync.md">مزامنة وقت ميلفوس</a></li>
</ul>
<h3 id="Raft-implementation-in-C++" class="common-anchor-header">تنفيذ الطوافة في C++</h3><p>إذا كنت لا تزال مهتمًا بخوارزمية الإجماع، أقترح عليك التحقق من <a href="https://github.com/eBay/Gringofts">مشروع Gringofts مفتوح المصدر الخاص بـ eBay</a>. إنه تطبيق C++ لخوارزمية إجماع الطوافة (متغير من عائلة باكسوس). وقد قام صديقي جاكي وإلفيس (زملائي السابقون في مورغان ستانلي) ببنائه لنظام الدفع عبر الإنترنت في eBay، وهو بالتحديد أحد أكثر السيناريوهات ملاءمة لهذه التقنية.</p>
