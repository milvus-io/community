---
id: >-
  accelerating-compilation-with-dependency-decoupling-and-testing-containerization.md
title: تسريع التجميع التجميع 2.5 مرة مع فصل التبعية واختبار الحاويات
author: Zhifeng Zhang
date: 2021-05-28T00:00:00.000Z
desc: >-
  اكتشف كيف يقلل zilliz من زمن التحويل البرمجي 2.5 مرة باستخدام تقنيات فصل
  التبعية والحاويات لمشاريع الذكاء الاصطناعي وعمليات التشغيل الآلي متعددة
  الوظائف واسعة النطاق.
cover: assets.zilliz.com/cover_20e3cddb96.jpeg
tag: Engineering
canonicalUrl: >-
  https://zilliz.com/blog/accelerating-compilation-with-dependency-decoupling-and-testing-containerization
---
<custom-h1>تسريع التحويل البرمجي 2.5 مرة مع فصل التبعيات واختبار الاحتواء</custom-h1><p>يمكن أن يتفاقم وقت التحويل البرمجي بسبب التبعيات الداخلية والخارجية المعقدة التي تتطور خلال عملية التطوير، بالإضافة إلى التغييرات في بيئات التجميع مثل نظام التشغيل أو بنية الأجهزة. فيما يلي بعض المشكلات الشائعة التي قد يواجهها المرء عند العمل على مشاريع الذكاء الاصطناعي أو مشاريع MLOps واسعة النطاق:</p>
<p><strong>تجميع طويل للغاية</strong> - يتم تجميع التعليمات البرمجية مئات المرات كل يوم. مع وجود مئات الآلاف من أسطر التعليمات البرمجية في المكان، قد يؤدي حتى تغيير بسيط إلى تجميع كامل يستغرق عادةً ساعة أو أكثر.</p>
<p><strong>بيئة التجميع المعقدة</strong> - يجب تجميع كود المشروع تحت بيئات مختلفة، والتي تتضمن أنظمة تشغيل مختلفة، مثل CentOS وUbuntu، والتبعية الأساسية، مثل GCC وLLVM وCUDA، وبنى الأجهزة. والتجميع في بيئة معينة قد لا يعمل عادةً في بيئة مختلفة.</p>
<p><strong>التبعيات المعقدة</strong> - يتضمن تجميع المشروع أكثر من 30 تبعية بين المكونات وتبعيات الطرف الثالث. وغالباً ما يؤدي تطوير المشروع إلى تغييرات في التبعيات، مما يؤدي حتماً إلى تعارض التبعيات. التحكم في الإصدار بين التبعيات معقد للغاية بحيث يؤثر تحديث إصدار التبعيات بسهولة على المكونات الأخرى.</p>
<p><strong>بطء تنزيل التبعيات التابعة للجهات الخارجية أو فشلها</strong> - تتسبب التأخيرات في الشبكة أو مكتبات التبعيات الخارجية غير المستقرة في بطء تنزيل الموارد أو فشل الوصول إليها، مما يؤثر بشكل خطير على تكامل التعليمات البرمجية.</p>
<p>من خلال فصل التبعيات وتنفيذ اختبار الحاويات، تمكنا من تقليل متوسط وقت التحويل البرمجي بنسبة 60% أثناء العمل على مشروع البحث عن تشابه التضمينات مفتوح المصدر <a href="https://milvus.io/">Milvus</a>.</p>
<p><br/></p>
<h3 id="Decouple-the-dependencies-of-the-project" class="common-anchor-header">فصل تبعيات المشروع</h3><p>عادةً ما يتضمن تجميع المشروع عددًا كبيرًا من تبعيات المكونات الداخلية والخارجية. وكلما زاد عدد التبعيات في المشروع، أصبحت إدارتها أكثر تعقيدًا. ومع نمو البرنامج، يصبح تغيير أو إزالة التبعيات أو إزالتها أكثر صعوبة وتكلفة، بالإضافة إلى تحديد آثار القيام بذلك. الصيانة المنتظمة مطلوبة طوال عملية التطوير لضمان عمل التبعيات بشكل صحيح. يمكن أن تتسبب الصيانة الضعيفة أو التبعيات المعقدة أو التبعيات المعيبة في حدوث تعارضات تؤدي إلى إبطاء أو تعطيل التطوير. ومن الناحية العملية، يمكن أن يعني ذلك تأخر تنزيلات الموارد، وفشل الوصول الذي يؤثر سلبًا على تكامل التعليمات البرمجية، وغير ذلك. يمكن لفصل تبعيات المشروع أن يخفف من العيوب ويقلل من وقت التجميع، مما يسرع من اختبار النظام وتجنب العوائق غير الضرورية في تطوير البرمجيات.</p>
<p>لذلك، نوصي بفصل التبعيات في مشروعك:</p>
<ul>
<li>فصل المكونات ذات التبعيات المعقدة</li>
<li>استخدم مستودعات مختلفة لإدارة الإصدارات.</li>
<li>استخدم ملفات التكوين لإدارة معلومات الإصدار وخيارات التجميع والتبعيات وما إلى ذلك.</li>
<li>أضف ملفات التهيئة إلى مكتبات المكونات بحيث يتم تحديثها مع تكرار المشروع.</li>
</ul>
<p><strong>تحسين التحويل البرمجي بين المكونات</strong> - سحب وتجميع المكون ذي الصلة وفقًا للتبعيات وخيارات التحويل البرمجي المسجلة في ملفات التكوين. ضع علامة على نتائج التحويل البرمجي الثنائي وملفات البيان المقابلة لها وحزمها، ثم ارفعها إلى مستودعك الخاص. إذا لم يتم إجراء أي تغيير على أحد المكونات أو المكونات التي يعتمد عليها، فقم بتشغيل نتائج التحويل البرمجي الخاصة به وفقًا لملفات البيان. بالنسبة لمشكلات مثل التأخير في الشبكة أو مكتبات تبعية الطرف الثالث غير المستقرة، حاول إعداد مستودع داخلي أو استخدام مستودعات معكوسة.</p>
<p>لتحسين التجميع بين المكونات</p>
<p>1- إنشاء رسم بياني لعلاقة التبعية - استخدم ملفات التكوين في مكتبات المكونات لإنشاء رسم بياني لعلاقة التبعية. استخدم علاقة التبعية لاسترداد معلومات الإصدار (فرع Git، والوسم، ومعرف التزام Git) وخيارات التحويل البرمجي والمزيد من المكونات التابعة في المنبع والمصب.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/1_949dffec32.png" alt="1.png" class="doc-image" id="1.png" />
   </span> <span class="img-wrapper"> <span>1.png</span> </span></p>
<p><strong>2- التحقق من التبعيات</strong> - قم بإنشاء تنبيهات للتبعيات الدائرية وتعارضات الإصدارات وغيرها من المشكلات التي تنشأ بين المكونات.</p>
<p><strong>3- تسطيح الت</strong> بعيات - فرز التبعيات حسب البحث في العمق أولًا (DFS) ودمج المكونات ذات التبعيات المكررة لتشكيل رسم بياني للتبعية.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/2_45130c55e4.png" alt="2.png" class="doc-image" id="2.png" />
   </span> <span class="img-wrapper"> <span>2.png</span> </span></p>
<p>4- استخدم خوارزمية MerkleTree لتوليد تجزئة (تجزئة جذرية) تحتوي على تبعيات كل مكون بناءً على معلومات الإصدار وخيارات التجميع وغيرها. بالإضافة إلى معلومات مثل اسم المكون، تشكل الخوارزمية علامة فريدة لكل مكون.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/3_6a4fcdf4e3.png" alt="3.png" class="doc-image" id="3.png" />
   </span> <span class="img-wrapper"> <span>3.png</span> </span></p>
<p>5- استنادًا إلى معلومات العلامة الفريدة للمكون، تحقق مما إذا كان هناك أرشيف تجميعي مطابق موجود في الريبو الخاص. إذا تم استرجاع أرشيف تجميعي، قم بفك ضغطه للحصول على ملف البيان للتشغيل؛ إذا لم يكن كذلك، قم بتحويل المكون إلى تجميع، وقم بترميز ملفات كائنات التجميع المُنشأة وملف البيان، وقم بتحميلها إلى الريبو الخاص.</p>
<p><br/></p>
<p><strong>تنفيذ تحسينات التحويل البرمجي داخل المكونات</strong> - اختر أداة تخزين مؤقت للتحويل البرمجي خاصة باللغة لتخزين ملفات الكائنات المحولة مؤقتًا، وقم بتحميلها وتخزينها في المستودع الخاص. For C/C++ compilation, choose a compilation cache tool like CCache to cache the C/C++ compilation intermediate files, and then archive the local CCache cache after compilation. تقوم أدوات ذاكرة التخزين المؤقت للتجميع هذه ببساطة بتخزين ملفات التعليمات البرمجية المتغيرة واحدًا تلو الآخر بعد التجميع، ونسخ المكونات المجمعة لملف التعليمات البرمجية التي لم تتغير بحيث يمكن إشراكها مباشرةً في التجميع النهائي. يتضمن تحسين التجميع داخل المكونات الخطوات التالية:</p>
<ol>
<li>إضافة تبعيات التجميع الضرورية إلى ملف Dockerfile. استخدام Hadolint لإجراء فحوصات التوافق على ملف Dockerfile لضمان توافق الصورة مع أفضل ممارسات Docker.</li>
<li>قم بنسخ بيئة التجميع وفقًا لإصدار سبرينت المشروع (الإصدار + البناء) ونظام التشغيل ومعلومات أخرى.</li>
<li>قم بتشغيل حاوية بيئة التجميع المنسوخة، وانقل معرف الصورة إلى الحاوية كمتغير بيئة. إليك مثال على أمر للحصول على معرّف الصورة: "docker inspect " - النوع=صورة" - التنسيق "{{.ID}}" مستودع/بناء-إنف:v0.1-centos7".</li>
<li>اختر الأداة المناسبة لتجميع ذاكرة التخزين المؤقت: أدخل أداة الاحتواء الخاصة بك لدمج وتجميع أكوادك وتحقق في المستودع الخاص بك إذا كانت هناك ذاكرة تخزين مؤقتة مناسبة للتجميع. إذا كانت الإجابة بنعم، قم بتنزيلها واستخراجها إلى الدليل المحدد. بعد أن يتم تجميع جميع المكونات، يتم حزم ذاكرة التخزين المؤقت التي تم إنشاؤها بواسطة أداة تجميع ذاكرة التخزين المؤقت وتحميلها إلى مستودعك الخاص بناءً على إصدار المشروع ومعرف الصورة.</li>
</ol>
<p><br/></p>
<h3 id="Further-compilation-optimization" class="common-anchor-header">تحسين التحويل البرمجي الإضافي</h3><p>يشغل التجميع الأولي لدينا مساحة كبيرة جدًا على القرص والنطاق الترددي للشبكة، ويستغرق وقتًا طويلاً للنشر، اتخذنا الإجراءات التالية</p>
<ol>
<li>اختر الصورة الأساسية الأصغر حجمًا لتقليل حجم الصورة، على سبيل المثال: Alpine، وBoolbox، إلخ.</li>
<li>تقليل عدد طبقات الصورة. إعادة استخدام التبعيات قدر الإمكان. دمج أوامر متعددة باستخدام "&amp;&amp;".</li>
<li>تنظيف المنتجات الوسيطة أثناء بناء الصورة.</li>
<li>استخدام ذاكرة التخزين المؤقت للصور لبناء الصورة قدر الإمكان.</li>
</ol>
<p>مع استمرار تقدم مشروعنا، بدأ استخدام الأقراص وموارد الشبكة في الارتفاع مع زيادة ذاكرة التخزين المؤقت للتجميع، في حين أن بعض ذاكرات التخزين المؤقت للتجميع غير مستغلة بشكل كافٍ. قمنا بعد ذلك بإجراء التعديلات التالية:</p>
<p><strong>تنظيف ملفات ذاكرة التخزين المؤقت بانتظام</strong> - التحقق بانتظام من المستودع الخاص (باستخدام البرامج النصية على سبيل المثال)، وتنظيف ملفات ذاكرة التخزين المؤقت التي لم تتغير منذ فترة أو لم يتم تنزيلها كثيرًا.</p>
<p><strong>التخزين الانتقائي لملفات التحويل البرمجي الانتقائية</strong> - قم بتخزين الملفات التي تتطلب موارد كثيرة فقط في ذاكرة التخزين المؤقت، وتخطي ملفات التحويل البرمجي التي لا تتطلب الكثير من الموارد.</p>
<p><br/></p>
<h3 id="Leveraging-containerized-testing-to-reduce-errors-improve-stability-and-reliability" class="common-anchor-header">الاستفادة من اختبار الحاويات لتقليل الأخطاء وتحسين الاستقرار والموثوقية</h3><p>يجب تجميع البرمجيات في بيئات مختلفة، والتي تتضمن مجموعة متنوعة من أنظمة التشغيل (مثل CentOS وUbuntu)، والتبعية الأساسية (مثل GCC وLLVM وCUDA)، وبنى أجهزة محددة. التعليمات البرمجية التي يتم تجميعها بنجاح في بيئة معينة تفشل في بيئة مختلفة. من خلال تشغيل الاختبارات داخل الحاويات، تصبح عملية الاختبار أسرع وأكثر دقة.</p>
<p>تضمن الحاويات أن بيئة الاختبار متسقة، وأن التطبيق يعمل كما هو متوقع. يقوم نهج الاختبار في الحاويات بتعبئة الاختبارات كحاويات صور وبناء بيئة اختبار معزولة حقاً. وجد المختبرون لدينا أن هذا النهج مفيد جدًا، مما أدى في النهاية إلى تقليل أوقات التجميع بنسبة تصل إلى 60%.</p>
<p><strong>ضمان بيئة تجميع متسقة</strong> - نظرًا لأن المنتجات المجمعة حساسة للتغيرات في بيئة النظام، فقد تحدث أخطاء غير معروفة في أنظمة التشغيل المختلفة. يجب علينا وضع علامات وأرشفة ذاكرة التخزين المؤقت للمنتجات المجمّعة وفقًا للتغييرات في بيئة التجميع، ولكن يصعب تصنيفها. لذلك قمنا بإدخال تقنية التجميع في حاويات لتوحيد بيئة التحويل البرمجي لحل مثل هذه المشكلات.</p>
<p><br/></p>
<h3 id="Conclusion" class="common-anchor-header">الخاتمة</h3><p>من خلال تحليل تبعيات المشروع، تقدم هذه المقالة طرقًا مختلفة لتحسين التحويل البرمجي بين المكونات وداخلها، مما يوفر أفكارًا وأفضل الممارسات لبناء تكامل مستقر وفعال للتعليمات البرمجية المستمرة. ساعدت هذه الأساليب في حل مشكلة بطء تكامل التعليمات البرمجية الناجمة عن التبعيات المعقدة، وتوحيد العمليات داخل الحاوية لضمان اتساق البيئة، وتحسين كفاءة التجميع من خلال تشغيل نتائج التجميع واستخدام أدوات التخزين المؤقت للتجميع لتخزين نتائج التجميع الوسيطة مؤقتًا.</p>
<p>أدت هذه الممارسات المذكورة أعلاه إلى تقليل وقت التحويل البرمجي للمشروع بنسبة 60% في المتوسط، مما أدى إلى تحسين الكفاءة الكلية لتكامل الأكواد بشكل كبير. من الآن فصاعدًا، سنستمر في التحويل البرمجي المتوازي بين المكونات وداخلها لتقليل زمن التحويل البرمجي بشكل أكبر.</p>
<p><br/></p>
<p><em>تم استخدام المصادر التالية لهذه المقالة:</em></p>
<ul>
<li>"فصل الأشجار المصدرية في مكونات مستوى البناء"</li>
<li>"<a href="https://dev.to/brpaz/factors-to-consider-when-adding-third-party-dependencies-to-a-project-46hf">عوامل يجب مراعاتها عند إضافة تبعيات الطرف الثالث إلى مشروع</a>"</li>
<li>"<a href="https://queue.acm.org/detail.cfm?id=3344149">النجاة من تبعيات البرمجيات</a>"</li>
<li>"<a href="https://www.cc.gatech.edu/~beki/t1.pdf">فهم التبعيات: دراسة تحديات التنسيق في تطوير البرمجيات" "دراسة تحديات التنسيق في تطوير البرمجيات</a>"</li>
</ul>
<p><br/></p>
<h3 id="About-the-author" class="common-anchor-header">نبذة عن المؤلف</h3><p>تشيفنغ تشانغ هو مهندس أول في DevOps في Zilliz.com يعمل على قاعدة بيانات Milvus، وهي قاعدة بيانات متجهة مفتوحة المصدر، ومدرب معتمد من جامعة LF للبرمجيات مفتوحة المصدر في الصين. حصل على درجة البكالوريوس في إنترنت الأشياء (IOT) من معهد هندسة البرمجيات في قوانغتشو. أمضى حياته المهنية في المشاركة في مشاريع وقيادة مشاريع في مجال CI/CD، و DevOps، وإدارة البنية التحتية لتكنولوجيا المعلومات، ومجموعة أدوات السحابة الأصلية، والحاويات، وتحسين عملية التجميع.</p>
