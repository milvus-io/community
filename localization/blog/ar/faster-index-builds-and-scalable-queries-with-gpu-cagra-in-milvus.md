---
id: faster-index-builds-and-scalable-queries-with-gpu-cagra-in-milvus.md
title: >-
  تحسين NVIDIA CAGRA في Milvus: نهج هجين بين وحدة معالجة الرسومات ووحدة المعالجة
  المركزية (GPU) لفهرسة أسرع واستعلامات أرخص
author: Marcelo Chen
date: 2025-12-10T00:00:00.000Z
cover: assets.zilliz.com/CAGRA_cover_7b9675965f.png
tag: Engineering
recommend: false
publishToMedium: true
tags: 'Milvus, vector database'
meta_keywords: 'Milvus2.6, CAGRA, GPU, CPU, graph-based index'
meta_title: |
  Optimizing CAGRA in Milvus: A Hybrid GPU–CPU Approach
desc: >-
  تعرّف على كيفية استخدام GPU_CAGRA في Milvus 2.6 لوحدات معالجة الرسومات
  البيانية لإنشاء رسم بياني سريع ووحدات المعالجة المركزية لخدمة الاستعلامات
  القابلة للتطوير.
origin: >-
  https://milvus.io/blog/faster-index-builds-and-scalable-queries-with-gpu-cagra-in-milvus.md
---
<p>مع انتقال أنظمة الذكاء الاصطناعي من مرحلة التجارب إلى البنية التحتية للإنتاج، لم تعد قواعد البيانات المتجهة تتعامل مع ملايين التضمينات. <strong>أصبحت المليارات الآن روتينية، وعشرات المليارات شائعة بشكل متزايد.</strong> على هذا النطاق، لا تؤثر الخيارات الخوارزمية على الأداء والاسترجاع فحسب، بل تُترجم مباشرةً إلى تكلفة البنية التحتية.</p>
<p>وهذا يؤدي إلى سؤال أساسي لعمليات النشر على نطاق واسع: <strong>كيف تختار الفهرس المناسب لتقديم استدعاء وزمن استجابة مقبول دون السماح باستخدام موارد الحوسبة بشكل متصاعد خارج نطاق السيطرة؟</strong></p>
<p>لقد أصبحت الفهارس القائمة على الرسوم البيانية مثل <strong>NSW وHNSW وCAGRA وVamana</strong> هي الإجابة الأكثر اعتماداً على نطاق واسع. من خلال التنقل في الرسوم البيانية للأحياء المبنية مسبقًا، تتيح هذه الفهارس إمكانية البحث السريع عن أقرب جار على نطاق مليار، وتجنب المسح الضوئي الغاشم ومقارنة كل متجه بالاستعلام.</p>
<p>ومع ذلك، فإن ملف تعريف التكلفة لهذا النهج غير متكافئ. <strong>فالاستعلام عن الرسم البياني رخيص نسبيًا؛ أما إنشاؤه فليس كذلك.</strong> يتطلب إنشاء رسم بياني عالي الجودة إجراء عمليات حسابية واسعة النطاق للمسافة وتنقيحًا متكررًا عبر مجموعة البيانات بأكملها - وهي أعباء عمل تكافح موارد وحدة المعالجة المركزية التقليدية للتعامل معها بكفاءة مع نمو البيانات.</p>
<p>تعالج CAGRA من NVIDIA هذا الاختناق من خلال استخدام وحدات معالجة الرسومات لتسريع بناء الرسم البياني من خلال التوازي الهائل. وعلى الرغم من أن هذا يقلل بشكل كبير من وقت الإنشاء، إلا أن الاعتماد على وحدات معالجة الرسومات في إنشاء الفهرس وخدمة الاستعلامات على حد سواء يفرض قيودًا أعلى من حيث التكلفة وقابلية التوسع في بيئات الإنتاج.</p>
<p>ولموازنة هذه المفاضلات، <strong>يتبنى</strong> <a href="https://milvus.io/docs/release_notes.md#v261">Milvus 2.6.1</a> <strong>تصميمًا هجينًا</strong> <strong>لفهارس</strong> <a href="https://milvus.io/docs/gpu-cagra.md">GPU_CAGRA</a>: <strong>تُستخدم وحدات معالجة الرسوم البيانية فقط لبناء الرسم البياني، بينما يتم تنفيذ الاستعلام على وحدات المعالجة المركزية.</strong> يحافظ هذا على مزايا جودة الرسوم البيانية المبنية على وحدة معالجة الرسومات البيانية مع الحفاظ على قابلية التوسع في خدمة الاستعلام وفعالية التكلفة، مما يجعلها مناسبة بشكل خاص لأحمال العمل ذات التحديثات غير المتكررة للبيانات وأحجام الاستعلامات الكبيرة والحساسية الصارمة للتكلفة.</p>
<h2 id="What-Is-CAGRA-and-How-Does-It-Work" class="common-anchor-header">ما هي CAGRA وكيف تعمل؟<button data-href="#What-Is-CAGRA-and-How-Does-It-Work" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>تنقسم فهارس المتجهات القائمة على الرسم البياني عمومًا إلى فئتين رئيسيتين:</p>
<ul>
<li><p><strong>بناء الرسم البياني التكراري،</strong> ويمثله <strong>CAGRA</strong> (مدعوم بالفعل في Milvus).</p></li>
<li><p><strong>بناء الرسم البياني القائم على الإدراج،</strong> ويمثله <strong>Vamana</strong> (قيد التطوير حاليًا في Milvus).</p></li>
</ul>
<p>يختلف هذان الأسلوبان اختلافًا كبيرًا في أهداف تصميمهما وأسسهما التقنية، مما يجعل كل منهما مناسبًا لمقاييس البيانات وأنماط أعباء العمل المختلفة.</p>
<p>إن<strong>NVIDIA CAGRA (القائمة على الرسم البياني لو</strong> حدة معالجة الرسوم البيانية لوحدة معالجة الرسوم البيانية) هي خوارزمية أصلية لوحدة معالجة الرسوم البيانية للبحث التقريبي عن أقرب جار (ANN)، وهي مصممة لبناء الرسوم البيانية المتقاربة واسعة النطاق والاستعلام عنها بكفاءة. ومن خلال الاستفادة من توازيية وحدة معالجة الرسوم البيانية، تعمل CAGRA على تسريع بناء الرسم البياني بشكل كبير وتوفر أداء استعلام عالي الإنتاجية مقارنةً بالنهج القائمة على وحدة المعالجة المركزية مثل HNSW.</p>
<p>تم بناء CAGRA على خوارزمية <strong>NN-Descent (أقرب جار منحدر)</strong> ، والتي تقوم ببناء رسم بياني لأقرب جار (kNN) من خلال التنقيح التكراري. في كل عملية تكرار، يتم تقييم وتحديث الجيران المرشحين وتحديثهم، بحيث يتقاربون تدريجيًا نحو علاقات جوار أعلى جودة عبر مجموعة البيانات.</p>
<p>بعد كل جولة تنقيح، تطبق CAGRA تقنيات تشذيب إضافية للرسم البياني - مثل <strong>تشذيب الالتفاف من قفزتين</strong>- لإزالة الحواف الزائدة عن الحاجة مع الحفاظ على جودة البحث. ينتج عن هذا المزيج من التنقيح والتشذيب التكراري <strong>رسم بياني مضغوط ومتصل جيدًا</strong> وفعال في وقت الاستعلام.</p>
<p>من خلال التنقيح والتشذيب المتكرر، تنتج CAGRA بنية رسم بياني تدعم <strong>الاستدعاء العالي والبحث القريب من الأقرب في زمن استجابة منخفض على نطاق واسع،</strong> مما يجعلها مناسبة بشكل خاص لمجموعات البيانات الثابتة أو التي يتم تحديثها بشكل غير متكرر.</p>
<h3 id="Step-1-Building-the-Initial-Graph-with-NN-Descent" class="common-anchor-header">الخطوة 1: بناء الرسم البياني الأولي باستخدام NN-Descent</h3><p>يعتمد NN-Descent على ملاحظة بسيطة ولكنها قوية: إذا كانت العقدة <em>u</em> جارة للعقدة <em>v،</em> والعقدة <em>w</em> جارة للعقدة <em>u،</em> فمن المحتمل جدًا أن تكون <em>w</em> جارة للعقدة <em>v</em> أيضًا. تسمح هذه الخاصية المتعدية للخوارزمية باكتشاف الجيران الأقرب الحقيقيين بكفاءة، دون مقارنة كل زوج من المتجهات بشكل شامل.</p>
<p>تستخدم CAGRA خوارزمية NN-Descent كخوارزمية أساسية لبناء الرسم البياني. تعمل العملية على النحو التالي:</p>
<p><strong>1. تهيئة عشوائية:</strong> تبدأ كل عقدة بمجموعة صغيرة من الجيران المختارين عشوائيًا، لتكوين رسم بياني أولي تقريبي.</p>
<p><strong>2. توسيع الجيران:</strong> في كل تكرار، تجمع العقدة جيرانها الحاليين وجيرانهم لتشكيل قائمة مرشحين. تحسب الخوارزمية أوجه التشابه بين العقدة وجميع المرشحين. ولأن قائمة مرشحي كل عقدة مستقلة، يمكن تعيين هذه العمليات الحسابية إلى كتل خيطية منفصلة لوحدة معالجة الرسومات وتنفيذها بالتوازي على نطاق واسع.</p>
<p><strong>3. تحديث قائمة المرشحين:</strong> إذا عثرت الخوارزمية على مرشحين أقرب من جيران العقدة الحاليين، فإنها تقوم بتبديل الجيران الأبعد وتحديث قائمة kNN للعقدة. على مدى عدة تكرارات، تُنتج هذه العملية رسمًا بيانيًا تقريبيًا أعلى جودة بكثير من kNN.</p>
<p><strong>4. التحقق من التقارب:</strong> مع تقدم التكرارات، يحدث عدد أقل من تحديثات الجيران. بمجرد انخفاض عدد الاتصالات المحدثة إلى أقل من عتبة محددة، تتوقف الخوارزمية، مما يشير إلى أن الرسم البياني قد استقر بشكل فعال.</p>
<p>نظرًا لأن توسيع الجار وحساب التشابه للعقد المختلفة مستقلان تمامًا، تقوم CAGRA بتعيين عبء عمل NN-Descent لكل عقدة إلى كتلة خيطية مخصصة لوحدة معالجة الرسومات. يتيح هذا التصميم توازيًا هائلاً ويجعل بناء الرسم البياني أسرع بكثير من الطرق التقليدية القائمة على وحدة المعالجة المركزية.</p>
<h3 id="Step-2-Pruning-the-Graph-with-2-Hop-Detours" class="common-anchor-header">الخطوة 2: تشذيب الرسم البياني باستخدام تحويلات القفزة 2</h3><p>بعد اكتمال NN-Descent، يكون الرسم البياني الناتج دقيقًا ولكنه كثيف للغاية. يحتفظ NN-Descent عمدًا بجيران مرشحين إضافيين، وتُدخل مرحلة التهيئة العشوائية العديد من الحواف الضعيفة أو غير ذات الصلة. ونتيجة لذلك، غالبًا ما ينتهي الأمر بكل عقدة بدرجة أعلى مرتين - أو حتى عدة مرات - من الدرجة المستهدفة.</p>
<p>لإنتاج رسم بياني مضغوط وفعّال، تطبق CAGRA عملية تشذيب الحواف ذات القفزة الثنائية.</p>
<p>والفكرة واضحة ومباشرة: إذا كان بإمكان العقدة <em>A</em> الوصول إلى العقدة <em>B</em> بشكل غير مباشر من خلال جار مشترك <em>C</em> (تشكيل مسار A → C → B)، وكانت مسافة هذا المسار غير المباشر مماثلة للمسافة المباشرة بين <em>A</em> <em>وB،</em> فإن الحافة المباشرة A → B تعتبر زائدة عن الحاجة ويمكن إزالتها.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/2_hop_detours_d15eae8702.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p>تتمثل الميزة الرئيسية لاستراتيجية التقليم هذه في أن التحقق من التكرار لكل حافة يعتمد فقط على المعلومات المحلية - المسافات بين نقطتي النهاية وجيرانهما المشتركين. ونظرًا لإمكانية تقييم كل حافة بشكل مستقل، فإن خطوة التقليم قابلة للتوازي بشكل كبير وتتناسب بشكل طبيعي مع تنفيذ دُفعات وحدة معالجة الرسومات.</p>
<p>نتيجةً لذلك، يمكن ل CAGRA تشذيب الرسم البياني بكفاءة على وحدات معالجة الرسومات، مما يقلل من نفقات التخزين بنسبة <strong>40-50%</strong> مع الحفاظ على دقة البحث وتحسين سرعة اجتيازه أثناء تنفيذ الاستعلام.</p>
<h2 id="GPUCAGRA-in-Milvus-What’s-Different" class="common-anchor-header">GPU_CAGRA في Milvus: ما الذي يختلف؟<button data-href="#GPUCAGRA-in-Milvus-What’s-Different" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>بينما توفر وحدات معالجة الرسومات مزايا أداء كبيرة لبناء الرسم البياني، تواجه بيئات الإنتاج تحديًا عمليًا: موارد وحدة معالجة الرسومات أكثر تكلفة بكثير ومحدودة من وحدات المعالجة المركزية. إذا كان كل من بناء الفهرس وتنفيذ الاستعلام يعتمد فقط على وحدات معالجة الرسوم البيانية، تظهر العديد من المشكلات التشغيلية بسرعة:</p>
<ul>
<li><p><strong>انخفاض استخدام الموارد:</strong> غالبًا ما تكون حركة الاستعلام غير منتظمة ومتفجرة، مما يترك وحدات معالجة الرسومات خاملة لفترات طويلة ويهدر سعة الحوسبة المكلفة.</p></li>
<li><p><strong>ارتفاع تكلفة النشر:</strong> يؤدي تخصيص وحدة معالجة الرسومات لكل مثيل يخدم الاستعلام إلى زيادة تكاليف الأجهزة، على الرغم من أن معظم الاستعلامات لا تستخدم أداء وحدة معالجة الرسومات بشكل كامل.</p></li>
<li><p><strong>قابلية التوسع المحدودة:</strong> يحد عدد وحدات معالجة الرسومات المتاحة مباشرةً من عدد النسخ المتماثلة للخدمة التي يمكنك تشغيلها، مما يحد من قدرتك على التوسع حسب الطلب.</p></li>
<li><p><strong>مرونة منخفضة:</strong> عندما يعتمد كل من إنشاء الفهرس والاستعلام على وحدات معالجة الرسومات، يصبح النظام مرتبطاً بتوافر وحدة معالجة الرسومات، ولا يمكن تحويل أعباء العمل بسهولة إلى وحدات المعالجة المركزية.</p></li>
</ul>
<p>لمعالجة هذه القيود، يقدم الإصدار Milvus 2.6.1 وضع نشر مرن لفهرس GPU_CAGRA من خلال المعلمة <code translate="no">adapt_for_cpu</code>. يتيح هذا الوضع سير عمل هجين: تستخدم CAGRA وحدة معالجة الرسوم البيانية لإنشاء فهرس رسم بياني عالي الجودة، بينما يتم تنفيذ الاستعلام على وحدة المعالجة المركزية - باستخدام HNSW كخوارزمية بحث.</p>
<p>في هذا الإعداد، يتم استخدام وحدات معالجة الرسومات حيث تقدم أكبر قيمة - إنشاء فهرس سريع وعالي الدقة - بينما تتعامل وحدات المعالجة المركزية مع أعباء عمل الاستعلامات واسعة النطاق بطريقة أكثر فعالية من حيث التكلفة وقابلة للتطوير.</p>
<p>ونتيجة لذلك، فإن هذا النهج الهجين مناسب بشكل خاص لأحمال العمل حيث:</p>
<ul>
<li><p><strong>تحديثات البيانات غير متكررة،</strong> لذا فإن عمليات إعادة بناء الفهرس نادرة</p></li>
<li><p><strong>حجم الاستعلام مرتفع،</strong> مما يتطلب العديد من النسخ المتماثلة غير المكلفة</p></li>
<li><p><strong>حساسية التكلفة عالية،</strong> ويجب التحكم في استخدام وحدة معالجة الرسومات بإحكام</p></li>
</ul>
<h3 id="Understanding-adaptforcpu" class="common-anchor-header">الفهم <code translate="no">adapt_for_cpu</code></h3><p>في Milvus، تتحكم المعلمة <code translate="no">adapt_for_cpu</code> في كيفية تسلسل فهرس CAGRA إلى القرص أثناء إنشاء الفهرس وكيفية إعادة تسلسله إلى الذاكرة في وقت التحميل. من خلال تغيير هذا الإعداد في وقت الإنشاء ووقت التحميل، يمكن ل Milvus التبديل بمرونة بين بناء الفهرس القائم على وحدة معالجة الرسومات وتنفيذ الاستعلامات القائم على وحدة المعالجة المركزية.</p>
<p>تؤدي المجموعات المختلفة من <code translate="no">adapt_for_cpu</code> في وقت الإنشاء ووقت التحميل إلى أربعة أوضاع تنفيذ، كل منها مصمم لسيناريو تشغيلي محدد.</p>
<table>
<thead>
<tr><th style="text-align:center"><strong>وقت الإنشاء (<code translate="no">adapt_for_cpu</code>)</strong></th><th style="text-align:center"><strong>وقت التحميل (<code translate="no">adapt_for_cpu</code>)</strong></th><th style="text-align:center"><strong>منطق التنفيذ</strong></th><th style="text-align:center"><strong>السيناريو الموصى به</strong></th></tr>
</thead>
<tbody>
<tr><td style="text-align:center"><strong>صحيح</strong></td><td style="text-align:center"><strong>صحيح</strong></td><td style="text-align:center">الإنشاء باستخدام GPU_CAGRA ← التسلسل على هيئة HNSW ← إلغاء التسلسل على هيئة HNSW ← <strong>الاستعلام بوحدة المعالجة المركزية</strong></td><td style="text-align:center">أعباء العمل الحساسة للتكلفة؛ خدمة الاستعلام على نطاق واسع</td></tr>
<tr><td style="text-align:center"><strong>صواب</strong></td><td style="text-align:center"><strong>خطأ</strong></td><td style="text-align:center">الإنشاء باستخدام GPU_CAGRA → التسلسل ك HNSW → إلغاء التسلسل ك HNSW → <strong>الاستعلام بو</strong>حدة <strong>المعالجة المركزية</strong></td><td style="text-align:center">تعود الاستعلامات المتتالية إلى وحدة المعالجة المركزية عند حدوث عدم تطابق في المعلمات</td></tr>
<tr><td style="text-align:center"><strong>خطأ</strong></td><td style="text-align:center"><strong>صحيح</strong></td><td style="text-align:center">الإنشاء باستخدام GPU_CAGRA → التسلسل على هيئة CAGRA → إلغاء التسلسل على هيئة HNSW → <strong>الاستعلام بو</strong>حدة <strong>المعالجة المركزية</strong></td><td style="text-align:center">الاحتفاظ بفهرس CAGRA الأصلي للتخزين مع تمكين البحث المؤقت لوحدة المعالجة المركزية</td></tr>
<tr><td style="text-align:center"><strong>خطأ</strong></td><td style="text-align:center"><strong>خطأ</strong></td><td style="text-align:center">الإنشاء باستخدام GPU_CAGRA → التسلسل على هيئة CAGRA → إلغاء التسلسل على هيئة CAGRA → <strong>الاستعلام بوحدة معالجة الرسومات</strong></td><td style="text-align:center">أعباء العمل ذات الأداء الحرج حيث تكون التكلفة ثانوية</td></tr>
</tbody>
</table>
<p><strong>ملاحظة:</strong> تدعم آلية <code translate="no">adapt_for_cpu</code> التحويل في اتجاه واحد فقط. يمكن تحويل فهرس CAGRA إلى HNSW لأن بنية الرسم البياني CAGRA تحافظ على جميع العلاقات المجاورة التي يحتاجها HNSW. ومع ذلك، لا يمكن تحويل فهرس HNSW مرة أخرى إلى CAGRA، لأنه يفتقر إلى المعلومات الهيكلية الإضافية اللازمة للاستعلام المستند إلى وحدة معالجة الرسومات. ونتيجة لذلك، يجب اختيار إعدادات وقت الإنشاء بعناية، مع مراعاة متطلبات النشر والاستعلام على المدى الطويل.</p>
<h2 id="Putting-GPUCAGRA-to-the-Test" class="common-anchor-header">وضع GPU_CAGRA تحت الاختبار<button data-href="#Putting-GPUCAGRA-to-the-Test" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>لتقييم فعالية نموذج التنفيذ الهجين - باستخدام وحدات معالجة الرسومات لإنشاء الفهرس ووحدات المعالجة المركزية لتنفيذ الاستعلام - أجرينا سلسلة من التجارب الخاضعة للرقابة في بيئة موحدة. يركز التقييم على ثلاثة أبعاد: <strong>أداء بناء الفهرس</strong> <strong>وأداء الاستعلام</strong> <strong>ودقة الاسترجاع</strong>.</p>
<p><strong>الإعداد التجريبي</strong></p>
<p>أُجريت التجارب على أجهزة معتمدة على نطاق واسع ومتوافقة مع معايير الصناعة لضمان بقاء النتائج موثوقة وقابلة للتطبيق على نطاق واسع.</p>
<ul>
<li><p>وحدة المعالجة المركزية: معالج MD EPYC 7R13 (16 وحدة معالجة مركزية)</p></li>
<li><p>وحدة معالجة الرسومات: NVIDIA L4</p></li>
</ul>
<h3 id="1-Index-Build-Performance" class="common-anchor-header">1. أداء بناء الفهرس</h3><p>نحن نقارن CAGRA المبني على وحدة معالجة الرسومات مع HNSW المبني على وحدة المعالجة المركزية، تحت نفس درجة الرسم البياني المستهدفة 64.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/cp1_a177200ab2.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p><strong>النتائج الرئيسية</strong></p>
<ul>
<li><p><strong>تنشئ وحدة معالجة الرسومات CAGRA بوحدة معالجة الرسومات CAGRA فهارس أسرع بمعدل 12-15 مرة من HNSW بوحدة المعالجة المركزية.</strong> على كل من Cohere1M و Gist1M، تتفوق CAGRA القائمة على وحدة معالجة الرسومات على HNSW القائمة على وحدة المعالجة المركزية، مما يسلط الضوء على كفاءة التوازي بين وحدة معالجة الرسومات أثناء بناء الرسم البياني.</p></li>
<li><p><strong>يزداد وقت الإنشاء خطيًا مع تكرارات NN-Descent.</strong> ومع ارتفاع عدد مرات التكرار، يزداد وقت البناء بطريقة شبه خطية، مما يعكس طبيعة التنقيح التكراري ل NN-Descent ويوفر مفاضلة يمكن التنبؤ بها بين تكلفة البناء وجودة الرسم البياني.</p></li>
</ul>
<h3 id="2-Query-performance" class="common-anchor-header">2. أداء الاستعلام</h3><p>في هذه التجربة، يتم بناء الرسم البياني CAGRA مرة واحدة على وحدة معالجة الرسومات، ثم يتم الاستعلام عنه باستخدام مسارين مختلفين للتنفيذ:</p>
<ul>
<li><p><strong>الاستعلام بو</strong>حدة<strong>المعالجة المركزية</strong>: يتم إلغاء تسلسل الفهرس إلى تنسيق HNSW والبحث على وحدة المعالجة المركزية</p></li>
<li><p><strong>الاستعلام</strong> باستخدام وحدة<strong>معالجة الرسومات</strong>: يتم تشغيل البحث مباشرة على الرسم البياني لوحدة معالجة الرسومات باستخدام وحدة معالجة الرسومات</p></li>
</ul>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/cp2_bd00e60553.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p><strong>النتائج الرئيسية</strong></p>
<ul>
<li><p><strong>إنتاجية البحث على وحدة معالجة الرسومات أعلى 5-6 أضعاف من البحث على وحدة المعالجة المركزية.</strong> عبر كل من Cohere1M و Gist1M، يوفر اجتياز وحدة معالجة الرسوم البيانية المستندة إلى وحدة معالجة الرسوم البيانية معدل سرعة أعلى بكثير، مما يسلط الضوء على كفاءة التنقل المتوازي في الرسم البياني على وحدات معالجة الرسوم البيانية.</p></li>
<li><p><strong>يزداد التذكر مع تكرارات NN-Descent، ثم يستقر.</strong> مع زيادة عدد تكرارات الإنشاء، يتحسن التذكر لكل من وحدة المعالجة المركزية ووحدة معالجة الرسومات. ومع ذلك، بعد نقطة معينة، ينتج عن التكرارات الإضافية مكاسب متناقصة، مما يشير إلى أن جودة الرسم البياني قد تقاربت إلى حد كبير.</p></li>
</ul>
<h3 id="3-Recall-accuracy" class="common-anchor-header">3. دقة الاسترجاع</h3><p>في هذه التجربة، يتم الاستعلام عن كل من CAGRA و HNSW على وحدة المعالجة المركزية لمقارنة الاستدعاء في ظل ظروف استعلام متطابقة.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/cp3_1a46a7bdda.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p><strong>النتائج الرئيسية</strong></p>
<p><strong>تحقق CAGRA استرجاعًا أعلى من HNSW على كلتا مجموعتي البيانات،</strong> مما يدل على أنه حتى عندما يتم إنشاء فهرس CAGRA على وحدة معالجة الرسومات ثم يتم إلغاء تسلسله للبحث على وحدة المعالجة المركزية، يتم الحفاظ على جودة الرسم البياني بشكل جيد.</p>
<h2 id="What’s-Next-Scaling-Index-Construction-with-Vamana" class="common-anchor-header">ما التالي: توسيع نطاق بناء الفهرس باستخدام Vamana<button data-href="#What’s-Next-Scaling-Index-Construction-with-Vamana" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>يقدم نهج Milvus الهجين بين وحدة معالجة الرسومات ووحدة المعالجة المركزية (GPU) حلاً عملياً وفعالاً من حيث التكلفة لأعباء عمل البحث المتجه واسعة النطاق اليوم. من خلال إنشاء رسوم بيانية CAGRA عالية الجودة على وحدات معالجة الرسومات وخدمة الاستعلامات على وحدات المعالجة المركزية، فإنه يجمع بين إنشاء الفهرس السريع وتنفيذ الاستعلامات القابلة للتطوير وبأسعار معقولة - وهو<strong>مناسب</strong> بشكل خاص<strong>لأعباء العمل ذات التحديثات غير المتكررة، وأحجام الاستعلامات العالية، وقيود التكلفة الصارمة.</strong></p>
<p>حتى في المقاييس الأكبر - عشرات<strong>أو مئات المليارات من المتجهات -</strong>يصبح بناء<strong>الفهرس</strong>نفسه عنق الزجاجة. عندما لا تتسع مجموعة البيانات الكاملة في ذاكرة وحدة معالجة الرسوم البيانية، تتحول الصناعة عادةً إلى طرق <strong>بناء الرسم البياني القائمة على الإدراج</strong> مثل <strong>Vamana</strong>. فبدلاً من بناء الرسم البياني دفعة واحدة، تعالج Vamana البيانات على دفعات، وتقوم بإدخال متجهات جديدة بشكل تدريجي مع الحفاظ على الاتصال العالمي.</p>
<p>يتبع خط أنابيب البناء ثلاث مراحل رئيسية:</p>
<p><strong>1. نمو الدُفعات الهندسية</strong> - البدء بدفعات صغيرة لتكوين رسم بياني هيكلي، ثم زيادة حجم الدُفعات لزيادة التوازي إلى أقصى حد، وأخيرًا استخدام دفعات كبيرة لتحسين التفاصيل.</p>
<p><strong>2. الإدراج الجشع</strong> - يتم إدراج كل عقدة جديدة عن طريق التنقل من نقطة دخول مركزية، مع تنقيح مجموعة جيرانها بشكل متكرر.</p>
<p><strong>3. تحديثات الحافة العكسية</strong> - إضافة اتصالات عكسية للحفاظ على التماثل وضمان التنقل الفعال في الرسم البياني.</p>
<p>يتم دمج التقليم مباشرةً في عملية البناء باستخدام معيار α-RNG: إذا كان الجار المرشح <em>v</em> مغطى بالفعل من قبل جار موجود <em>p′</em> (أي <em>د(p′، v) &lt; α × د(p، v)</em>)، يتم تقليم <em>v</em>. تسمح المعلمة α بالتحكم الدقيق في التباعد والدقة. يتم تحقيق تسريع وحدة معالجة الرسومات من خلال التوازي داخل الدُفعات وتوسيع نطاق الدُفعات الهندسية، مما يحقق التوازن بين جودة الفهرس والإنتاجية.</p>
<p>تُمكِّن هذه التقنيات معًا الفرق من التعامل مع النمو السريع للبيانات وتحديثات الفهرس على نطاق واسع دون الوقوع في قيود ذاكرة وحدة معالجة الرسومات.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/One_more_thing_b458360e25.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p>يعمل فريق Milvus بنشاط على بناء دعم Vamana، مع إصدار مستهدف في النصف الأول من عام 2026. ترقبوا ذلك.</p>
<p>هل لديك أسئلة أو تريد التعمق في أي ميزة من أحدث إصدار من Milvus؟ انضم إلى<a href="https://discord.com/invite/8uyFbECzPX"> قناة Discord</a> الخاصة بنا أو قم بتسجيل المشكلات على<a href="https://github.com/milvus-io/milvus"> GitHub</a>. يمكنك أيضًا حجز جلسة فردية مدتها 20 دقيقة للحصول على رؤى وإرشادات وإجابات على أسئلتك من خلال<a href="https://milvus.io/blog/join-milvus-office-hours-to-get-support-from-vectordb-experts.md"> ساعات عمل Milvus المكتبية</a>.</p>
<h2 id="Learn-More-about-Milvus-26-Features" class="common-anchor-header">تعرف على المزيد حول ميزات Milvus 2.6<button data-href="#Learn-More-about-Milvus-26-Features" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><ul>
<li><p><a href="https://milvus.io/blog/introduce-milvus-2-6-built-for-scale-designed-to-reduce-costs.md">تقديم ميلفوس 2.6: بحث متجه ميسور التكلفة على نطاق المليار</a></p></li>
<li><p><a href="https://milvus.io/blog/data-in-and-data-out-in-milvus-2-6.md">تقديم وظيفة التضمين: كيف يعمل ملفوس 2.6 على تبسيط عملية البحث في المتجهات والبحث الدلالي</a></p></li>
<li><p><a href="https://milvus.io/blog/json-shredding-in-milvus-faster-json-filtering-with-flexibility.md">تمزيق JSON في ميلفوس: تصفية JSON أسرع ب 88.9 مرة مع المرونة</a></p></li>
<li><p><a href="https://milvus.io/blog/unlocking-true-entity-level-retrieval-new-array-of-structs-and-max-sim-capabilities-in-milvus.md">فتح الاسترجاع الحقيقي على مستوى الكيان: صفيف الهياكل الجديد وإمكانيات MAX_SIM في ميلفوس</a></p></li>
<li><p><a href="https://milvus.io/blog/minhash-lsh-in-milvus-the-secret-weapon-for-fighting-duplicates-in-llm-training-data.md">MinHash LSH في ميلفوس: السلاح السري لمكافحة التكرارات في بيانات تدريب LLM </a></p></li>
<li><p><a href="https://milvus.io/blog/bring-vector-compression-to-the-extreme-how-milvus-serves-3%C3%97-more-queries-with-rabitq.md">الارتقاء بضغط المتجهات إلى أقصى الحدود: كيف يخدم ميلفوس 3 أضعاف الاستعلامات باستخدام RaBitQ</a></p></li>
<li><p><a href="https://milvus.io/blog/benchmarks-lie-vector-dbs-deserve-a-real-test.md">تكذب المعايير - قواعد بيانات المتجهات تستحق اختبارًا حقيقيًا </a></p></li>
<li><p><a href="https://milvus.io/blog/we-replaced-kafka-pulsar-with-a-woodpecker-for-milvus.md">استبدلنا كافكا/بولسار بنقار الخشب في ميلفوس</a></p></li>
</ul>
