---
id: why-ai-agents-like-openclaw-burn-through-tokens-and-how-to-cut-costs.md
title: لماذا يحرق وكلاء الذكاء الاصطناعي مثل OpenClaw الرموز وكيفية خفض التكاليف
author: Min Yin
date: 2026-2-28
cover: assets.zilliz.com/Blog_Open_Claw_Burning_Through_Tokens_1_39b7ee4fdf.jpg
tag: Engineering
recommend: false
publishToMedium: true
tags: 'OpenClaw, Token Optimization, Vector Search, AI Agents, Milvus'
meta_keywords: >-
  OpenClaw token costs, OpenClaw token optimization, reduce OpenClaw API costs,
  hybrid search BM25 vector, AI agent memory, memsearch, Milvus
meta_title: |
  Why AI Agents like OpenClaw Burn Through Tokens and How to Cut Costs
desc: >-
  لماذا ترتفع فواتير الرموز الرمزية لـ OpenClaw ووكلاء الذكاء الاصطناعي الآخرين،
  وكيفية إصلاحها باستخدام استرجاع BM25 + استرجاع المتجهات (Index1 وQMD وMilvus)
  وذاكرة التخفيض أولاً (memsearch).
origin: >-
  https://milvus.io/blog/why-ai-agents-like-openclaw-burn-through-tokens-and-how-to-cut-costs.md
---
<custom-h1>لماذا يحرق وكلاء الذكاء الاصطناعي مثل OpenClaw الرموز وكيفية خفض التكاليف</custom-h1><p>إذا كنت قد قضيت أي وقت مع <a href="https://milvus.io/blog/openclaw-formerly-clawdbot-moltbot-explained-a-complete-guide-to-the-autonomous-ai-agent.md">OpenClaw</a> (المعروف سابقًا باسم Clawdbot وMoltbot)، فأنت تعرف بالفعل مدى جودة وكيل الذكاء الاصطناعي هذا. إنه سريع، ومحلي، ومرن، وقادر على تنفيذ مهام سير عمل معقدة بشكل مدهش عبر Slack، و Discord، وقاعدة التعليمات البرمجية الخاصة بك، وأي شيء آخر تربطه به. ولكن بمجرد أن تبدأ في استخدامه بجدية، يظهر نمط واحد بسرعة: <strong>يبدأ استخدامك للرمز المميز في الارتفاع.</strong></p>
<p>هذا ليس خطأ OpenClaw على وجه التحديد - إنها الطريقة التي يتصرف بها معظم وكلاء الذكاء الاصطناعي اليوم. فهي تقوم بتشغيل مكالمة LLM لكل شيء تقريبًا: البحث عن ملف، أو التخطيط لمهمة، أو كتابة ملاحظة، أو تنفيذ أداة، أو طرح سؤال متابعة. ولأن الرموز هي العملة العالمية لهذه المكالمات، فإن كل إجراء له تكلفة.</p>
<p>لفهم مصدر هذه التكلفة، نحتاج إلى النظر تحت الغطاء إلى مساهمين كبيرين:</p>
<ul>
<li><strong>البحث:</strong> تسحب عمليات البحث سيئة الإنشاء حمولات السياق المترامية الأطراف - ملفات كاملة وسجلات ورسائل ومناطق برمجية لا يحتاجها النموذج بالفعل.</li>
<li><strong>الذاكرة:</strong> يجبر تخزين المعلومات غير المهمة الوكيل على إعادة قراءتها وإعادة معالجتها في المكالمات المستقبلية، مما يضاعف استخدام الرمز المميز بمرور الوقت.</li>
</ul>
<p>كلتا المشكلتين تزيدان بصمت من التكاليف التشغيلية دون تحسين القدرة.</p>
<h2 id="How-AI-Agents-Like-OpenClaw-Actually-Perform-Searches--and-Why-That-Burns-Tokens" class="common-anchor-header">كيف يقوم وكلاء الذكاء الاصطناعي مثل OpenClaw بإجراء عمليات البحث فعلياً - ولماذا يحرق ذلك الرموز<button data-href="#How-AI-Agents-Like-OpenClaw-Actually-Perform-Searches--and-Why-That-Burns-Tokens" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>عندما يحتاج الوكيل إلى معلومات من قاعدة التعليمات البرمجية أو مكتبة المستندات الخاصة بك، فإنه عادةً ما يقوم بما يعادل <strong>Ctrl + F</strong> على مستوى المشروع. يتم إرجاع كل سطر مطابق - غير مرتب وغير مصفى وغير مصنف. يطبّق كلود كود هذا من خلال أداة Grep مخصصة مبنية على ripgrep. لا يحتوي OpenClaw على أداة بحث مدمجة في قاعدة الشيفرات، لكن أداة التنفيذ الخاصة به تتيح للنموذج الأساسي تشغيل أي أمر، ويمكن للمهارات المحملة أن توجه الوكيل لاستخدام أدوات مثل rg. في كلتا الحالتين، يُرجع البحث في قاعدة الشيفرات الكلمات الرئيسية المطابقة للكلمات الرئيسية غير مرتبة وغير مصفاة.</p>
<p>يعمل نهج القوة الغاشمة هذا بشكل جيد في المشاريع الصغيرة. ولكن مع نمو المستودعات، يزداد الثمن. تتراكم المطابقات غير ذات الصلة في نافذة سياق LLM، مما يجبر النموذج على قراءة ومعالجة آلاف الرموز التي لا يحتاجها بالفعل. قد يؤدي بحث واحد غير محدد النطاق إلى سحب ملفات كاملة، أو كتل تعليقات ضخمة، أو سجلات تشترك في كلمة رئيسية ولكن ليس في القصد الأساسي. كرر هذا النمط عبر جلسة تصحيح أخطاء أو بحث طويلة، وسيتراكم هذا الكم الهائل بسرعة.</p>
<p>يحاول كل من OpenClaw و Claude Code إدارة هذا النمو. حيث يعمل OpenClaw على تنقيح مخرجات الأداة كبيرة الحجم وضغط تاريخ المحادثات الطويلة، بينما يحد Claude Code من إخراج الملفات المقروءة ويدعم ضغط السياق. تعمل عمليات التخفيف هذه - ولكن فقط بعد تنفيذ الاستعلام المتضخم بالفعل. لا تزال نتائج البحث غير المصنفة تستهلك الرموز، ولا تزال تدفع ثمنها. تساعد إدارة السياق في المنعطفات المستقبلية، وليس المكالمة الأصلية التي ولَّدت الهدر.</p>
<h2 id="How-AI-Agent-Memory-Works-and-Why-It-Also-Costs-Tokens" class="common-anchor-header">كيف تعمل ذاكرة عميل الذكاء الاصطناعي ولماذا تكلف الرموز أيضًا<button data-href="#How-AI-Agent-Memory-Works-and-Why-It-Also-Costs-Tokens" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>البحث ليس المصدر الوحيد للنفقات الزائدة للرموز. يجب أيضًا تحميل كل جزء من السياق الذي يستدعيه الوكيل من الذاكرة في نافذة سياق LLM، وهذا يكلف الرموز أيضًا.</p>
<p>إن واجهات برمجة تطبيقات LLM التي يعتمد عليها معظم الوكلاء اليوم عديمة الحالة: تتطلب واجهة برمجة تطبيقات الرسائل الخاصة بأنثروبيك تاريخ المحادثة الكامل مع كل طلب، وتعمل واجهة برمجة تطبيقات OpenAI لإكمال الدردشة بنفس الطريقة. حتى واجهة برمجة تطبيقات الردود الأحدث من OpenAI، التي تدير حالة المحادثة من جانب الخادم، لا تزال تطلب نافذة السياق الكامل في كل مكالمة. الذاكرة المحملة في السياق تكلف الرموز المميزة بغض النظر عن كيفية وصولها إلى هناك.</p>
<p>للتغلب على هذا الأمر، تقوم أطر عمل الوكيل بكتابة الملاحظات إلى ملفات على القرص وتحميل الملاحظات ذات الصلة مرة أخرى إلى نافذة السياق عندما يحتاجها الوكيل. على سبيل المثال، يقوم OpenClaw بتخزين الملاحظات المنسقة في MEMORY.md وإلحاق السجلات اليومية بملفات Markdown ذات الطابع الزمني، ثم فهرستها باستخدام BM25 الهجين والبحث المتجه حتى يتمكن الوكيل من استدعاء السياق ذي الصلة عند الطلب.</p>
<p>يعمل تصميم ذاكرة OpenClaw بشكل جيد، لكنه يتطلب نظام OpenClaw البيئي الكامل: عملية البوابة، واتصالات منصة المراسلة، وبقية المكدس. وينطبق الشيء نفسه على ذاكرة Claude Code، والتي ترتبط بـ CLI. إذا كنت تقوم ببناء وكيل مخصص خارج هذه المنصات، فأنت بحاجة إلى حل مستقل. يغطي القسم التالي الأدوات المتاحة لكلا المشكلتين.</p>
<h2 id="How-to-Stop-OpenClaw-From-Burning-Through-Tokens" class="common-anchor-header">كيفية إيقاف OpenClaw من حرق التوكنات<button data-href="#How-to-Stop-OpenClaw-From-Burning-Through-Tokens" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>إذا كنت ترغب في تقليل عدد الرموز التي يستهلكها OpenClaw، فهناك رافعتان يمكنك استخدامهما.</p>
<ul>
<li>الأولى هي <strong>استرجاع أفضل</strong> - استبدال تفريغ الكلمات المفتاحية بنمط grep بأدوات بحث مرتبة تعتمد على الصلة بالموضوع، بحيث لا يرى النموذج سوى المعلومات المهمة بالفعل.</li>
<li>والثاني هو <strong>تحسين الذاكرة</strong> - الانتقال من التخزين المبهم المعتمد على إطار العمل إلى شيء يمكنك فهمه وفحصه والتحكم فيه.</li>
</ul>
<h3 id="Replacing-grep-with-Better-Retrieval-index1-QMD-and-Milvus" class="common-anchor-header">استبدال برنامج grep باسترجاع أفضل: Index1 و QMD و Milvus</h3><p>يبحث العديد من وكلاء الترميز بالذكاء الاصطناعي في قواعد البرمجة باستخدام grep أو ripgrep. لدى Claude Code أداة Grep مخصصة مبنية على ripgrep. لا يحتوي OpenClaw على أداة بحث مدمجة في قاعدة الشيفرات، لكن أداة التنفيذ الخاصة به تتيح للنموذج الأساسي تشغيل أي أمر، ويمكن تحميل مهارات مثل ripgrep أو QMD لتوجيه كيفية بحث الوكيل. بدون مهارة تركز على الاسترجاع، يعود الوكيل إلى أي نهج يختاره النموذج الأساسي. المشكلة الأساسية هي نفسها في جميع الوكلاء: بدون استرجاع مرتب، تدخل مطابقات الكلمات المفتاحية إلى نافذة السياق دون تصفية.</p>
<p>يعمل هذا عندما يكون المشروع صغيرًا بما يكفي بحيث تتناسب كل مطابقة بشكل مريح مع نافذة السياق. تبدأ المشكلة عندما تنمو قاعدة التعليمات البرمجية أو مكتبة المستندات إلى الحد الذي تُظهر فيه الكلمة المفتاحية عشرات أو مئات النتائج ويتعين على الوكيل تحميلها جميعًا في المطالبة. في هذا النطاق، تحتاج إلى نتائج مرتبة حسب الصلة بالموضوع، وليس فقط تصفيتها حسب التطابق.</p>
<p>الحل القياسي هو البحث المختلط، الذي يجمع بين طريقتين متكاملتين للترتيب:</p>
<ul>
<li>يقوم BM25 بتصنيف كل نتيجة حسب عدد مرات ظهور المصطلح في مستند معين ومدى تفرده. فالملف المركّز الذي يذكر كلمة "مصادقة" 15 مرة يحتل مرتبة أعلى من الملف المترامي الأطراف الذي يذكرها مرة واحدة.</li>
<li>يقوم البحث المتجه بتحويل النص إلى تمثيلات رقمية للمعنى، لذلك يمكن أن تتطابق كلمة "مصادقة" مع "تدفق تسجيل الدخول" أو "إدارة الجلسة" حتى عندما لا يشتركان في أي كلمات رئيسية.</li>
</ul>
<p>لا تكفي أي من الطريقتين وحدهما: يفتقد BM25 المصطلحات المعاد صياغتها، ويفتقد البحث المتجه المصطلحات الدقيقة مثل رموز الخطأ. الجمع بين الاثنين ودمج القوائم المرتبة من خلال خوارزمية الدمج يغطي كلا الثغرتين.</p>
<p>تطبق الأدوات أدناه هذا النمط بمقاييس مختلفة. Grep هو خط الأساس الذي يبدأ به الجميع. يضيف كل من index1 وQMD وMilvus بحثًا هجينًا مع زيادة السعة.</p>
<h4 id="index1-fast-hybrid-search-on-a-single-machine" class="common-anchor-header">index1: بحث هجين سريع على جهاز واحد</h4><p>إن<a href="https://github.com/gladego/index1">index1</a> هو أداة CLI تقوم بحزم البحث الهجين في ملف قاعدة بيانات SQLite واحد. يتعامل FTS5 مع BM25، ويتعامل sqlite-vec مع تشابه المتجهات، ويدمج RRF القوائم المرتبة. يتم إنشاء التضمينات محليًا بواسطة Ollama، لذلك لا شيء يغادر جهازك.</p>
<p>يجزئ الفهرس1 الشيفرة حسب البنية، وليس حسب عدد الأسطر: يتم تقسيم ملفات ماركداون حسب العناوين، وملفات بايثون حسب AST، وجافا سكريبت وتايب سكريبت حسب أنماط الرجع. هذا يعني أن نتائج البحث ترجع وحدات متماسكة مثل دالة كاملة أو قسم توثيق كامل، وليس نطاقات أسطر عشوائية تقطع في منتصف الكتلة. يتراوح زمن الاستجابة من 40 إلى 180 مللي ثانية للاستعلامات المختلطة. بدون Ollama، يعود الأمر إلى BM25 فقط، والذي لا يزال يرتب النتائج بدلًا من تفريغ كل تطابق في نافذة السياق.</p>
<p>يتضمن index1 أيضًا وحدة ذاكرة عرضية لتخزين الدروس المستفادة والأسباب الجذرية للأخطاء والقرارات المعمارية. تعيش هذه الذكريات داخل نفس قاعدة بيانات SQLite مثل فهرس التعليمات البرمجية بدلاً من الملفات المستقلة.</p>
<p>ملاحظة: الفهرس 1 هو مشروع في مرحلة مبكرة (0 نجمة، 4 التزامات اعتبارًا من فبراير 2026). قم بتقييمه مقابل قاعدة التعليمات البرمجية الخاصة بك قبل الالتزام به.</p>
<ul>
<li><strong>الأفضل ل</strong>: المطورين المنفردين أو الفرق الصغيرة التي لديها قاعدة شفرات تتناسب مع جهاز واحد، وتبحث عن تحسين سريع مقارنةً ببرنامج grep.</li>
<li><strong>قم بتطويره عندما</strong>: تحتاج إلى وصول متعدد المستخدمين إلى نفس الفهرس، أو<strong>عندما</strong> تتجاوز بياناتك ما يعالجه ملف SQLite واحد بشكل مريح.</li>
</ul>
<h4 id="QMD-higher-accuracy-through-local-LLM-re-ranking" class="common-anchor-header">QMD: دقة أعلى من خلال إعادة ترتيب LLM المحلية</h4><p>تضيف<a href="https://github.com/tobi/qmd">QMD</a> (مستندات ترميز الاستعلام)، التي أنشأها مؤسس Shopify توبي لوتكه، مرحلة ثالثة: إعادة ترتيب LLM. بعد أن يقوم كل من BM25 والبحث المتجه بإرجاع كل من المرشحين للنتائج، يقوم نموذج اللغة المحلي بإعادة قراءة أفضل النتائج وإعادة ترتيبها حسب الصلة الفعلية باستعلامك. هذا يلتقط الحالات التي تُرجع فيها كل من الكلمات المفتاحية والمطابقات الدلالية نتائج معقولة ولكن خاطئة.</p>
<p>يتم تشغيل QMD بالكامل على جهازك باستخدام ثلاثة نماذج GGUF يبلغ مجموعها حوالي 2 غيغابايت: نموذج التضمين (embeddinggemma-300M)، ونموذج إعادة ترتيب عبر برامج إعادة التشفير (Qwen3-Reranker-0.6B)، ونموذج توسيع الاستعلام (qmd-query-expansion-1.7B). يتم تنزيل الثلاثة تلقائيًا عند التشغيل الأول. لا توجد مكالمات واجهة برمجة التطبيقات السحابية، ولا مفاتيح واجهة برمجة التطبيقات.</p>
<p>المفاضلة هي وقت بدء التشغيل البارد: يستغرق تحميل النماذج الثلاثة من القرص ما يقرب من 15 إلى 16 ثانية. يدعم QMD وضع الخادم الدائم (qmd mcp) الذي يحتفظ بالنماذج في الذاكرة بين الطلبات، مما يلغي عقوبة البدء البارد للاستعلامات المتكررة.</p>
<ul>
<li><strong>الأفضل لـ:</strong> البيئات ذات الخصوصية الحرجة حيث لا يمكن أن تغادر أي بيانات جهازك، وحيث تكون دقة الاسترجاع أكثر أهمية من وقت الاستجابة.</li>
<li><strong>قم بتطويره عندما:</strong> تحتاج إلى استجابات في أقل من ثانية، أو عندما تحتاج إلى وصول جماعي مشترك، أو عندما تتجاوز مجموعة بياناتك سعة الجهاز الواحد.</li>
</ul>
<h4 id="Milvus-hybrid-search-at-team-and-enterprise-scale" class="common-anchor-header">ميلفوس: بحث هجين على مستوى الفريق والمؤسسة</h4><p>تعمل أدوات الآلة الواحدة المذكورة أعلاه بشكل جيد للمطورين الأفراد، لكنها تصل إلى حدود عندما يحتاج عدة أشخاص أو وكلاء إلى الوصول إلى نفس القاعدة المعرفية. <a href="https://github.com/milvus-io/milvus"></a></p>
<p><a href="https://github.com/milvus-io/milvus">Milvus</a> هي قاعدة بيانات متجهات مفتوحة المصدر مصممة لهذه المرحلة التالية: موزعة ومتعددة المستخدمين وقادرة على التعامل مع مليارات المتجهات.</p>
<p>الميزة الرئيسية لحالة الاستخدام هذه هي Sparse-BM25 المدمجة في قاعدة البيانات المتشعبة، وهي متوفرة منذ الإصدار 2.5 من Milvus وأسرع بكثير في الإصدار 2.6. أنت تقدم نصًا خامًا، ويقوم ميلفوس بترميزه داخليًا باستخدام محلل مبني على تانتيفي، ثم يحول النتيجة إلى متجهات متفرقة يتم حسابها مسبقًا وتخزينها في وقت الفهرس.</p>
<p>نظرًا لأن تمثيل BM25 مخزّن بالفعل، لا يحتاج الاسترجاع إلى إعادة حساب الدرجات أثناء التنقل. تعيش هذه المتجهات المتفرقة جنبًا إلى جنب مع المتجهات الكثيفة (التضمينات الدلالية) في نفس المجموعة. في وقت الاستعلام، تقوم بدمج كلتا الإشارتين مع مصنف مثل RRFRanker، والذي يوفره Milvus خارج الصندوق. نفس نمط البحث الهجين مثل Index1 وQMD، ولكن تعمل على بنية تحتية تتوسع أفقياً.</p>
<p>يوفر Milvus أيضًا إمكانات لا تستطيع أدوات الآلة الواحدة توفيرها: العزل متعدد المستأجرين (قواعد بيانات أو مجموعات منفصلة لكل فريق)، وتكرار البيانات مع تجاوز الفشل التلقائي، وطبقات البيانات الساخنة/الباردة للتخزين الفعال من حيث التكلفة. بالنسبة للوكلاء، هذا يعني أن العديد من المطورين أو مثيلات الوكلاء المتعددة يمكنهم الاستعلام عن نفس القاعدة المعرفية في نفس الوقت دون التعدي على بيانات بعضهم البعض.</p>
<ul>
<li><strong>الأفضل من أجل</strong>: العديد من المطورين أو الوكلاء الذين يتشاركون قاعدة معرفية، أو مجموعات مستندات كبيرة أو سريعة النمو، أو بيئات الإنتاج التي تحتاج إلى النسخ المتماثل، وتجاوز الفشل، والتحكم في الوصول.</li>
</ul>
<p>خلاصة القول</p>
<table>
<thead>
<tr><th>الأداة</th><th>المرحلة</th><th>النشر</th><th>إشارة الترحيل</th></tr>
</thead>
<tbody>
<tr><td>كلود جريب الأصلي</td><td>النماذج الأولية</td><td>مدمج، بدون إعداد</td><td>ارتفاع الفواتير أو تباطؤ الاستعلامات</td></tr>
<tr><td>فهرس1</td><td>جهاز واحد (سرعة)</td><td>SQLite محلي + أولاما</td><td>تحتاج إلى وصول متعدد المستخدمين أو أن البيانات تتجاوز جهازًا واحدًا</td></tr>
<tr><td>QMD</td><td>جهاز واحد (دقة)</td><td>ثلاثة نماذج GGUF محلية</td><td>تحتاج إلى فهارس مشتركة للفريق</td></tr>
<tr><td>ميلفوس</td><td>فريق أو إنتاج</td><td>مجموعة موزعة</td><td>مجموعات مستندات كبيرة أو متطلبات متعددة المستأجرين</td></tr>
</tbody>
</table>
<h3 id="Reducing-AI-Agent-Token-Costs-by-Giving-Them-Persistent-Editable-Memory-with-memsearch" class="common-anchor-header">تقليل تكاليف الرمز المميز لوكيل الذكاء الاصطناعي من خلال منحهم ذاكرة ثابتة وقابلة للتحرير باستخدام memsearch</h3><p>يقلل تحسين البحث من إهدار الرمز المميز لكل استعلام، ولكنه لا يساعد فيما يحتفظ به الوكيل بين الجلسات.</p>
<p>كل جزء من السياق الذي يستدعيه الوكيل من الذاكرة يجب تحميله في الموجهة، وهذا يكلف الرموز أيضًا. السؤال ليس ما إذا كان يجب تخزين الذاكرة أم لا، بل كيف. تحدد طريقة التخزين ما إذا كان بإمكانك رؤية ما يتذكره الوكيل، وإصلاحه عندما يكون خاطئًا، وأخذه معك إذا قمت بتبديل الأدوات.</p>
<p>تفشل معظم الأطر في جميع هذه الأمور الثلاثة. تخزّن Mem0 وZep كل شيء في قاعدة بيانات متجهة، والتي تعمل على الاسترجاع، ولكنها تجعل الذاكرة</p>
<ul>
<li><strong>مبهمة.</strong> لا يمكنك رؤية ما يتذكره الوكيل دون الاستعلام عن واجهة برمجة التطبيقات.</li>
<li><strong>صعب التعديل.</strong> تصحيح الذاكرة أو إزالتها يعني استدعاء واجهة برمجة التطبيقات، وليس فتح ملف.</li>
<li><strong>مقفل.</strong> تبديل الأطر يعني تصدير بياناتك وتحويلها وإعادة استيرادها.</li>
</ul>
<p>يتخذ OpenClaw نهجًا مختلفًا. كل الذاكرة تعيش في ملفات Markdown عادية على القرص. يكتب الوكيل السجلات اليومية تلقائيًا، ويمكن للبشر فتح أي ملف ذاكرة وتحريره مباشرةً. هذا يحل جميع المشاكل الثلاث: الذاكرة قابلة للقراءة والتحرير والنقل حسب التصميم.</p>
<p>أما المفاضلة فتتمثل في نفقات النشر. إن تشغيل ذاكرة OpenClaw يعني تشغيل نظام OpenClaw البيئي الكامل: عملية البوابة، واتصالات منصة المراسلة، وبقية المكدس. بالنسبة للفرق التي تستخدم OpenClaw بالفعل، لا بأس بذلك. بالنسبة لأي شخص آخر، فإن الحاجز مرتفع للغاية. تم تصميم <strong>memsearch</strong> لسد هذه الفجوة: فهو يستخرج نمط ذاكرة OpenClaw من Markdown-first في مكتبة مستقلة تعمل مع أي وكيل.</p>
<p>يعامل<strong><a href="https://github.com/zilliztech/memsearch">memsearch،</a></strong> الذي أنشأه Zilliz (الفريق الذي يقف وراء Milvus)، ملفات Markdown كمصدر وحيد للحقيقة. يحتفظ MEMORY.md بالحقائق والقرارات طويلة المدى التي تكتبها يدويًا. يتم إنشاء السجلات اليومية (2026-02-26.md) تلقائيًا من ملخصات الجلسات. الفهرس المتجه، المخزن في ميلفوس، هو طبقة مشتقة يمكن إعادة بنائها من Markdown في أي وقت.</p>
<p>من الناحية العملية، هذا يعني أنه يمكنك فتح أي ملف ذاكرة في محرر نصي وقراءة ما يعرفه الوكيل بالضبط وتغييره. احفظ الملف، وسيكتشف مراقب ملفات memsearch التغيير ويعيد الفهرسة تلقائيًا. يمكنك إدارة الذكريات باستخدام Git، ومراجعة الذكريات التي أنشأها الذكاء الاصطناعي من خلال طلبات السحب، أو الانتقال إلى جهاز جديد عن طريق نسخ مجلد. في حالة فقدان فهرس Milvus، يمكنك إعادة بنائه من الملفات. الملفات ليست في خطر أبدًا.</p>
<p>تحت الغطاء، يستخدم memsearch نفس نمط البحث الهجين الموصوف أعلاه: تقسيم الأجزاء حسب بنية العنوان وحدود الفقرات، واسترجاع BM25 + المتجه، وأمر مضغوط يعمل على LLM يلخص الذكريات القديمة عندما تكبر السجلات.  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/Blog_Open_Claw_Burning_Through_Tokens_3_d9df026b47.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p>الأفضل لـ: الفرق التي تريد رؤية كاملة لما يتذكره الوكيل، أو تحتاج إلى التحكم في الإصدار على الذاكرة، أو تريد نظام ذاكرة غير مقيد بأي إطار عمل وكيل واحد.</p>
<p>باختصار</p>
<table>
<thead>
<tr><th>القدرة</th><th>ميم0 / زب</th><th>ميمسارش</th></tr>
</thead>
<tbody>
<tr><td>مصدر الحقيقة</td><td>قاعدة بيانات المتجهات (مصدر البيانات الوحيد)</td><td>ملفات تخفيض السعر (أساسي) + ميلفوس (فهرس)</td></tr>
<tr><td>الشفافية</td><td>صندوق أسود، يتطلب واجهة برمجة التطبيقات للفحص</td><td>فتح أي ملف .md لقراءته</td></tr>
<tr><td>قابلية التعديل</td><td>التعديل عبر مكالمات واجهة برمجة التطبيقات</td><td>التعديل مباشرةً في أي محرر نصي، إعادة الفهرسة التلقائية</td></tr>
<tr><td>التحكم في الإصدار</td><td>يتطلب تسجيل تدقيق منفصل للتدقيق</td><td>يعمل Git بشكل أصلي</td></tr>
<tr><td>تكلفة الترحيل</td><td>التصدير → تحويل التنسيق → إعادة الاستيراد</td><td>نسخ مجلد تخفيض السعر</td></tr>
<tr><td>التعاون بين الإنسان والذكاء الاصطناعي</td><td>الذكاء الاصطناعي يكتب، والبشر يراقبون</td><td>يمكن للبشر التحرير والاستكمال والمراجعة</td></tr>
</tbody>
</table>
<h2 id="Which-setup-fits-your-scale" class="common-anchor-header">أي إعداد يناسب مقياسك<button data-href="#Which-setup-fits-your-scale" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><table>
<thead>
<tr><th>السيناريو</th><th>البحث</th><th>الذاكرة</th><th>متى تنتقل</th></tr>
</thead>
<tbody>
<tr><td>نموذج أولي مبكر</td><td>جريب (مدمج)</td><td>-</td><td>ارتفاع الفواتير أو تباطؤ الاستعلامات</td></tr>
<tr><td>مطور واحد، البحث فقط</td><td><a href="https://github.com/gladego/index1">الفهرس1</a> (السرعة) أو <a href="https://github.com/tobi/qmd">QMD</a> (الدقة)</td><td>-</td><td>الحاجة إلى وصول متعدد المستخدمين أو أن البيانات تتجاوز جهاز واحد</td></tr>
<tr><td>مطور واحد، كلاهما</td><td><a href="https://github.com/gladego/index1">فهرس1</a></td><td><a href="https://github.com/zilliztech/memsearch">ميمسارش</a></td><td>تحتاج إلى وصول متعدد المستخدمين أو أن البيانات تتجاوز جهازًا واحدًا</td></tr>
<tr><td>فريق أو إنتاج، كلاهما</td><td><a href="https://github.com/milvus-io/milvus">ميلفوس</a></td><td><a href="https://github.com/zilliztech/memsearch">ميمسارش</a></td><td>-</td></tr>
<tr><td>تكامل سريع، ذاكرة فقط</td><td>-</td><td>ميم0 أو زب</td><td>الحاجة إلى فحص الذكريات أو تحريرها أو ترحيلها</td></tr>
</tbody>
</table>
<h2 id="Conclusion" class="common-anchor-header">الخلاصة<button data-href="#Conclusion" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>إن التكاليف الرمزية التي تأتي مع وكلاء الذكاء الاصطناعي دائمي التشغيل ليست حتمية. غطى هذا الدليل مجالين حيث يمكن للأدوات الأفضل أن تقلل من الهدر: البحث والذاكرة.</p>
<p>يعمل Grep على نطاق صغير، ولكن مع نمو قواعد الرموز، فإن مطابقات الكلمات المفتاحية غير المصنفة تغمر نافذة السياق بمحتوى لا يحتاجه النموذج أبدًا. <a href="https://github.com/gladego/index1"></a><a href="https://github.com/gladego/index1">فهرس1</a> و <a href="https://github.com/tobi/qmd"></a> QMD يحل هذا الأمر على جهاز واحد من خلال الجمع بين تسجيل الكلمات المفتاحية BM25 مع البحث المتجه وإرجاع النتائج الأكثر صلة فقط. بالنسبة للفرق أو الإعدادات متعددة الوكلاء أو أعباء عمل الإنتاج، يوفر <a href="https://milvus.io"></a><a href="https://milvus.io">Milvus</a> نفس نمط البحث الهجين على البنية التحتية التي تتوسع أفقياً.</p>
<p>بالنسبة للذاكرة، تقوم معظم الأطر بتخزين كل شيء في قاعدة بيانات متجهة: مبهمة ويصعب تحريرها يدويًا ومغلقة على الإطار الذي أنشأها. تعيش الذاكرة في ملفات Markdown عادية يمكنك قراءتها وتحريرها والتحكم في الإصدار باستخدام Git. يعمل ميلفوس كفهرس مشتق يمكن إعادة بنائه من تلك الملفات في أي وقت. تظل متحكمًا فيما يعرفه الوكيل.</p>
<p>كل من <a href="https://github.com/zilliztech/memsearch"></a><a href="https://github.com/zilliztech/memsearch">memsearch</a> و <a href="https://github.com/milvus-io/milvus"></a><a href="https://github.com/milvus-io/milvus">Milvus</a> مفتوح المصدر. نحن نعمل بنشاط على تطوير memsearch ونود الحصول على تعليقات من أي شخص يقوم بتشغيله في الإنتاج. افتح مشكلة، أو أرسل لنا تقرير علاقات عامة، أو أخبرنا فقط ما الذي يعمل وما الذي لا يعمل.</p>
<p>المشاريع المذكورة في هذا الدليل:</p>
<ul>
<li><a href="https://github.com/zilliztech/memsearch">memsearch</a>: ذاكرة التخفيضات الأولى لوكلاء الذكاء الاصطناعي، بدعم من ميلفوس.</li>
<li><a href="https://github.com/milvus-io/milvus">Milvus</a>: قاعدة بيانات متجهة مفتوحة المصدر للبحث الهجين القابل للتطوير.</li>
<li><a href="https://github.com/gladego/index1">Index1</a>: BM25 + البحث الهجين BM25 + المتجه لوكلاء ترميز الذكاء الاصطناعي.</li>
<li><a href="https://github.com/tobi/qmd">QMD</a>: بحث هجين محلي مع إعادة ترتيب LLM.</li>
</ul>
<h2 id="Keep-Reading" class="common-anchor-header">تابع القراءة<button data-href="#Keep-Reading" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><ul>
<li><a href="https://milvus.io/blog/we-extracted-openclaws-memory-system-and-opensourced-it-memsearch.md">استخرجنا نظام الذاكرة الخاص بـ OpenClaw وأطلقنا مصدره (memsearch)</a></li>
<li><a href="https://milvus.io/blog/adding-persistent-memory-to-claude-code-with-the-lightweight-memsearch-plugin.md">الذاكرة الثابتة لكود كلوود: البرنامج المساعد memsearch ccplugin</a></li>
<li><a href="https://milvus.io/blog/openclaw-formerly-clawdbot-moltbot-explained-a-complete-guide-to-the-autonomous-ai-agent.md">ما هو OpenClaw؟ الدليل الكامل لعامل الذكاء الاصطناعي مفتوح المصدر</a></li>
<li><a href="https://milvus.io/blog/stepbystep-guide-to-setting-up-openclaw-previously-clawdbotmoltbot-with-slack.md">البرنامج التعليمي لـ OpenClaw الاتصال بـ Slack لمساعد الذكاء الاصطناعي المحلي</a></li>
</ul>
