{"codeList":["json\n{\n  \"category\": \"functional\",\n  \"description\": \"New chat button creates a fresh conversation\",\n  \"steps\": [\n    \"Navigate to main interface\",\n    \"Click the 'New Chat' button\",\n    \"Verify a new conversation is created\",\n    \"Check that chat area shows welcome state\",\n    \"Verify conversation appears in sidebar\"\n  ],\n  \"passes\": false\n}\n","from sentence_transformers import SentenceTransformer\nfrom pymilvus import MilvusClient\nfrom langgraph.checkpoint.memory import MemorySaver\nfrom langgraph.graph import StateGraph, START, END\nfrom typing import TypedDict, Annotated\nimport operator\nimport subprocess\nimport json\n\n# ==================== Initialization ====================\nembedding_model = SentenceTransformer('all-MiniLM-L6-v2')\nmilvus_client = MilvusClient(\"./milvus_agent_memory.db\")\n\n# Create collection\nif not milvus_client.has_collection(\"agent_history\"):\n    milvus_client.create_collection(\n        collection_name=\"agent_history\",\n        dimension=384,\n        auto_id=True\n    )\n\n# ==================== Milvus Operations ====================\ndef retrieve_context(query: str, top_k: int = 3):\n    \"\"\"Retrieve relevant history from Milvus (core element: semantic retrieval)\"\"\"\n    query_vec = embedding_model.encode(query).tolist()\n    results = milvus_client.search(\n        collection_name=\"agent_history\",\n        data=[query_vec],\n        limit=top_k,\n        output_fields=[\"content\"]\n    )\n    if results and results[0]:\n        return [hit[\"entity\"][\"content\"] for hit in results[0]]\n    return []\n\ndef save_progress(content: str):\n    \"\"\"Save progress to Milvus (long-term memory)\"\"\"\n    embedding = embedding_model.encode(content).tolist()\n    milvus_client.insert(\n        collection_name=\"agent_history\",\n        data=[{\"vector\": embedding, \"content\": content}]\n    )\n\n# ==================== Core Element 1: Git Commit ====================\ndef git_commit(message: str):\n    \"\"\"Git commit (core element from the article)\"\"\"\n    try:\n        # In a real project, actual Git commands would be executed\n        # subprocess.run([\"git\", \"add\", \".\"], check=True)\n        # subprocess.run([\"git\", \"commit\", \"-m\", message], check=True)\n        print(f\"[Git Commit] {message}\")\n        return True\n    except Exception as e:\n        print(f\"[Git Commit Failed] {e}\")\n        return False\n\n# ==================== Core Element 2: Test Verification ====================\ndef run_tests(feature: str):\n    \"\"\"Run tests (end-to-end testing emphasized in the article)\"\"\"\n    try:\n        # In a real project, testing tools like Puppeteer would be called\n        # Simplified to simulated testing here\n        print(f\"[Test Verification] Testing feature: {feature}\")\n        # Simulated test result\n        test_passed = True  # In practice, this would return actual test results\n        if test_passed:\n            print(f\"[Test Passed] {feature}\")\n        return test_passed\n    except Exception as e:\n        print(f\"[Test Failed] {e}\")\n        return False\n\n# ==================== State Definition ====================\nclass AgentState(TypedDict):\n    messages: Annotated[list, operator.add]\n    features: list  # All features list\n    completed_features: list  # Completed features\n    current_feature: str  # Currently processing feature\n    session_count: int  # Session counter\n\n# ==================== Two-Agent Nodes ====================\ndef initialize_node(state: AgentState):\n    \"\"\"Initializer Agent: Generate feature list and set up work environment\"\"\"\n    print(\"\\n========== Initializer Agent Started ==========\")\n    \n    # Generate feature list (in practice, a detailed feature list would be generated based on requirements)\n    features = [\n        \"Implement user registration\",\n        \"Implement user login\",\n        \"Implement password reset\",\n        \"Implement user profile editing\",\n        \"Implement session management\"\n    ]\n    \n    # Save initialization info to Milvus\n    init_summary = f\"Project initialized with {len(features)} features\"\n    save_progress(init_summary)\n    \n    print(f\"[Initialization Complete] Feature list: {features}\")\n    \n    return {\n        **state,\n        \"features\": features,\n        \"completed_features\": [],\n        \"current_feature\": features[0] if features else \"\",\n        \"session_count\": 0,\n        \"messages\": [init_summary]\n    }\n\ndef code_node(state: AgentState):\n    \"\"\"Coding Agent: Implement, test, commit (core loop node)\"\"\"\n    print(f\"\\n========== Coding Agent Session #{state['session_count'] + 1} ==========\")\n    \n    current_feature = state[\"current_feature\"]\n    print(f\"[Current Task] {current_feature}\")\n    \n    # ===== Core Element 3: Retrieve history from Milvus (cross-session memory) =====\n    print(f\"[Retrieving History] Querying experiences related to '{current_feature}'...\")\n    context = retrieve_context(current_feature)\n    if context:\n        print(f\"[Retrieval Results] Found {len(context)} relevant records:\")\n        for i, ctx in enumerate(context, 1):\n            print(f\"  {i}. {ctx[:60]}...\")\n    else:\n        print(\"[Retrieval Results] No relevant history (first time implementing this type of feature)\")\n    \n    # ===== Step 1: Implement feature =====\n    print(f\"[Starting Implementation] {current_feature}\")\n    # In practice, an LLM would be called to generate code\n    implementation_result = f\"Implemented feature: {current_feature}\"\n    \n    # ===== Step 2: Test verification (core element) =====\n    test_passed = run_tests(current_feature)\n    if not test_passed:\n        print(f\"[Session End] Tests did not pass, fixes needed\")\n        return state  # Don't proceed if tests fail\n    \n    # ===== Step 3: Git commit (core element) =====\n    commit_message = f\"feat: {current_feature}\"\n    git_commit(commit_message)\n    \n    # ===== Step 4: Update progress file =====\n    print(f\"[Updating Progress] Marking feature as complete\")\n    \n    # ===== Step 5: Save to Milvus long-term memory =====\n    progress_record = f\"Completed feature: {current_feature} | Commit message: {commit_message} | Test status: passed\"\n    save_progress(progress_record)\n    \n    # ===== Step 6: Update state and prepare for next feature =====\n    new_completed = state[\"completed_features\"] + [current_feature]\n    remaining_features = [f for f in state[\"features\"] if f not in new_completed]\n    \n    print(f\"[Progress] Completed: {len(new_completed)}/{len(state['features'])}\")\n    # ===== Core Element 4: Session end (clear session boundary) =====\n    print(f\"[Session End] Codebase is in clean state, safe to interrupt\\n\")\n    \n    return {\n        **state,\n        \"completed_features\": new_completed,\n        \"current_feature\": remaining_features[0] if remaining_features else \"\",\n        \"session_count\": state[\"session_count\"] + 1,\n        \"messages\": [implementation_result]\n    }\n\n# ==================== Core Element 3: Loop Control ====================\ndef should_continue(state: AgentState):\n    \"\"\"Determine whether to continue to next feature (incremental loop development)\"\"\"\n    if state[\"current_feature\"] and state[\"current_feature\"] != \"\":\n        return \"code\"  # Continue to next feature\n    else:\n        print(\"\\n========== All Features Complete ==========\")\n        return END\n\n# ==================== Build Workflow ====================\nworkflow = StateGraph(AgentState)\n\n# Add nodes\nworkflow.add_node(\"initialize\", initialize_node)\nworkflow.add_node(\"code\", code_node)\n\n# Add edges\nworkflow.add_edge(START, \"initialize\")\nworkflow.add_edge(\"initialize\", \"code\")\n\n# Add conditional edges (implement loop)\nworkflow.add_conditional_edges(\n    \"code\",\n    should_continue,\n    {\n        \"code\": \"code\",  # Continue loop\n        END: END  # End\n    }\n)\n\n# Compile workflow (using MemorySaver as checkpointer)\napp = workflow.compile(checkpointer=MemorySaver())\n\n# ==================== Usage Example: Demonstrating Cross-Session Recovery ====================\nif __name__ == \"__main__\":\n    print(\"=\" * 60)\n    print(\"Demo Scenario: Multi-Session Development for Long-Running Agents\")\n    print(\"=\" * 60)\n    \n    # ===== Session 1: Initialize + complete first 2 features =====\n    print(\"\\n[Scenario 1] First launch: Complete first 2 features\")\n    config = {\"configurable\": {\"thread_id\": \"project_001\"}}\n    \n    result = app.invoke({\n        \"messages\": [],\n        \"features\": [],\n        \"completed_features\": [],\n        \"current_feature\": \"\",\n        \"session_count\": 0\n    }, config)\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"[Simulated Scenario] Developer manually interrupts (Ctrl+C) or context window exhausted\")\n    print(\"=\" * 60)\n    \n    # ===== Session 2: Restore state from checkpoint =====\n    print(\"\\n[Scenario 2] New session starts: Continue from last interruption\")\n    print(\"Using the same thread_id, LangGraph automatically restores from checkpoint...\")\n    \n    # Using the same thread_id, LangGraph will automatically restore state from checkpoint\n    result = app.invoke({\n        \"messages\": [],\n        \"features\": [],\n        \"completed_features\": [],\n        \"current_feature\": \"\",\n        \"session_count\": 0\n    }, config)\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"Demo Complete!\")\n    print(\"=\" * 60)\n    print(\"\\nKey Takeaways:\")\n    print(\"1. ✅ Two-Agent Architecture (initialize + code)\")\n    print(\"2. ✅ Incremental Loop Development (conditional edges control loop)\")\n    print(\"3. ✅ Git Commits (commit after each feature)\")\n    print(\"4. ✅ Test Verification (end-to-end testing)\")\n    print(\"5. ✅ Session Management (clear session boundaries)\")\n    print(\"6. ✅ Cross-Session Recovery (thread_id + checkpoint)\")\n    print(\"7. ✅ Semantic Retrieval (Milvus long-term memory)\")\n  \n\n**The key insight is in the last part.** By using the same `thread_id`, LangGraph automatically restores the checkpoint from the previous session. Session 2 picks up exactly where session 1 stopped — no manual state transfer, no lost progress.\n\n"],"headingContent":"","anchorList":[{"label":"انتشر Clawdbot (الآن OpenClaw) على نطاق واسع","href":"Clawdbot-now-OpenClaw-went-viral","type":2,"isActive":false},{"label":"انتشر Clawdbot لسبب ما","href":"Clawdbot-went-viral-for-a-reason","type":2,"isActive":false},{"label":"تحديان لبناء وكلاء طويل الأمد","href":"Two-challenges-for-building-long-running-agents","type":2,"isActive":false},{"label":"كيف تمنع البنية ثنائية الوكيلين استنفاد السياق","href":"How-the-Two-Agent-Architecture-Prevents-Context-Exhaustion","type":2,"isActive":false},{"label":"كيف يمنح ميلفوس الوكلاء ذاكرة دلالية عبر الجلسات","href":"How-Milvus-Gives-Agents-Semantic-Memory-Across-Sessions","type":2,"isActive":false},{"label":"التحقق من الاكتمال بالاختبار الآلي","href":"Verifying-Completion-with-Automated-Testing","type":2,"isActive":false},{"label":"تجميعها معًا: لانجغراف لحالة الجلسة، وميلفوس للذاكرة طويلة الأجل","href":"Putting-It-Together-LangGraph-for-Session-State-Milvus-for-Long-Term-Memory","type":2,"isActive":false}]}