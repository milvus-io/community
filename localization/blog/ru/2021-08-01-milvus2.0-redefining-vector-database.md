---
id: milvus2.0-redefining-vector-database.md
title: Milvus 2.0 Переосмысление векторной базы данных
author: Xiaofan Luan
date: 2021-08-01T00:00:00.000Z
desc: >-
  Milvus 2.0 уже доступен. Эта рефакторинговая, облачная нативная версия
  обеспечивает поиск изображений/видео, чат-боты и многие другие AI-приложения.
cover: assets.zilliz.com/2_0_cover_bbc582b347.jpg
tag: Engineering
origin: null
---
<custom-h1>Milvus 2.0: Переосмысление векторной базы данных</custom-h1><p>Когда в октябре 2018 года мы написали первую строчку кода для Milvus, это было как будто вчера. В марте 2021 года, после 19 итераций, протестированных 1 000+ пользователями по всему миру, мы запустили Milvus 1.0, наш первый официальный релиз с долгосрочной поддержкой. Будучи самой популярной в мире векторной базой данных с открытым исходным кодом, Milvus 1.0 удалось решить некоторые фундаментальные проблемы в управлении векторами, такие как CRUD-операции и сохранение данных. Однако по мере появления новых сценариев и требований мы начали понимать, что нам предстоит решить еще очень много вопросов. В этой статье мы расскажем о наблюдениях, сделанных нами за последние три года, о проблемах, которые Milvus 2.0 должен решить, и о том, почему Milvus 2.0 считается лучшим решением этих проблем. Чтобы узнать больше о том, что предлагает Milvus 2.0, ознакомьтесь с <a href="https://milvus.io/docs/v2.0.x/release_notes.md">информацией о выпуске Milvus 2.0</a>.</p>
<h2 id="Challenges-Milvus-1x-is-faced-with" class="common-anchor-header">Проблемы, с которыми сталкивается Milvus 1.x<button data-href="#Challenges-Milvus-1x-is-faced-with" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p><strong>Силовое разделение данных:</strong> Milvus 1.0 способен работать только с векторными вкраплениями, полученными из неструктурированных данных, и практически не поддерживает скалярные запросы. Разделение хранилищ данных в его конструкции приводит к дублированию данных и увеличивает сложность разработки приложений, а гибридный поиск между векторными и скалярными данными неудовлетворителен из-за отсутствия единого оптимизатора.</p>
<p><strong>Дилемма между своевременностью и эффективностью:</strong> Milvus 1.0 - это система, работающая практически в реальном времени, которая полагается на регулярный или принудительный флэш для обеспечения видимости данных. Такой подход увеличивает сложность и неопределенность обработки потоковых данных на нескольких уровнях. Кроме того, хотя утверждается, что такой подход к пакетной вставке повышает эффективность обработки, он все равно потребляет много ресурсов. Поэтому необходим подход, основанный на массовой загрузке.</p>
<p><strong>Недостаточная масштабируемость и эластичность:</strong> Milvus 1.0 опирается на Mishards, промежуточное решение для шардинга, для достижения масштабируемости, и сетевое хранилище (NAS) для хранения данных. Эта классическая архитектура, построенная на основе общего хранилища, не вносит большого вклада в общую масштабируемость по следующим причинам:</p>
<ol>
<li>В Mishards поддерживается только один узел записи, который невозможно масштабировать.</li>
<li>Масштабирование узлов чтения в Mishards реализовано с помощью последовательной маршрутизации на основе хэша. Хотя последовательное хэширование легко реализовать и оно помогает решить проблему равномерного распределения данных, оно недостаточно гибко в планировании данных и не позволяет решить проблему несоответствия между размером данных и вычислительной мощностью.</li>
<li>Milvus 1.0 полагается на MySQL для управления метаданными, но объем запросов и наборов данных, с которыми способен справиться отдельный сервер MySQL, довольно ограничен.</li>
</ol>
<p><strong>Отсутствие высокой доступности:</strong> По нашим наблюдениям, большинство пользователей Milvus отдают предпочтение доступности, а не согласованности, однако Milvus 1.x не обладает такими возможностями, как репликация в памяти и аварийное восстановление, и не вполне соответствует требованиям к высокой доступности. Поэтому мы изучаем возможность пожертвовать определенной степенью точности для достижения более высокой доступности.</p>
<p><strong>Непомерно высокие затраты:</strong> Milvus 1.0 полагается на NAS для хранения данных, стоимость которых обычно в десять раз выше, чем локальных или объектных хранилищ. Поскольку векторный поиск в значительной степени зависит от вычислительных ресурсов и памяти, высокая стоимость может стать препятствием для дальнейшей работы с крупными массивами данных или сложными бизнес-сценариями.</p>
<p><strong>Неинтуитивный пользовательский опыт:</strong></p>
<ol>
<li>Сложное распределенное развертывание влечет за собой высокие эксплуатационные расходы.</li>
<li>Хорошо продуманный графический интерфейс пользователя (GUI) недоступен.</li>
<li>Неинтуитивно понятные API стали тормозить разработку приложений.</li>
</ol>
<p>Стоит ли переходить с патча на патч или начинать с нуля - большой вопрос. Чарльз Кси, отец Milvus, считает, что, подобно тому, как многие традиционные автопроизводители не смогли сделать Tesla прогрессивной, Milvus должна стать игроком в области обработки неструктурированных данных и аналитики, чтобы преуспеть. Именно эта убежденность подтолкнула нас к запуску Milvus 2.0, рефакторинговой облачной векторной базы данных.</p>
<h2 id="The-Making-of-Milvus-20" class="common-anchor-header">Создание Milvus 2.0<button data-href="#The-Making-of-Milvus-20" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><h3 id="Design-principles" class="common-anchor-header">Принципы проектирования</h3><p>Milvus 2.0 - наша облачная нативная векторная база данных нового поколения, построенная на следующих трех принципах:</p>
<p><strong>Облако - прежде всего:</strong> Мы считаем, что только архитектуры, поддерживающие разделение хранения и вычислений, могут масштабироваться по требованию и использовать все преимущества эластичности облака. Мы также хотели бы обратить ваше внимание на микросервисный дизайн Milvus 2.0, который предусматривает разделение чтения и записи, разделение инкрементных и исторических данных, а также разделение задач, требующих больших затрат процессора, памяти и ввода-вывода. Микросервисы помогают оптимизировать распределение ресурсов для постоянно меняющейся гетерогенной рабочей нагрузки.</p>
<p><strong>Журналы как данные:</strong> В Milvus 2.0 брокер журналов служит основой системы: Все операции по вставке и обновлению данных должны проходить через брокер журналов, а рабочие узлы выполняют операции CRUD, подписываясь на журналы и потребляя их. Такая конструкция снижает сложность системы за счет переноса основных функций, таких как персистентность данных и флэшбэк, на уровень хранения, а log pub-sub делает систему еще более гибкой и лучше приспособленной для будущего масштабирования.</p>
<p><strong>Унифицированная пакетная и потоковая обработка:</strong> В Milvus 2.0 реализована унифицированная архитектура Lambda, которая объединяет обработку инкрементных и исторических данных. По сравнению с архитектурой Kappa, в Milvus 2.0 реализована функция log backfill, которая сохраняет снимки журналов и индексы в объектном хранилище для повышения эффективности восстановления после сбоев и производительности запросов. Чтобы разбить неограниченные (потоковые) данные на ограниченные окна, Milvus использует новый механизм водяных знаков, который нарезает потоковые данные на несколько пакетов сообщений по времени записи или события и сохраняет временную шкалу для запросов пользователей по времени.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/2_0_image_1_59d7316324.png" alt="2.0 image 1.png" class="doc-image" id="2.0-image-1.png" />
   </span> <span class="img-wrapper"> <span>2.0 изображение 1.png</span> </span></p>
<h3 id="System-architecture" class="common-anchor-header">Архитектура системы</h3><p>Как уже упоминалось выше, дизайн Milvus 2.0 строго следует принципам разделения хранилищ и вычислений, а также плоскости управления и плоскости данных. Система состоит из четырех уровней: уровень доступа, служба координаторов, рабочие узлы и хранилище.</p>
<p><strong>Уровень доступа:</strong> Интерфейс: Уровень доступа - это передний уровень системы и конечная точка для пользователей. Он отвечает за пересылку запросов и сбор результатов.</p>
<p><strong>Служба координаторов:</strong> Служба координаторов распределяет задания между рабочими узлами и выполняет функции "мозга" системы. Существует четыре типа координаторов: корневой координатор (root coord), координатор данных (data coord), координатор запросов (query coord) и координатор индексов (index coord).</p>
<p><strong>Рабочие узлы:</strong> Руки и ноги. Рабочие узлы - это немые исполнители, которые выполняют указания службы координаторов и отвечают на запросы чтения/записи, поступающие с уровня доступа. Существует три типа рабочих узлов: узлы данных, узлы запросов и узлы индексов.</p>
<p><strong>Хранилище:</strong> Кости. Хранилища бывают трех типов: метахранилище, брокер журналов и хранилище объектов.</p>
<ul>
<li>Метахранилище, реализованное в etcd, используется для хранения метаданных, таких как коллекция и контрольная точка для службы координатора.</li>
<li>Лог-брокер, реализованный в Pulsar, используется в основном для хранения инкрементных журналов и реализации надежных асинхронных уведомлений.</li>
<li>Объектное хранилище, реализованное на MinIO или S3, используется в основном для хранения снимков журналов и индексных файлов.</li>
</ul>
<p>Ниже приведена схема системной архитектуры Milvus 2.0: <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/2_0_image_2_2cc7d7fc9c.png" alt="2.0 image 2.png" class="doc-image" id="2.0-image-2.png" /><span>2.0 image 2.png</span> </span></p>
<h3 id="Key-features" class="common-anchor-header">Ключевые особенности</h3><p>Затраты на эксплуатацию базы данных включают в себя не только потребление ресурсов во время выполнения, но и потенциальные затраты на обучение, а также затраты на эксплуатацию и обслуживание. С практической точки зрения, чем удобнее база данных для пользователя, тем больше вероятность того, что она сэкономит эти потенциальные расходы. С самого первого дня существования Milvus простота использования всегда была на первом месте в нашем списке, и последняя версия Milvus 2.0 предлагает довольно много возможностей для снижения таких затрат.</p>
<h4 id="Always-online" class="common-anchor-header">Всегда онлайн</h4><p>Надежность данных и устойчивость сервиса - основные требования к базе данных, и наша стратегия - &quot;отказывать дешево, отказывать мало и отказывать часто&quot;.</p>
<ul>
<li>Под "дешевым отказом" подразумевается разделение систем хранения и вычислений, что делает восстановление после сбоев узлов простым и недорогим.</li>
<li>"Fail small" означает стратегию "разделяй и властвуй", которая упрощает проектирование за счет того, что каждый сервис-координатор обрабатывает лишь небольшую часть данных, предназначенных для чтения/записи/инкрементальных/исторических данных.</li>
<li>"Fail often" означает внедрение хаос-тестирования, которое использует внедрение ошибок в среду тестирования для моделирования таких ситуаций, как аппаратные сбои и сбои зависимостей, и ускоряет обнаружение ошибок.</li>
</ul>
<h4 id="Hybrid-search-between-scalar-and-vector-data" class="common-anchor-header">Гибридный поиск между скалярными и векторными данными</h4><p>Чтобы использовать синергию между структурированными и неструктурированными данными, Milvus 2.0 поддерживает скалярные и векторные данные и обеспечивает гибридный поиск между ними. Гибридный поиск помогает пользователям находить приблизительных ближайших соседей, которые соответствуют критериям фильтра. В настоящее время Milvus поддерживает реляционные операции, такие как EQUAL, GREATER THAN и LESS THAN, и логические операции, такие как NOT, AND, OR и IN.</p>
<h4 id="Tunable-consistency" class="common-anchor-header">Настраиваемая согласованность</h4><p>Будучи распределенной базой данных, подчиняющейся теореме PACELC, Milvus 2.0 приходится искать компромисс между согласованностью, доступностью и задержкой. В большинстве сценариев чрезмерное внимание к согласованности данных в производстве может оказаться излишним, так как разрешение небольшой части данных быть невидимыми мало влияет на общий отзыв, но может значительно повысить производительность запросов. Тем не менее мы считаем, что такие уровни согласованности, как <em>сильная, ограниченная и сессионная</em>, имеют свое уникальное применение. Поэтому Milvus поддерживает настраиваемую согласованность на уровне запросов. Например, при тестировании пользователям может потребоваться <em>сильная</em> согласованность, чтобы гарантировать абсолютную корректность результатов тестирования.</p>
<h4 id="Time-travel" class="common-anchor-header">Путешествие во времени</h4><p>Инженерам по обработке данных часто приходится делать откат данных, чтобы исправить грязные данные и ошибки в коде. Традиционные базы данных обычно реализуют откат данных через моментальные снимки или даже переобучение данных. Это может привести к излишним накладным расходам и затратам на обслуживание. Milvus сохраняет временную шкалу для всех операций вставки и удаления данных, и пользователи могут указать временную метку в запросе, чтобы получить представление данных в определенный момент времени. Благодаря перемещению во времени Milvus также может реализовать легкое резервное копирование или клонирование данных.</p>
<h4 id="ORM-Python-SDK" class="common-anchor-header">ORM Python SDK</h4><p>Объектно-реляционное отображение (ORM) позволяет пользователям сосредоточиться на бизнес-модели верхнего уровня, а не на базовой модели данных, облегчая разработчикам управление отношениями между коллекциями, полями и программами. Чтобы сократить разрыв между доказательством концепции (PoC) алгоритмов ИИ и их внедрением в производство, мы разработали API PyMilvus ORM, которые могут работать со встроенной библиотекой, автономным развертыванием, распределенным кластером или даже облачным сервисом. Благодаря унифицированному набору API мы обеспечиваем пользователям единообразный пользовательский опыт и снижаем затраты на миграцию или адаптацию кода.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/2_0_image_3_55394d6e80.png" alt="2.0 image 3.png" class="doc-image" id="2.0-image-3.png" />
   </span> <span class="img-wrapper"> <span>2.0 изображение 3.png</span> </span></p>
<h4 id="Supporting-tools" class="common-anchor-header">Вспомогательные инструменты</h4><ul>
<li>Milvus Insight - это графический пользовательский интерфейс Milvus, предлагающий такие практические функции, как управление состоянием кластера, управление метаданных и запрос данных. Исходный код Milvus Insight также будет открыт как независимый проект. Мы ищем новых участников для участия в этом проекте.</li>
<li>Опыт работы "из коробки" (OOBE), более быстрое развертывание: Milvus 2.0 можно развернуть с помощью helm или docker-compose.</li>
<li>Milvus 2.0 использует Prometheus, базу данных временных рядов с открытым исходным кодом, для хранения данных о производительности и мониторинге, и Grafana, открытую платформу наблюдаемости, для визуализации метрик.</li>
</ul>
<h2 id="Looking-to-the-future" class="common-anchor-header">Взгляд в будущее<button data-href="#Looking-to-the-future" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Оглядываясь назад, мы считаем, что архитектура системы, основанной на больших данных + применении искусственного интеллекта, слишком сложна. Главным приоритетом сообщества Milvus всегда было сделать Milvus проще в использовании. В дальнейшем проект Milvus будет сосредоточен на следующих направлениях:</p>
<p><strong>БД для ИИ:</strong> помимо базовых функций CRUD, Milvus как система баз данных должна обладать более умным оптимизатором запросов, более мощными возможностями запросов к данным и более полными функциями управления данными. Наша работа на следующем этапе будет сосредоточена на функциях языка манипулирования данными (DML) и типах данных, которые еще не доступны в Milvus 2.0, включая добавление операций удаления и обновления и поддержку строковых типов данных.</p>
<p><strong>ИИ для БД:</strong> ручная настройка таких параметров, как типы индексов, конфигурация системы, пользовательская нагрузка и типы оборудования, усложняет использование Milvus, и ее следует избегать по мере возможности. Мы проанализировали нагрузку на систему и частоту доступа к данным, а в будущем планируем внедрить автонастройку, чтобы снизить затраты на обучение.</p>
<p><strong>Оптимизация затрат:</strong> Самой большой проблемой векторного поиска является необходимость обрабатывать огромные массивы данных за ограниченный промежуток времени. Это требует как больших затрат процессора, так и памяти. Внедрение гетерогенного аппаратного ускорения GPU и FPGA на физическом уровне может значительно снизить нагрузку на CPU. Мы также разрабатываем гибридные алгоритмы индексирования ANN на диске и в памяти для реализации высокопроизводительных запросов к массивным наборам данных с ограниченным объемом памяти. Кроме того, мы оцениваем производительность существующих алгоритмов векторного индексирования с открытым исходным кодом, таких как ScaNN и NGT.</p>
<p><strong>Простота использования:</strong> Milvus постоянно улучшает удобство использования, предоставляя инструменты управления кластером, SDK на разных языках, инструменты развертывания, инструменты эксплуатации и многое другое.</p>
<p>Чтобы узнать больше о планах выпуска Milvus, ознакомьтесь с <a href="https://milvus.io/docs/v2.0.x/roadmap.md">дорожной картой Milvus</a>.</p>
<p>Благодарим всех участников сообщества Milvus, без которых Milvus 2.0 был бы невозможен. Не стесняйтесь <a href="https://github.com/milvus-io/milvus">подавать заявки</a> или <a href="https://github.com/milvus-io/milvus">вносить свой код</a> в сообщество Milvus!</p>
<p><br/></p>
<p><em>Об авторе</em></p>
<p><em>Сяофань Луань сейчас работает в Zilliz в качестве директора по инженерным вопросам, управляя R&amp;D проекта Milvus. Он имеет 7-летний опыт работы, сосредоточенный на создании систем баз данных и хранения данных. После окончания Корнельского университета он последовательно работал в Oracle, HEDVIG и Alibaba Cloud.</em></p>
