---
id: building-a-personalized-product-recommender-system-with-vipshop-and-milvus.md
title: Общая архитектура
author: milvus
date: 2021-07-29T08:46:39.920Z
desc: >-
  Milvus позволяет легко предоставлять пользователям персонализированные
  рекомендации.
cover: assets.zilliz.com/blog_shopping_27fba2c990.jpg
tag: Scenarios
canonicalUrl: >-
  https://zilliz.com/blog/building-a-personalized-product-recommender-system-with-vipshop-and-milvus
---
<custom-h1>Создание персонализированной системы рекомендаций товаров с помощью Vipshop и Milvus</custom-h1><p>С взрывным ростом объема интернет-данных количество товаров и их категории в современных платформах электронной коммерции увеличиваются, с одной стороны, а с другой - возрастает сложность для пользователей в поиске нужных им товаров.</p>
<p><a href="https://www.vip.com/">Vipshop</a> является ведущим онлайн-ритейлером скидок на бренды в Китае. Компания предлагает высококачественные и популярные брендовые товары потребителям по всему Китаю со значительной скидкой от розничных цен. Чтобы оптимизировать процесс покупок для своих клиентов, компания решила создать персонализированную систему поисковых рекомендаций, основанную на ключевых словах запроса и портретах пользователей.</p>
<p>Основная функция системы поисковых рекомендаций для электронной коммерции - извлекать подходящие товары из большого количества продуктов и показывать их пользователям в соответствии с их поисковым намерением и предпочтениями. В этом процессе система должна рассчитать сходство между продуктами и поисковыми намерениями и предпочтениями пользователей и рекомендовать пользователям TopK продуктов с наибольшим сходством.</p>
<p>Такие данные, как информация о продукте, поисковые намерения и предпочтения пользователей, являются неструктурированными данными. Мы попытались рассчитать сходство таких данных с помощью CosineSimilarity(7.x) поисковой системы Elasticsearch (ES), но этот подход имеет следующие недостатки.</p>
<ul>
<li><p>Длительное время отклика на вычисления - средняя задержка при получении результатов TopK из миллионов элементов составляет около 300 мс.</p></li>
<li><p>Высокая стоимость обслуживания индексов ES - один и тот же набор индексов используется как для векторов товарных признаков, так и для других связанных данных, что не облегчает построение индексов, но приводит к появлению огромного количества данных.</p></li>
</ul>
<p>Мы попытались разработать собственный локально чувствительный хэш-плагин для ускорения вычисления CosineSimilarity в ES. Хотя производительность и пропускная способность были значительно улучшены после ускорения, задержка в 100+ мс все еще не соответствовала реальным требованиям онлайн-поиска товаров.</p>
<p>После тщательного исследования мы решили использовать Milvus, векторную базу данных с открытым исходным кодом, которая отличается поддержкой распределенного развертывания, многоязычными SDK, разделением чтения/записи и т. д. по сравнению с обычно используемым автономным Faiss.</p>
<p>Используя различные модели глубокого обучения, мы преобразуем массивные неструктурированные данные в векторы признаков и импортируем эти векторы в Milvus. Благодаря отличной производительности Milvus наша система рекомендаций по поиску в электронной коммерции может эффективно запрашивать TopK векторов, которые похожи на целевые векторы.</p>
<h2 id="Overall-Architecture" class="common-anchor-header">Общая архитектура<button data-href="#Overall-Architecture" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Архитектура](https://assets.zilliz.com/1_01551e7b2b.jpg &quot;Архитектура.&quot;) Как показано на схеме, общая архитектура системы состоит из двух основных частей.</p>
<ul>
<li><p>Процесс записи: векторы признаков элементов (далее - векторы элементов), сгенерированные моделью глубокого обучения, нормализуются и записываются в MySQL. Затем MySQL считывает обработанные векторы признаков предметов с помощью инструмента синхронизации данных (ETL) и импортирует их в векторную базу данных Milvus.</p></li>
<li><p>Процесс чтения: Поисковый сервис получает векторы характеристик предпочтений пользователя (далее - векторы пользователя) на основе ключевых слов запроса пользователя и его портретов, запрашивает похожие векторы в Milvus и выдает векторы TopK элементов.</p></li>
</ul>
<p>Milvus поддерживает как инкрементное обновление данных, так и обновление данных целиком. При каждом инкрементном обновлении необходимо удалить существующий вектор элементов и вставить новый вектор элементов, что означает, что каждая вновь обновленная коллекция будет проиндексирована заново. Это лучше подходит для сценария с большим количеством чтений и меньшим количеством записей. Поэтому мы выбираем метод полного обновления данных. Более того, запись всех данных в несколько разделов занимает всего несколько минут, что эквивалентно обновлению практически в реальном времени.</p>
<p>Узлы записи Milvus выполняют все операции записи, включая создание коллекций данных, построение индексов, вставку векторов и т. д., и предоставляют публичные услуги с доменными именами записи. Узлы чтения Milvus выполняют все операции чтения и предоставляют публичные услуги с доменными именами "только чтение".</p>
<p>В то время как текущая версия Milvus не поддерживает переключение псевдонимов коллекций, мы внедряем Redis для плавного переключения псевдонимов между несколькими целыми коллекциями данных.</p>
<p>Узлу чтения требуется только считывать существующую информацию о метаданных и векторные данные или индексы из MySQL, Milvus и распределенной файловой системы GlusterFS, поэтому возможности чтения могут быть горизонтально расширены за счет развертывания нескольких экземпляров.</p>
<h2 id="Implementation-Details" class="common-anchor-header">Детали реализации<button data-href="#Implementation-Details" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><h3 id="Data-Update" class="common-anchor-header">Обновление данных</h3><p>Сервис обновления данных включает в себя не только запись векторных данных, но и определение объема данных в векторах, построение индексов, предварительную загрузку индексов, управление псевдонимами и т. д. Общий процесс выглядит следующим образом. <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/2_6052b01334.jpg" alt="Process" class="doc-image" id="process" /><span>Процесс</span> </span></p>
<ol>
<li><p>Предположим, что перед построением полных данных CollectionA предоставляет сервис данных для общественности, и все используемые данные направляются в CollectionA (<code translate="no">redis key1 = CollectionA</code>). Целью построения целых данных является создание новой коллекции CollectionB.</p></li>
<li><p>Проверка данных о товарах - проверка номера товара в таблице MySQL, сравнение данных о товарах с существующими данными в CollectionA. Оповещение может быть установлено в соответствии с количеством или процентом. Если заданное количество (процент) не будет достигнуто, все данные не будут построены, и это будет считаться неудачей этой операции построения, вызывая предупреждение; как только заданное количество (процент) будет достигнуто, начнется процесс построения всех данных.</p></li>
<li><p>Начало построения всех данных - инициализация псевдонима всех строящихся данных и обновление Redis. После обновления псевдоним всех собираемых данных направляется в CollectionB (<code translate="no">redis key2 = CollectionB</code>).</p></li>
<li><p>Создание новой целой коллекции - определите, существует ли коллекция CollectionB. Если существует, удалите ее перед созданием новой.</p></li>
<li><p>Пакетная запись данных - вычислите ID раздела для каждого товара с его собственным ID, используя операцию модуло, и запишите данные в несколько разделов во вновь созданную коллекцию пакетно.</p></li>
<li><p>Построение и предварительная загрузка индекса - создание индекса (<code translate="no">createIndex()</code>) для новой коллекции. Файл индекса хранится на сервере распределенного хранения GlusterFS. Система автоматически имитирует запрос к новой коллекции и предварительно загружает индекс для разогрева запроса.</p></li>
<li><p>Проверка данных коллекции - проверка количества элементов данных в новой коллекции, сравнение данных с существующей коллекцией и установка предупреждений на основе количества и процента. Если заданное количество (процент) не достигнуто, коллекция не будет переключена, а процесс создания будет считаться неудачным, что приведет к срабатыванию оповещения.</p></li>
<li><p>Переключение коллекции - управление псевдонимами. После обновления Redis весь используемый псевдоним данных направляется в коллекциюВ (<code translate="no">redis key1 = CollectionB</code>), исходный ключ Redis2 удаляется, и процесс сборки завершается.</p></li>
</ol>
<h3 id="Data-Recall" class="common-anchor-header">Вызов данных</h3><p>Данные раздела Milvus вызываются несколько раз для расчета сходства между векторами пользователя, полученными на основе ключевых слов запроса и портрета пользователя, и вектором элемента, и после объединения возвращаются векторы TopK элементов. Общая схема рабочего процесса выглядит следующим образом: <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/3_93518602b1.jpg" alt="workflow" class="doc-image" id="workflow" /><span>В</span> </span>следующей таблице перечислены основные службы, участвующие в этом процессе. Видно, что средняя задержка для вызова векторов TopK составляет около 30 мс.</p>
<table>
<thead>
<tr><th><strong>Сервис</strong></th><th><strong>Роль</strong></th><th><strong>Входные параметры</strong></th><th><strong>Выходные параметры</strong></th><th><strong>Задержка отклика</strong></th></tr>
</thead>
<tbody>
<tr><td>Получение векторов пользователя</td><td>Получение вектора пользователя</td><td>информация о пользователе + запрос</td><td>вектор пользователя</td><td>10 мс</td></tr>
<tr><td>Milvus Search</td><td>Вычисление сходства векторов и возвращение результатов TopK</td><td>вектор пользователя</td><td>вектор предмета</td><td>10 мс</td></tr>
<tr><td>Логика планирования</td><td>Одновременное извлечение и объединение результатов</td><td>Векторы элементов, отобранных по нескольким каналам, и оценка сходства</td><td>TopK элементов</td><td>10 мс</td></tr>
</tbody>
</table>
<p><strong>Процесс реализации:</strong></p>
<ol>
<li>На основе ключевых слов запроса пользователя и его портрета модель глубокого обучения вычисляет вектор пользователя.</li>
<li>Получение псевдонима коллекции всех используемых данных из Redis currentInUseKeyRef и получение Milvus CollectionName. Этот процесс является сервисом синхронизации данных, т. е. переключения псевдонима в Redis после обновления всех данных.</li>
<li>Milvus вызывается одновременно и асинхронно с пользовательским вектором для получения данных из разных разделов одной коллекции, Milvus вычисляет сходство между пользовательским вектором и вектором элементов и возвращает TopK схожих векторов элементов в каждом разделе.</li>
<li>Векторы TopK элементов, возвращенные из каждого раздела, объединяются и ранжируются в обратном порядке по расстоянию сходства, которое вычисляется с помощью внутреннего произведения IP (чем больше расстояние между векторами, тем больше они похожи). В итоге получаются векторы TopK элементов.</li>
</ol>
<h2 id="Looking-Ahead" class="common-anchor-header">Перспективы<button data-href="#Looking-Ahead" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>В настоящее время векторный поиск на основе Milvus может стабильно использоваться в сценариях поиска рекомендаций, а его высокая производительность дает нам больше возможностей для игры с размерностью модели и выбором алгоритма.</p>
<p>Milvus будет играть важную роль в качестве промежуточного программного обеспечения для большего числа сценариев, включая поиск по отзывам на главном сайте и рекомендации по всем сценариям.</p>
<p>Три наиболее ожидаемые функции Milvus в будущем следующие.</p>
<ul>
<li>Логика переключения псевдонимов коллекций - координация переключения между коллекциями без использования внешних компонентов.</li>
<li>Механизм фильтрации - Milvus v0.11.0 поддерживает механизм фильтрации ES DSL только в автономной версии. Недавно выпущенный Milvus 2.0 поддерживает скалярную фильтрацию и разделение чтения/записи.</li>
<li>Поддержка хранения для Hadoop Distributed File System (HDFS) - Milvus v0.10.6, который мы используем, поддерживает только файловый интерфейс POSIX, и мы развернули GlusterFS с поддержкой FUSE в качестве бэкенда хранения. Однако HDFS является лучшим выбором с точки зрения производительности и простоты масштабирования.</li>
</ul>
<h2 id="Lessons-Learned-and-Best-Practices" class="common-anchor-header">Извлеченные уроки и лучшие практики<button data-href="#Lessons-Learned-and-Best-Practices" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><ol>
<li>Для приложений, в которых основное внимание уделяется операциям чтения, развертывание разделения чтения и записи может значительно увеличить вычислительную мощность и повысить производительность.</li>
<li>В Java-клиенте Milvus отсутствует механизм переподключения, поскольку клиент Milvus, используемый службой отзыва, находится в памяти. Нам приходится создавать собственный пул соединений, чтобы обеспечить доступность соединения между Java-клиентом и сервером с помощью проверки сердцебиения.</li>
<li>На Milvus периодически возникают медленные запросы. Это связано с недостаточным прогревом новой коллекции. При симуляции запроса к новой коллекции индексный файл загружается в память, чтобы добиться прогрева индекса.</li>
<li>nlist - это параметр построения индекса, а nprobe - параметр запроса. Вам необходимо подобрать разумное пороговое значение в соответствии с вашим бизнес-сценарием путем проведения тестовых экспериментов, чтобы сбалансировать производительность и точность поиска.</li>
<li>Для сценария со статическими данными эффективнее сначала импортировать все данные в коллекцию, а затем строить индексы.</li>
</ol>
