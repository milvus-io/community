---
id: we-replaced-kafka-pulsar-with-a-woodpecker-for-milvus.md
title: Мы заменили Kafka/Pulsar на Woodpecker для Milvus - вот что получилось
author: James Luan
date: 2025-05-15T00:00:00.000Z
desc: >-
  Мы создали Woodpecker, облачную нативную систему WAL, чтобы заменить Kafka и
  Pulsar в Milvus для снижения эксплуатационной сложности и стоимости.
cover: >-
  assets.zilliz.com/We_Replaced_Kafka_Pulsar_with_a_Woodpecker_for_Milvus_Here_s_What_Happened_77e8de27a9.png
tag: Engineering
recommend: true
publishToMedium: true
tags: 'Milvus, vector database, vector search, AI Agents, LLM'
meta_keywords: >-
  Replace Kafka, replace Pulsar, messaging queues, Write-Ahead Logging (WAL),
  Milvus vector database
meta_title: |
  We Replaced Kafka/Pulsar with a Woodpecker for Milvus
origin: >-
  https://milvus.io/blog/we-replaced-kafka-pulsar-with-a-woodpecker-for-milvus.md
---
<p><strong>TL;DR:</strong> Мы создали Woodpecker, облачную нативную систему ведения журналов с опережающей записью (WAL), чтобы заменить Kafka и Pulsar в Milvus 2.6. Результат? Упрощение операций, повышение производительности и снижение затрат на нашу векторную базу данных Milvus.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/We_Replaced_Kafka_Pulsar_with_a_Woodpecker_for_Milvus_Here_s_What_Happened_77e8de27a9.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<h2 id="The-Starting-Point-When-Message-Queues-No-Longer-Fit" class="common-anchor-header">Отправная точка: Когда очереди сообщений перестали подходить<button data-href="#The-Starting-Point-When-Message-Queues-No-Longer-Fit" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Мы любили и использовали Kafka и Pulsar. Они работали, пока не перестали. По мере развития Milvus, ведущей векторной базы данных с открытым исходным кодом, мы обнаружили, что эти мощные очереди сообщений больше не отвечают нашим требованиям к масштабируемости. Поэтому мы сделали смелый шаг: мы переписали потоковую основу в Milvus 2.6 и реализовали собственный WAL - <strong>Woodpecker</strong>.</p>
<p>Позвольте мне рассказать вам о нашем путешествии и объяснить, почему мы сделали это изменение, которое на первый взгляд может показаться нелогичным.</p>
<h2 id="Cloud-Native-From-Day-One" class="common-anchor-header">Облачная нативность с первого дня<button data-href="#Cloud-Native-From-Day-One" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>С самого начала Milvus была облачно-нативной векторной базой данных. Мы используем Kubernetes для эластичного масштабирования и быстрого восстановления после сбоев, а также объектные хранилища, такие как Amazon S3 и MinIO, для сохранения данных.</p>
<p>Такой подход, основанный на использовании облачных технологий, дает огромные преимущества, но и создает определенные проблемы:</p>
<ul>
<li><p>Облачные сервисы хранения объектов, такие как S3, обеспечивают практически неограниченные возможности по пропускной способности и доступности, но при этом задержки часто превышают 100 мс.</p></li>
<li><p>Модели ценообразования этих сервисов (основанные на шаблонах и частоте доступа) могут увеличить непредвиденные расходы на операции с базами данных в реальном времени.</p></li>
<li><p>Баланс между характеристиками "облака" и требованиями векторного поиска в реальном времени создает серьезные архитектурные проблемы.</p></li>
</ul>
<h2 id="The-Shared-Log-Architecture-Our-Foundation" class="common-anchor-header">Архитектура Shared Log: Наша основа<button data-href="#The-Shared-Log-Architecture-Our-Foundation" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Многие системы векторного поиска ограничиваются пакетной обработкой данных, поскольку создание потоковой системы в облачной нативной среде сопряжено с еще большими трудностями. В отличие от них, Milvus ставит во главу угла свежесть данных в реальном времени и реализует архитектуру общих журналов - представьте ее как жесткий диск для файловой системы.</p>
<p>Эта архитектура общих журналов обеспечивает критически важную основу, которая отделяет протоколы консенсуса от основной функциональности базы данных. Применяя такой подход, Milvus избавляется от необходимости напрямую управлять сложными протоколами консенсуса, что позволяет нам сосредоточиться на предоставлении исключительных возможностей векторного поиска.</p>
<p>Мы не одиноки в этом архитектурном паттерне - такие базы данных, как AWS Aurora, Azure Socrates и Neon, используют аналогичный дизайн. <strong>Однако в экосистеме с открытым исходным кодом остается существенный пробел: несмотря на очевидные преимущества такого подхода, сообществу не хватает малозамедленной, масштабируемой и экономически эффективной реализации распределенного журнала с опережающей записью (WAL).</strong></p>
<p>Существующие решения, такие как Bookie, оказались неадекватными для наших нужд из-за их тяжеловесного клиентского дизайна и отсутствия готовых к производству SDK для Golang и C++. Этот технологический пробел привел нас к первоначальному подходу с использованием очередей сообщений.</p>
<h2 id="Our-Initial-Solution-Message-Queues-as-WAL" class="common-anchor-header">Наше первоначальное решение: Очереди сообщений как WAL<button data-href="#Our-Initial-Solution-Message-Queues-as-WAL" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Чтобы устранить этот пробел, наш первоначальный подход использовал очереди сообщений (Kafka/Pulsar) в качестве журнала с опережающей записью (WAL). Архитектура работала следующим образом:</p>
<ul>
<li><p>Все входящие обновления в реальном времени проходят через очередь сообщений.</p></li>
<li><p>Авторы получают немедленное подтверждение, как только оно принимается очередью сообщений.</p></li>
<li><p>QueryNode и DataNode обрабатывают эти данные асинхронно, обеспечивая высокую пропускную способность записи при сохранении свежести данных.</p></li>
</ul>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/Figure_Milvus_2_0_Architecture_Overview_465f5ba27a.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p>Рисунок: Обзор архитектуры Milvus 2.0</p>
<p>Эта система эффективно обеспечивала немедленное подтверждение записи и одновременно асинхронную обработку данных, что было очень важно для поддержания баланса между пропускной способностью и свежестью данных, на которые рассчитывают пользователи Milvus.</p>
<h2 id="Why-We-Needed-Something-Different-for-WAL" class="common-anchor-header">Почему нам нужно было что-то другое для WAL<button data-href="#Why-We-Needed-Something-Different-for-WAL" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>В Milvus 2.6 мы решили отказаться от внешних очередей сообщений в пользу Woodpecker, нашей специально разработанной, облачной нативной реализации WAL. Это решение не было легким. В конце концов, мы успешно использовали Kafka и Pulsar в течение многих лет.</p>
<p>Проблема заключалась не в самих этих технологиях - обе они являются отличными системами с мощными возможностями. Проблема заключалась в том, что по мере развития Milvus эти внешние системы становились все более сложными и накладными. По мере того как наши требования становились все более специализированными, разрыв между тем, что предлагали очереди сообщений общего назначения, и тем, что требовалось нашей векторной базе данных, продолжал увеличиваться.</p>
<p>Три специфических фактора в конечном итоге определили наше решение о создании замены:</p>
<h3 id="Operational-Complexity" class="common-anchor-header">Операционная сложность</h3><p>Внешние зависимости, такие как Kafka или Pulsar, требуют выделенных машин с несколькими узлами и тщательного управления ресурсами. Это создает ряд проблем:</p>
<ul>
<li>Повышенная сложность эксплуатации</li>
</ul>
<ul>
<li>Более сложные кривые обучения для системных администраторов</li>
</ul>
<ul>
<li>Повышенный риск ошибок конфигурации и уязвимостей безопасности.</li>
</ul>
<h3 id="Architectural-Constraints" class="common-anchor-header">Архитектурные ограничения</h3><p>Очереди сообщений, такие как Kafka, имеют неотъемлемые ограничения по количеству поддерживаемых тем. Мы разработали VShard в качестве обходного пути для совместного использования тем между компонентами, но это решение, хотя и позволяло эффективно решать задачи масштабирования, вносило значительные архитектурные сложности.</p>
<p>Эти внешние зависимости затрудняли реализацию критически важных функций, таких как сборка мусора в журнале, и увеличивали трудности интеграции с другими модулями системы. Со временем архитектурное несоответствие между очередями сообщений общего назначения и специфическими, высокопроизводительными требованиями векторной базы данных становилось все более очевидным, что заставило нас пересмотреть наши проектные решения.</p>
<h3 id="Resource-Inefficiency" class="common-anchor-header">Неэффективность ресурсов</h3><p>Обеспечение высокой доступности с помощью таких систем, как Kafka и Pulsar, обычно требует:</p>
<ul>
<li><p>распределенного развертывания на нескольких узлах</p></li>
<li><p>Значительное распределение ресурсов даже для небольших рабочих нагрузок</p></li>
<li><p>Хранение эфемерных сигналов (например, Timetick от Milvus), которые на самом деле не требуют длительного хранения.</p></li>
</ul>
<p>Однако этим системам не хватает гибкости, чтобы обойтись без сохранения для таких преходящих сигналов, что приводит к ненужным операциям ввода-вывода и использованию хранилища. Это приводит к непропорциональному перерасходу ресурсов и увеличению затрат - особенно в небольших по масштабу или ограниченных по ресурсам средах.</p>
<h2 id="Introducing-Woodpecker---A-Cloud-Native-High-Performance-WAL-Engine" class="common-anchor-header">Представляем Woodpecker - облачный высокопроизводительный движок WAL<button data-href="#Introducing-Woodpecker---A-Cloud-Native-High-Performance-WAL-Engine" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>В Milvus 2.6 мы заменили Kafka/Pulsar на <strong>Woodpecker</strong>, специально разработанную, нативную для облака систему WAL. Разработанная для объектных хранилищ, Woodpecker упрощает операции, повышая производительность и масштабируемость.</p>
<p>Woodpecker создается с нуля, чтобы максимально использовать потенциал облачных хранилищ. Его цель - стать самым высокопроизводительным WAL-решением, оптимизированным для облачных сред и обеспечивающим основные возможности, необходимые для журнала с записью только через приложение.</p>
<h3 id="The-Zero-Disk-Architecture-for-Woodpecker" class="common-anchor-header">Архитектура нулевого диска для Woodpecker</h3><p>Основная инновация Woodpecker - это <strong>архитектура Zero-Disk</strong>:</p>
<ul>
<li><p>Все данные журнала хранятся в облачном хранилище объектов (например, Amazon S3, Google Cloud Storage или Alibaba OS).</p></li>
<li><p>Метаданные управляются через распределенные хранилища ключевых значений, такие как etcd.</p></li>
<li><p>Отсутствие зависимости от локального диска для основных операций</p></li>
</ul>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/Figure_Woodpecker_Architecture_cc31e15ed9.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p>Рисунок:  Обзор архитектуры Woodpecker</p>
<p>Такой подход значительно снижает операционные накладные расходы, обеспечивая максимальную долговечность и эффективность облака. Устраняя зависимости от локальных дисков, Woodpecker идеально соответствует принципам cloud-native и значительно снижает операционную нагрузку на системных администраторов.</p>
<h3 id="Performance-Benchmarks-Exceeding-Expectations" class="common-anchor-header">Бенчмарки производительности: Превосходство ожиданий</h3><p>Мы провели комплексные бенчмарки, чтобы оценить производительность Woodpecker на одном узле, с одним клиентом и одним лог-потоком. Результаты оказались впечатляющими по сравнению с Kafka и Pulsar:</p>
<table>
<thead>
<tr><th><strong>Система</strong></th><th><strong>Kafka</strong></th><th><strong>Pulsar</strong></th><th><strong>WP MinIO</strong></th><th><strong>WP Local</strong></th><th><strong>WP S3</strong></th></tr>
</thead>
<tbody>
<tr><td>Пропускная способность</td><td>129,96 МБ/с</td><td>107 МБ/с</td><td>71 МБ/с</td><td>450 МБ/с</td><td>750 МБ/с</td></tr>
<tr><td>Задержка</td><td>58 мс</td><td>35 мс</td><td>184 мс</td><td>1,8 мс</td><td>166 мс</td></tr>
</tbody>
</table>
<p>Для удобства мы измерили теоретические пределы пропускной способности различных бэкендов хранилищ на нашей тестовой машине:</p>
<ul>
<li><p><strong>MinIO</strong>: ~110 МБ/с</p></li>
<li><p><strong>Локальная файловая система</strong>: 600-750 МБ/с</p></li>
<li><p><strong>Amazon S3 (один экземпляр EC2)</strong>: до 1,1 ГБ/с.</p></li>
</ul>
<p>Примечательно, что Woodpecker постоянно достигал 60-80% от максимально возможной пропускной способности для каждого бэкенда - исключительный уровень эффективности для промежуточного ПО.</p>
<h4 id="Key-Performance-Insights" class="common-anchor-header">Основные показатели производительности</h4><ol>
<li><p><strong>Режим локальной файловой системы</strong>: Woodpecker достиг скорости 450 МБ/с - 3,5× быстрее, чем Kafka, и 4,2× быстрее, чем Pulsar, - при сверхнизкой задержке всего 1,8 мс, что делает его идеальным для высокопроизводительных одноузловых развертываний.</p></li>
<li><p><strong>Режим облачного хранения (S3)</strong>: При прямой записи в S3 скорость Woodpecker достигла 750 МБ/с (около 68 % от теоретического предела S3), что на 5,8× выше, чем у Kafka, и на 7× выше, чем у Pulsar. Несмотря на более высокую задержку (166 мс), эта установка обеспечивает исключительную пропускную способность для рабочих нагрузок, ориентированных на пакетную обработку.</p></li>
<li><p><strong>Режим хранения объектов (MinIO)</strong>: Даже в режиме MinIO Woodpecker достиг 71 МБ/с - около 65 % от пропускной способности MinIO. Эта производительность сопоставима с Kafka и Pulsar, но при этом требует значительно меньше ресурсов.</p></li>
</ol>
<p>Woodpecker особенно оптимизирован для одновременной записи больших объемов данных, где поддержание порядка имеет решающее значение. И эти результаты отражают только ранние этапы разработки - ожидается, что текущие оптимизации в области объединения ввода-вывода, интеллектуальной буферизации и предварительной выборки позволят еще больше повысить производительность до теоретических пределов.</p>
<h3 id="Design-Goals" class="common-anchor-header">Цели разработки</h3><p>Woodpecker удовлетворяет растущие потребности рабочих нагрузок векторного поиска в реальном времени, выполняя следующие ключевые технические требования:</p>
<ul>
<li><p>Высокопроизводительный ввод данных с длительным сохранением в зонах доступности</p></li>
<li><p>Хвостовые чтения с низкой задержкой для подписки в реальном времени и высокопроизводительные догоняющие чтения для восстановления после сбоев</p></li>
<li><p>Подключаемые бэкэнды хранения, включая облачные объектные хранилища и файловые системы с поддержкой протокола NFS.</p></li>
<li><p>Гибкие варианты развертывания, поддерживающие как легкие автономные системы, так и масштабные кластеры для многопользовательских развертываний Milvus.</p></li>
</ul>
<h3 id="Architecture-Components" class="common-anchor-header">Компоненты архитектуры</h3><p>Стандартное развертывание Woodpecker включает в себя следующие компоненты.</p>
<ul>
<li><p><strong>Клиент</strong> - интерфейсный уровень для отправки запросов на чтение и запись</p></li>
<li><p><strong>LogStore</strong> - управляет высокоскоростной буферизацией записей, асинхронной загрузкой в хранилище и уплотнением журналов.</p></li>
<li><p><strong>Бэкэнд хранилища</strong> - поддерживает масштабируемые и недорогие сервисы хранения, такие как S3, GCS и файловые системы типа EFS.</p></li>
<li><p><strong>ETCD</strong> - хранит метаданные и координирует состояние журналов на распределенных узлах.</p></li>
</ul>
<h3 id="Flexible-Deployments-to-Match-Your-Specific-Needs" class="common-anchor-header">Гибкость развертывания в соответствии с вашими конкретными потребностями</h3><p>Woodpecker предлагает два режима развертывания для удовлетворения ваших конкретных потребностей:</p>
<p><strong>Режим MemoryBuffer - легкий и не требующий обслуживания.</strong></p>
<p>Режим MemoryBuffer Mode обеспечивает простой и легкий вариант развертывания, при котором Woodpecker временно буферизирует входящие записи в памяти и периодически сбрасывает их в облачное хранилище объектов. Управление метаданными осуществляется с помощью etcd для обеспечения согласованности и координации. Этот режим лучше всего подходит для пакетных рабочих нагрузок в небольших развертываниях или производственных средах, для которых простота важнее производительности, особенно если низкая задержка записи не является критичной.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/Figure_The_memory_Buffer_Mode_3429d693a1.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p><em>Рисунок: Режим memoryBuffer</em></p>
<p><strong>Режим QuorumBuffer - оптимизирован для развертывания с низкой задержкой и высокой долговечностью</strong></p>
<p>Режим QuorumBuffer Mode предназначен для чувствительных к задержкам и высокой частоте чтения/записи рабочих нагрузок, требующих как реагирования в реальном времени, так и высокой отказоустойчивости. В этом режиме Woodpecker функционирует как высокоскоростной буфер записи с тремя репликами кворума записи, обеспечивая высокую согласованность и доступность.</p>
<p>Запись считается успешной, как только она реплицируется по крайней мере на два из трех узлов, обычно завершаясь в течение однозначных миллисекунд, после чего данные асинхронно сбрасываются в облачное хранилище объектов для долговременного хранения. Такая архитектура минимизирует состояние узлов, устраняет необходимость в больших локальных дисковых томах и позволяет избежать сложного восстановления против энтропии, которое часто требуется в традиционных системах на основе кворума.</p>
<p>В результате получается оптимизированный и надежный уровень WAL, идеально подходящий для критически важных производственных сред, где важны согласованность, доступность и быстрое восстановление.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/Figure_The_Quorum_Buffer_Mode_72573dc666.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p><em>Рисунок: Режим QuorumBuffer</em></p>
<h2 id="StreamingService-Built-for-Real-Time-Data-Flow" class="common-anchor-header">StreamingService: Создан для работы с потоком данных в реальном времени<button data-href="#StreamingService-Built-for-Real-Time-Data-Flow" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Помимо Woodpecker, в Milvus 2.6 появился <strong>StreamingService -</strong>специализированный компонент, предназначенный для управления журналами, их приема и подписки на потоковые данные.</p>
<p>Чтобы понять, как работает наша новая архитектура, важно прояснить взаимосвязь между этими двумя компонентами:</p>
<ul>
<li><p><strong>Woodpecker</strong> - это уровень хранения, который обеспечивает фактическое сохранение журналов с опережением записи, обеспечивая долговечность и надежность.</p></li>
<li><p><strong>StreamingService</strong> - это сервисный уровень, который управляет операциями с журналами и предоставляет возможности потоковой передачи данных в реальном времени.</p></li>
</ul>
<p>Вместе они образуют полноценную замену внешним очередям сообщений. Woodpecker обеспечивает долговечную основу для хранения данных, а StreamingService предоставляет высокоуровневую функциональность, с которой приложения взаимодействуют напрямую. Такое разделение задач позволяет оптимизировать каждый компонент для выполнения его конкретной роли и в то же время обеспечить бесперебойную работу интегрированной системы.</p>
<h3 id="Adding-Streaming-Service-to-Milvus-26" class="common-anchor-header">Добавление службы стриминга в Milvus 2.6</h3><p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/Figure_Milvus_2_6_Architecture_Overview_238428c58f.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p>Рисунок: Потоковый сервис, добавленный в архитектуру Milvus 2.6</p>
<p>Потоковый сервис состоит из трех основных компонентов:</p>
<p><strong>Координатор потоковой передачи</strong></p>
<ul>
<li><p>Обнаруживает доступные узлы потоковой передачи путем мониторинга сессий Milvus ETCD</p></li>
<li><p>Управляет статусом WALs и собирает метрики балансировки нагрузки через ManagerService</p></li>
</ul>
<p><strong>Клиент потоковой передачи</strong></p>
<ul>
<li><p>Запрашивает службу AssignmentService для определения распределения сегментов WAL между узлами стриминга</p></li>
<li><p>Выполняет операции чтения/записи через службу HandlerService на соответствующем узле потоковой передачи</p></li>
</ul>
<p><strong>Потоковый узел</strong></p>
<ul>
<li><p>Обрабатывает фактические операции WAL и предоставляет возможности публикации-подписки для потоковой передачи данных в реальном времени</p></li>
<li><p>Включает <strong>службу ManagerService</strong> для администрирования WAL и создания отчетов о производительности</p></li>
<li><p>Имеет <strong>службу HandlerService</strong>, которая реализует эффективные механизмы публикации-подписки для записей WAL.</p></li>
</ul>
<p>Такая многоуровневая архитектура позволяет Milvus сохранять четкое разделение между функциональностью потоковой передачи данных (подписка, обработка в реальном времени) и собственно механизмами хранения. Woodpecker управляет "как" хранением журнала, в то время как StreamingService управляет "что" и "когда" операциями с журналом.</p>
<p>В результате служба Streaming Service значительно расширяет возможности Milvus в режиме реального времени, внедряя встроенную поддержку подписки, устраняя необходимость во внешних очередях сообщений. Он снижает потребление памяти за счет консолидации ранее дублировавшихся кэшей в трактах запросов и данных, уменьшает задержки при чтении с высокой степенью согласованности за счет устранения асинхронных задержек синхронизации, а также улучшает масштабируемость и скорость восстановления в рамках всей системы.</p>
<h2 id="Conclusion---Streaming-on-a-Zero-Disk-Architecture" class="common-anchor-header">Заключение - Потоковая передача данных на архитектуре с нулевым диском<button data-href="#Conclusion---Streaming-on-a-Zero-Disk-Architecture" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Управлять состоянием сложно. Системы с состоянием часто жертвуют эластичностью и масштабируемостью. Все более признанным ответом в облачном нативном дизайне является разделение состояния и вычислений, позволяющее каждому из них масштабироваться независимо.</p>
<p>Вместо того чтобы изобретать велосипед, мы делегировали сложность долговечного и масштабируемого хранения данных командам инженеров мирового класса, которые стоят за такими сервисами, как AWS S3, Google Cloud Storage и MinIO. Среди них S3 выделяется практически неограниченной емкостью, одиннадцатью девятками (99,999999999%) долговечности, 99,99% доступности и высокой производительностью чтения/записи.</p>
<p>Но даже у архитектур с "нулевым диском" есть компромиссы. Объектные хранилища по-прежнему сталкиваются с высокой задержкой записи и неэффективностью работы с небольшими файлами - ограничениями, которые остаются нерешенными во многих рабочих нагрузках реального времени.</p>
<p>Для векторных баз данных - особенно для тех, которые поддерживают критически важные задачи RAG, агентов искусственного интеллекта и поисковые нагрузки с низкой задержкой - доступ в режиме реального времени и быстрая запись не являются обязательными условиями. Именно поэтому мы перестроили Milvus на базе Woodpecker и службы потоковой передачи данных. Этот переход упрощает всю систему (давайте посмотрим правде в глаза - никто не хочет поддерживать полный стек Pulsar внутри векторной базы данных), обеспечивает более свежие данные, повышает экономическую эффективность и ускоряет восстановление после сбоев.</p>
<p>Мы считаем, что Woodpecker - это не просто компонент Milvus, он может послужить основой для других облачных нативных систем. По мере развития облачной инфраструктуры такие инновации, как S3 Express, могут еще больше приблизить нас к идеалу: кросс-АЗ долговечность с задержкой записи в одну миллисекунду.</p>
<h2 id="Getting-Started-with-Milvus-26" class="common-anchor-header">Начало работы с Milvus 2.6<button data-href="#Getting-Started-with-Milvus-26" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Milvus 2.6 доступен уже сейчас. Помимо Woodpecker, в ней представлены десятки новых функций и оптимизаций производительности, таких как многоуровневое хранилище, метод квантования RabbitQ, улучшенный полнотекстовый поиск и многопользовательская лицензия, что позволяет напрямую решать самые актуальные проблемы векторного поиска: эффективно масштабироваться и при этом держать расходы под контролем.</p>
<p>Готовы изучить все, что предлагает Milvus? Погрузитесь в наши<a href="https://milvus.io/docs/release_notes.md"> заметки о выпуске</a>, просмотрите<a href="https://milvus.io/docs"> полную документацию</a> или ознакомьтесь с нашими<a href="https://milvus.io/blog"> тематическими блогами</a>.</p>
<p>У вас есть вопросы? Присоединяйтесь к нашему <a href="https://discord.com/invite/8uyFbECzPX">сообществу Discord</a> или задайте вопрос на<a href="https://github.com/milvus-io/milvus"> GitHub</a> - мы готовы помочь вам извлечь максимум пользы из Milvus 2.6.</p>
