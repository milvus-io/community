---
id: >-
  accelerating-compilation-with-dependency-decoupling-and-testing-containerization.md
title: >-
  Ускорение компиляции в 2,5 раза с помощью разделения зависимостей и
  контейнеризации тестирования
author: Zhifeng Zhang
date: 2021-05-28T00:00:00.000Z
desc: >-
  Узнайте, как zilliz сократил время компиляции в 2,5 раза с помощью методов
  разделения зависимостей и контейнеризации для крупномасштабных проектов в
  области искусственного интеллекта и MLOps.
cover: assets.zilliz.com/cover_20e3cddb96.jpeg
tag: Engineering
canonicalUrl: >-
  https://zilliz.com/blog/accelerating-compilation-with-dependency-decoupling-and-testing-containerization
---
<custom-h1>Ускорение компиляции в 2,5 раза с помощью развязывания зависимостей и контейнеризации тестирования</custom-h1><p>Время компиляции может усугубляться сложными внутренними и внешними зависимостями, которые меняются в процессе разработки, а также изменениями в средах компиляции, таких как операционная система или аппаратная архитектура. Ниже перечислены общие проблемы, с которыми можно столкнуться при работе над крупномасштабными проектами в области ИИ или MLOps:</p>
<p><strong>Непомерно долгая компиляция</strong> - Интеграция кода выполняется сотни раз в день. При наличии сотен тысяч строк кода даже небольшое изменение может привести к полной компиляции, которая обычно занимает один или несколько часов.</p>
<p><strong>Сложная среда компиляции</strong> - код проекта должен быть скомпилирован в различных средах, которые включают в себя различные операционные системы, такие как CentOS и Ubuntu, базовые зависимости, такие как GCC, LLVM и CUDA, и аппаратные архитектуры. И компиляция в определенном окружении обычно может не работать в другом окружении.</p>
<p><strong>Сложные зависимости</strong> - компиляция проекта включает более 30 межкомпонентных и сторонних зависимостей. Развитие проекта часто приводит к изменениям в зависимостях, что неизбежно вызывает конфликты зависимостей. Контроль версий между зависимостями настолько сложен, что обновление версии зависимости может легко повлиять на другие компоненты.</p>
<p><strong>Загрузка сторонних зависимостей происходит медленно или со сбоями</strong> - сетевые задержки или нестабильность библиотек сторонних зависимостей приводят к медленной загрузке ресурсов или сбоям в доступе, что серьезно влияет на интеграцию кода.</p>
<p>Развязав зависимости и внедрив контейнеризацию тестирования, нам удалось сократить среднее время компиляции на 60 % во время работы над проектом <a href="https://milvus.io/">Milvus</a> по поиску сходства вкраплений с открытым исходным кодом.</p>
<p><br/></p>
<h3 id="Decouple-the-dependencies-of-the-project" class="common-anchor-header">Разделение зависимостей проекта</h3><p>Компиляция проекта обычно включает в себя большое количество внутренних и внешних зависимостей компонентов. Чем больше зависимостей в проекте, тем сложнее ими управлять. По мере роста программного обеспечения становится все сложнее и дороже изменять или удалять зависимости, а также выявлять их последствия. Регулярное обслуживание необходимо на протяжении всего процесса разработки для обеспечения правильного функционирования зависимостей. Плохое обслуживание, сложные или ошибочные зависимости могут привести к конфликтам, которые замедлят или остановят разработку. На практике это может означать задержку загрузки ресурсов, сбои в доступе, которые негативно влияют на интеграцию кода, и многое другое. Развязывание зависимостей проекта может уменьшить количество дефектов и сократить время компиляции, ускорить тестирование системы и избежать ненужного затягивания разработки программного обеспечения.</p>
<p>Поэтому мы рекомендуем разделить зависимости в вашем проекте:</p>
<ul>
<li>Разделить компоненты со сложными зависимостями</li>
<li>Использовать различные репозитории для управления версиями.</li>
<li>Используйте конфигурационные файлы для управления информацией о версиях, параметрах компиляции, зависимостях и т. д.</li>
<li>Добавьте конфигурационные файлы в библиотеки компонентов, чтобы они обновлялись по мере итераций проекта.</li>
</ul>
<p><strong>Оптимизация компиляции между компонентами</strong> - извлечение и компиляция соответствующего компонента в соответствии с зависимостями и параметрами компиляции, записанными в конфигурационных файлах. Пометьте и упакуйте результаты бинарной компиляции и соответствующие файлы манифеста, а затем загрузите их в свой личный репозиторий. Если компонент или компоненты, от которых он зависит, не изменились, воспроизведите результаты его компиляции в соответствии с файлами манифеста. Для решения таких проблем, как сетевые задержки или нестабильность библиотек зависимостей сторонних разработчиков, попробуйте создать внутренний репозиторий или использовать зеркальные репозитории.</p>
<p>Для оптимизации компиляции между компонентами:</p>
<p>1.Создайте граф зависимостей - используйте файлы конфигурации в библиотеках компонентов для создания графа зависимостей. Используйте граф зависимостей, чтобы получить информацию о версии (Git Branch, Tag и Git commit ID), а также параметры компиляции и многое другое для зависимых компонентов, как выше, так и ниже по течению.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/1_949dffec32.png" alt="1.png" class="doc-image" id="1.png" />
   </span> <span class="img-wrapper"> <span>1.png</span> </span></p>
<p>2<strong>.Проверка наличия зависимостей</strong> - генерируйте предупреждения о круговых зависимостях, конфликтах версий и других проблемах, возникающих между компонентами.</p>
<p>3<strong>.Сглаживание зависимостей</strong> - сортировка зависимостей по принципу Depth First Search (DFS) и фронтальное слияние компонентов с дублирующимися зависимостями для формирования графа зависимостей.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/2_45130c55e4.png" alt="2.png" class="doc-image" id="2.png" />
   </span> <span class="img-wrapper"> <span>2.png</span> </span></p>
<p>4.Использование алгоритма MerkleTree для генерации хэша (Root Hash), содержащего зависимости каждого компонента на основе информации о версии, параметрах компиляции и т. д. В сочетании с такой информацией, как имя компонента, алгоритм формирует уникальный тег для каждого компонента.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/3_6a4fcdf4e3.png" alt="3.png" class="doc-image" id="3.png" />
   </span> <span class="img-wrapper"> <span>3.png</span> </span></p>
<p>5.На основе информации об уникальном теге компонента проверяется, существует ли соответствующий архив компиляции в частном репозитории. Если архив компиляции найден, распакуйте его, чтобы получить файл манифеста для воспроизведения; если нет, скомпилируйте компонент, разметьте сгенерированные файлы объектов компиляции и файл манифеста и загрузите их в приватное хранилище.</p>
<p><br/></p>
<p><strong>Реализация оптимизаций компиляции в компонентах</strong> - выберите инструмент кэширования компиляции для конкретного языка, чтобы кэшировать скомпилированные объектные файлы, загрузить и хранить их в личном репозитории. Для компиляции C/C++ выберите инструмент кэширования компиляции, например CCache, для кэширования промежуточных файлов компиляции C/C++, а затем архивируйте локальный кэш CCache после компиляции. Такие инструменты кэширования компиляции просто кэшируют измененные файлы кода один за другим после компиляции и копируют скомпилированные компоненты неизмененного файла кода, чтобы они могли непосредственно участвовать в окончательной компиляции. Оптимизация компиляции внутри компонентов включает следующие шаги:</p>
<ol>
<li>Добавление необходимых зависимостей компиляции в Dockerfile. Используйте Hadolint для проверки соответствия Dockerfile, чтобы убедиться, что образ соответствует лучшим практикам Docker.</li>
<li>Отзеркальте среду компиляции в соответствии с версией спринта проекта (версия + сборка), операционной системой и другой информацией.</li>
<li>Запустите контейнер с зеркалированной средой компиляции и передайте идентификатор образа контейнеру в качестве переменной окружения. Вот пример команды для получения идентификатора образа: "docker inspect ' - type=image' - format '{{.ID}}' repository/build-env:v0.1-centos7".</li>
<li>Выберите подходящий инструмент кэширования компиляции: Укажите containter для интеграции и компиляции кода и проверьте в личном репозитории, существует ли соответствующий кэш компиляции. Если да, загрузите и распакуйте его в указанный каталог. После компиляции всех компонентов кэш, созданный инструментом компиляции кэша, упаковывается и загружается в ваш личный репозиторий на основе версии проекта и идентификатора образа.</li>
</ol>
<p><br/></p>
<h3 id="Further-compilation-optimization" class="common-anchor-header">Дальнейшая оптимизация компиляции</h3><p>Поскольку наша первоначальная сборка занимает слишком много дискового пространства и пропускной способности сети, а ее развертывание занимает много времени, мы приняли следующие меры:</p>
<ol>
<li>Выбрать наиболее компактный базовый образ для уменьшения размера изображения, например alpine, busybox и т. д.</li>
<li>Сократить количество слоев изображения. Использовать зависимости как можно чаще. Объединяйте несколько команд с помощью "&amp;&amp;".</li>
<li>Очищайте промежуточные продукты при построении изображения.</li>
<li>Как можно чаще используйте кэш изображений для построения образа.</li>
</ol>
<p>По мере развития нашего проекта использование диска и сетевых ресурсов стало расти по мере увеличения кэша компиляции, а некоторые кэши компиляции использовались недостаточно. Тогда мы внесли следующие изменения:</p>
<p><strong>Регулярная очистка файлов кэша</strong> - Регулярно проверяйте частный репозиторий (например, с помощью скриптов) и очищайте файлы кэша, которые давно не менялись или редко загружались.</p>
<p><strong>Выборочное кэширование компиляций</strong> - кэшируйте только требовательные к ресурсам компиляции и пропускайте кэширование компиляций, которые не требуют много ресурсов.</p>
<p><br/></p>
<h3 id="Leveraging-containerized-testing-to-reduce-errors-improve-stability-and-reliability" class="common-anchor-header">Использование контейнерного тестирования для уменьшения количества ошибок, повышения стабильности и надежности</h3><p>Коды приходится компилировать в разных средах, которые включают в себя различные операционные системы (например, CentOS и Ubuntu), базовые зависимости (например, GCC, LLVM и CUDA) и специфические аппаратные архитектуры. Код, который успешно компилируется в определенном окружении, не работает в другом окружении. Запуск тестов внутри контейнеров позволяет ускорить процесс тестирования и повысить его точность.</p>
<p>Контейнеризация гарантирует, что тестовое окружение единообразно и что приложение работает так, как ожидается. При контейнерном тестировании тесты упаковываются в контейнеры-образы и создается по-настоящему изолированная тестовая среда. Наши тестировщики обнаружили, что такой подход весьма полезен, и в итоге время компиляции сократилось на 60 %.</p>
<p><strong>Обеспечение согласованной среды компиляции</strong> - поскольку скомпилированные продукты чувствительны к изменениям в системном окружении, в разных операционных системах могут возникать неизвестные ошибки. Мы должны помечать и архивировать кэш скомпилированных продуктов в соответствии с изменениями в среде компиляции, но их сложно классифицировать. Поэтому мы внедрили технологию контейнеризации для унификации среды компиляции, чтобы решить эти проблемы.</p>
<p><br/></p>
<h3 id="Conclusion" class="common-anchor-header">Заключение</h3><p>Проанализировав зависимости проекта, в этой статье были представлены различные методы оптимизации компиляции между компонентами и внутри них, а также идеи и лучшие практики для построения стабильной и эффективной непрерывной интеграции кода. Эти методы помогли решить проблему медленной интеграции кода, вызванной сложными зависимостями, унифицировать операции внутри контейнера для обеспечения согласованности среды, а также повысить эффективность компиляции за счет воспроизведения результатов компиляции и использования инструментов кэширования компиляции для кэширования промежуточных результатов компиляции.</p>
<p>Вышеупомянутые практики позволили сократить время компиляции проекта в среднем на 60 %, значительно повысив общую эффективность интеграции кода. В дальнейшем мы будем продолжать распараллеливать компиляцию между компонентами и внутри них, чтобы еще больше сократить время компиляции.</p>
<p><br/></p>
<p><em>Для написания этой статьи были использованы следующие источники:</em></p>
<ul>
<li>"Разделение деревьев исходных текстов на компоненты уровня сборки"</li>
<li>"<a href="https://dev.to/brpaz/factors-to-consider-when-adding-third-party-dependencies-to-a-project-46hf">Факторы, которые следует учитывать при добавлении сторонних зависимостей в проект</a>"</li>
<li>"<a href="https://queue.acm.org/detail.cfm?id=3344149">Выживание зависимостей в программном обеспечении</a>"</li>
<li>"<a href="https://www.cc.gatech.edu/~beki/t1.pdf">Понимание зависимостей: Исследование проблем координации при разработке программного обеспечения</a>"</li>
</ul>
<p><br/></p>
<h3 id="About-the-author" class="common-anchor-header">Об авторе</h3><p>Чжифэн Чжан - старший DevOps-инженер в Zilliz.com, работающий над Milvus, векторной базой данных с открытым исходным кодом, и авторизованный инструктор университета открытого программного обеспечения LF в Китае. Он получил степень бакалавра в области Интернета вещей (IOT) в Институте программной инженерии в Гуанчжоу. В своей карьере участвует и руководит проектами в области CI/CD, DevOps, управления ИТ-инфраструктурой, Cloud-Native toolkit, контейнеризации и оптимизации процессов компиляции.</p>
