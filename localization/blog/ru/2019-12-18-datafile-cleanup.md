---
id: 2019-12-18-datafile-cleanup.md
title: Предыдущая стратегия удаления и связанные с ней проблемы
author: Yihua Mo
date: 2019-12-18T00:00:00.000Z
desc: >-
  Мы улучшили стратегию удаления файлов, чтобы устранить проблемы, связанные с
  операциями запроса.
cover: null
tag: Engineering
---
<custom-h1>Усовершенствования механизма очистки файлов данных</custom-h1><blockquote>
<p>Автор: Yihua Mo</p>
<p>Дата: 2019-12-18</p>
</blockquote>
<h2 id="Previous-delete-strategy-and-related-problems" class="common-anchor-header">Предыдущая стратегия удаления и связанные с ней проблемы<button data-href="#Previous-delete-strategy-and-related-problems" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>В статье <a href="/blog/ru/2019-11-08-data-management.md">"Управление данными в векторной поисковой системе Massive-Scale</a>" мы упоминали механизм удаления файлов данных. Удаление включает в себя мягкое удаление и жесткое удаление. После выполнения операции удаления таблицы она помечается как soft-delete. После этого операции поиска или обновления больше не допускаются. Однако операция запроса, начатая до удаления, все еще может выполняться. Таблица действительно удаляется вместе с метаданными и другими файлами только после завершения операции запроса.</p>
<p>Когда же файлы, помеченные как soft-delete, действительно удаляются? До версии 0.6.0 стратегия заключалась в том, что файл действительно удалялся после мягкого удаления в течение 5 минут. На следующем рисунке показана эта стратегия:</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://raw.githubusercontent.com/milvus-io/community/master/blog/assets/datafile_clean/5mins.png" alt="5mins" class="doc-image" id="5mins" />
   </span> <span class="img-wrapper"> <span>5mins</span> </span></p>
<p>Эта стратегия основана на предположении, что запросы обычно не длятся более 5 минут, и не является надежной. Если запрос длится более 5 минут, он не будет выполнен. Причина в том, что при запуске запроса Milvus собирает информацию о файлах, в которых может быть произведен поиск, и создает задания запроса. Затем планировщик запросов загружает файлы в память по одному и ищет их по очереди. Если при загрузке файла его больше не существует, запрос завершится неудачей.</p>
<p>Увеличение времени может помочь снизить риск сбоев запросов, но при этом возникает другая проблема: слишком большое использование диска. Причина в том, что при вставке большого количества векторов Milvus постоянно объединяет файлы данных, и объединенные файлы не сразу удаляются с диска, даже если запроса не происходит. Если вставка данных происходит слишком быстро и/или объем вставленных данных слишком велик, дополнительное использование диска может достигать десятков гигабайт. В качестве примера см. следующий рисунок:</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://raw.githubusercontent.com/milvus-io/community/master/blog/assets/datafile_clean/5min_result.png" alt="result" class="doc-image" id="result" />
   </span> <span class="img-wrapper"> <span>результат</span> </span></p>
<p>Как показано на предыдущем рисунке, первая порция вставленных данных (insert_1) стирается на диск и становится файлом_1, затем insert_2 становится файлом_2. Поток, отвечающий за объединение файлов, объединяет их в файл_3. Затем файл_1 и файл_2 помечаются как soft-delete. Третья порция данных для вставки становится файлом_4. Поток объединяет файлы file_3 и file_4 в file_5 и помечает file_3 и file_4 как soft-delete.</p>
<p>Аналогичным образом объединяются insert_6 и insert_5. В t3 файл_5 и файл_6 помечаются как soft-delete. Между t3 и t4, хотя многие файлы помечены как soft-delete, они все еще находятся на диске. После t4 файлы действительно удаляются. Таким образом, между t3 и t4 использование диска составляет 64 + 64 + 128 + 64 + 196 + 64 + 256 = 836 МБ. Вставленные данные составляют 64 + 64 + 64 + 64 + 64 = 256 МБ. Объем используемого диска в 3 раза больше объема вставленных данных. Чем выше скорость записи на диск, тем выше использование диска в определенный период времени.</p>
<h2 id="Improvements-of-the-delete-strategy-in-060" class="common-anchor-header">Улучшения стратегии удаления в версии 0.6.0<button data-href="#Improvements-of-the-delete-strategy-in-060" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Итак, в версии 0.6.0 мы изменили стратегию удаления файлов. Hard-delete больше не использует время в качестве триггера. Вместо этого триггером является момент, когда файл не используется ни одной задачей.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://raw.githubusercontent.com/milvus-io/community/master/blog/assets/datafile_clean/new_strategy.png" alt="newstrategy" class="doc-image" id="newstrategy" />
   </span> <span class="img-wrapper"> <span>новая стратегия</span> </span></p>
<p>Предположим, что вставляются две партии векторов. В момент t1 поступает запрос, Milvus получает два файла для запроса (file_1 и file_2, поскольку file_3 еще не существует). Затем поток бэкенда начинает объединять эти два файла с одновременным выполнением запроса. Когда файл_3 будет создан, файл_1 и файл_2 помечаются как soft-delete. После выполнения запроса никакие другие задачи не будут использовать файл_1 и файл_2, поэтому они будут жестко удалены в t4. Интервал между t2 и t4 очень мал и зависит от интервала запроса. Таким образом, неиспользуемые файлы будут удалены вовремя.</p>
<p>Что касается внутренней реализации, то для определения того, может ли файл быть жестко удален, используется подсчет ссылок, хорошо знакомый инженерам-программистам. Для пояснения можно использовать сравнение: когда у игрока есть жизни в игре, он все еще может играть. Когда количество жизней становится равным 0, игра заканчивается. Milvus следит за состоянием каждого файла. Когда файл используется задачей, к нему добавляется жизнь. Когда файл больше не используется, жизнь из него удаляется. Когда файл помечен как soft-delete и количество жизней равно 0, файл готов к hard-delete.</p>
<h2 id="Related-blogs" class="common-anchor-header">Похожие блоги<button data-href="#Related-blogs" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><ul>
<li><a href="/blog/ru/2019-11-08-data-management.md">Управление данными в векторной поисковой системе большого масштаба</a></li>
<li><a href="https://milvus.io/blog/managing-metadata-in-milvus-1.md">Управление метаданными в Milvus (1): Как просматривать метаданные</a></li>
<li><a href="/blog/ru/2019-12-27-meta-table.md">Управление метаданными Milvus (2): Поля в таблице метаданных</a></li>
</ul>
