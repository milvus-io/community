---
id: reflections-on-chatgpt-and-claude-memory-systems.md
title: >-
  Размышления о ChatGPT и системах памяти Клода: Что нужно для обеспечения
  возможности извлечения информации из разговора по требованию
author: Min Yin
date: 2026-01-09T00:00:00.000Z
cover: assets.zilliz.com/Chat_GPT_VS_Claude_cover_555fdac36d.png
tag: Engineering
recommend: false
publishToMedium: true
tags: 'Milvus, vector database'
meta_keywords: 'ChatGPT, Claude, memory systems, on-demand retrieval, conversational retrieval'
meta_title: |
  Milvus 2.6 Makes Claude-Style On-Demand Retrieval Practical
desc: >-
  Узнайте, как ChatGPT и Claude по-разному проектируют память, почему сложно
  восстановить разговорную информацию по требованию и как Milvus 2.6 позволяет
  это сделать в производственных масштабах.
origin: 'https://milvus.io/blog/reflections-on-chatgpt-and-claude-memory-systems.md'
---
<p>В высококачественных системах агентов ИИ проектирование памяти гораздо сложнее, чем кажется на первый взгляд. По своей сути она должна отвечать на три фундаментальных вопроса: Как должна храниться история разговоров? Когда следует извлекать прошлый контекст? И что именно следует извлекать?</p>
<p>Эти решения напрямую определяют задержку реакции агента, использование ресурсов и, в конечном счете, его предел возможностей.</p>
<p>Такие модели, как ChatGPT и Claude, становятся все более "памятливыми", чем больше мы их используем. Они запоминают предпочтения, адаптируются к долгосрочным целям и поддерживают преемственность между сессиями. В этом смысле они уже функционируют как мини-агенты ИИ. Однако под поверхностью их системы памяти построены на совершенно разных архитектурных предпосылках.</p>
<p>Недавний анализ <a href="https://manthanguptaa.in/posts/claude_memory/">механизмов памяти</a> <a href="https://manthanguptaa.in/posts/chatgpt_memory/">ChatGPT</a>и <a href="https://manthanguptaa.in/posts/claude_memory/">Claude</a> с помощью реверс-инжиниринга выявил явный контраст. <strong>ChatGPT</strong> полагается на предварительно вычисленный контекст и многоуровневое кэширование для обеспечения легкой и предсказуемой непрерывности. <strong>Claude,</strong> напротив, использует RAG-стиль, поиск по требованию с динамическим обновлением памяти, чтобы сбалансировать глубину памяти и эффективность.</p>
<p>Эти два подхода - не просто предпочтения дизайнеров, они определяются возможностями инфраструктуры. В <a href="https://milvus.io/docs/release_notes.md#v268"><strong>Milvus 2.6</strong></a> реализована комбинация гибридного плотного и разреженного поиска, эффективной скалярной фильтрации и многоуровневого хранения, которая необходима разговорной памяти по требованию, что делает выборочный поиск достаточно быстрым и экономичным для внедрения в реальные системы.</p>
<p>В этом посте мы расскажем о том, как на самом деле работают системы памяти ChatGPT и Claude, почему они разошлись в архитектуре и как последние достижения в таких системах, как Milvus, делают разговорный поиск по требованию практичным в масштабе.</p>
<h2 id="ChatGPT’s-Memory-System" class="common-anchor-header">Система памяти ChatGPT<button data-href="#ChatGPT’s-Memory-System" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Вместо того чтобы запрашивать векторную базу данных или динамически извлекать прошлые разговоры во время вывода, ChatGPT строит свою "память", собирая фиксированный набор контекстных компонентов и вставляя их непосредственно в каждую подсказку. Каждый компонент готовится заранее и занимает известную позицию в подсказке.</p>
<p>Такая конструкция позволяет сохранить персонализацию и непрерывность разговора, делая при этом более предсказуемыми задержки, использование маркеров и поведение системы. Другими словами, память - это не то, что модель ищет на лету, а то, что система упаковывает и передает модели каждый раз, когда она генерирует ответ.</p>
<p>На высоком уровне полный запрос ChatGPT состоит из следующих уровней, расположенных в порядке от самого глобального к самому непосредственному:</p>
<p>[0] Инструкции системы</p>
<p>[1] Инструкции разработчика</p>
<p>[2] Метаданные сессии (эфемерные)</p>
<p>[3] Память пользователя (долгосрочные факты)</p>
<p>[4] Recent Conversations Summary (прошлые чаты, названия + фрагменты)</p>
<p>[5] Сообщения текущей сессии (этот чат)</p>
<p>[6] Ваше последнее сообщение</p>
<p>Компоненты с [2] по [5] образуют эффективную память системы, каждый из которых выполняет свою роль.</p>
<h3 id="Session-Metadata" class="common-anchor-header">Метаданные сеанса</h3><p>Метаданные сессии представляют собой недолговечную, непостоянную информацию, которая вводится один раз в начале разговора и отбрасывается по окончании сессии. Ее роль заключается в том, чтобы помочь модели адаптироваться к текущему контексту использования, а не персонализировать поведение в долгосрочной перспективе.</p>
<p>Этот слой собирает сигналы о ближайшем окружении пользователя и недавних паттернах использования. Типичные сигналы включают:</p>
<ul>
<li><p><strong>Информация об устройстве</strong> - например, является ли пользователь мобильным или настольным компьютером.</p></li>
<li><p><strong>Атрибуты аккаунта</strong> - например, уровень подписки (например, ChatGPT Go), возраст аккаунта и общая частота использования.</p></li>
<li><p><strong>Поведенческие метрики</strong> - в том числе активные дни за последние 1, 7 и 30 дней, средняя длина разговора и распределение использования модели (например, 49 % запросов обрабатываются GPT-5).</p></li>
</ul>
<h3 id="User-Memory" class="common-anchor-header">Память пользователя</h3><p>Память пользователя - это постоянный, редактируемый слой памяти, который обеспечивает персонализацию во время разговоров. В ней хранится относительно стабильная информация - например, имя пользователя, его роль или карьерные цели, текущие проекты, прошлые результаты и предпочтения в обучении - и она вносится в каждый новый разговор, чтобы сохранить преемственность во времени.</p>
<p>Эта память может обновляться двумя способами:</p>
<ul>
<li><p><strong>Явные обновления</strong> происходят, когда пользователи напрямую управляют памятью с помощью инструкций типа "запомнить это" или "удалить это из памяти".</p></li>
<li><p><strong>Неявные обновления</strong> происходят, когда система определяет информацию, соответствующую критериям хранения OpenAI - например, подтвержденное имя или должность - и сохраняет ее автоматически, с учетом согласия пользователя и настроек памяти по умолчанию.</p></li>
</ul>
<h3 id="Recent-Conversation-Summary" class="common-anchor-header">Сводка последних разговоров</h3><p>Сводка последних бесед - это легкий межсессионный контекстный слой, который сохраняет непрерывность без повторного воспроизведения или извлечения полной истории чата. Вместо того чтобы полагаться на динамическое извлечение, как в традиционных подходах на основе RAG, эта сводка предварительно вычисляется и вводится непосредственно в каждый новый разговор.</p>
<p>Этот слой обобщает только сообщения пользователя, исключая ответы помощника. Он намеренно ограничен по размеру - обычно около 15 записей - и сохраняет только высокоуровневые сигналы о недавних интересах, а не подробное содержание. Поскольку он не опирается на вкрапления или поиск сходства, он сохраняет низкую задержку и потребление токенов.</p>
<h3 id="Current-Session-Messages" class="common-anchor-header">Сообщения текущей сессии</h3><p>Сообщения текущей сессии содержат полную историю сообщений текущего разговора и обеспечивают краткосрочный контекст, необходимый для последовательных, пошаговых ответов. Этот слой включает в себя как сообщения пользователя, так и ответы ассистента, но только пока сессия остается активной.</p>
<p>Поскольку модель работает в рамках фиксированного лимита токенов, эта история не может расти бесконечно. Когда лимит достигнут, система удаляет самые ранние сообщения, чтобы освободить место для более новых. Такое усечение затрагивает только текущую сессию: долгосрочная память пользователя и сводка последних бесед остаются нетронутыми.</p>
<h2 id="Claude’s-Memory-System" class="common-anchor-header">Система памяти в Claude<button data-href="#Claude’s-Memory-System" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>В Claude используется другой подход к управлению памятью. Вместо того чтобы внедрять большой, фиксированный набор компонентов памяти в каждую подсказку, как это делает ChatGPT, Клод сочетает постоянную память пользователя с инструментами по требованию и выборочным извлечением. Исторический контекст извлекается только тогда, когда модель считает его релевантным, что позволяет системе найти компромисс между глубиной контекста и вычислительными затратами.</p>
<p>Контекст подсказок в Claude структурирован следующим образом:</p>
<p>[0] Системная подсказка (статические инструкции)</p>
<p>[1] Воспоминания пользователя</p>
<p>[2] История разговора</p>
<p>[3] Текущее сообщение</p>
<p>Основные различия между Claude и ChatGPT заключаются в <strong>том, как извлекается история разговоров</strong> и <strong>как обновляется и поддерживается память пользователя</strong>.</p>
<h3 id="User-Memories" class="common-anchor-header">Память пользователя</h3><p>В Claude пользовательские воспоминания образуют долгосрочный контекстный слой, аналогичный по назначению пользовательской памяти ChatGPT, но с большим акцентом на автоматическое, фоновое обновление. Эти воспоминания хранятся в структурированном формате (обернутом в теги в стиле XML) и предназначены для постепенного развития с течением времени при минимальном вмешательстве пользователя.</p>
<p>Claude поддерживает два пути обновления:</p>
<ul>
<li><p><strong>Неявные обновления</strong> - система периодически анализирует содержание беседы и обновляет память в фоновом режиме. Эти обновления не применяются в реальном времени, а воспоминания, связанные с удаленными беседами, постепенно обрезаются в рамках текущей оптимизации.</p></li>
<li><p><strong>Явное обновление</strong> - пользователи могут напрямую управлять памятью с помощью таких команд, как "запомнить это" или "удалить это", которые выполняются с помощью специального инструмента <code translate="no">memory_user_edits</code>.</p></li>
</ul>
<p>По сравнению с ChatGPT, Claude возлагает большую ответственность на саму систему за уточнение, обновление и отсечение долговременной памяти. Это снижает потребность пользователей в активном контроле за сохранением информации.</p>
<h3 id="Conversation-History" class="common-anchor-header">История разговоров</h3><p>Для истории разговора Claude не полагается на фиксированное резюме, которое вводится в каждую подсказку. Вместо этого он извлекает прошлый контекст только тогда, когда модель решает, что это необходимо, используя три разных механизма. Это позволяет избежать переноса неактуальной истории и держать под контролем использование токенов.</p>
<table>
<thead>
<tr><th style="text-align:center"><strong>Компонент</strong></th><th style="text-align:center"><strong>Назначение</strong></th><th style="text-align:center"><strong>Как используется</strong></th></tr>
</thead>
<tbody>
<tr><td style="text-align:center"><strong>Скользящее окно (текущий разговор)</strong></td><td style="text-align:center">Хранит полную историю сообщений текущего разговора (не сводку), аналогично контексту сессии в ChatGPT.</td><td style="text-align:center">Инжектируется автоматически. Лимит токенов ~190K; старые сообщения удаляются по достижении лимита</td></tr>
<tr><td style="text-align:center"><code translate="no">conversation_search</code> <strong>инструмент</strong></td><td style="text-align:center">Поиск прошлых бесед по теме или ключевому слову, возвращает ссылки на беседы, заголовки и выдержки из сообщений пользователя/ассистента</td><td style="text-align:center">Срабатывает, когда модель определяет, что необходимы исторические подробности. Параметры включают <code translate="no">query</code> (условия поиска) и <code translate="no">max_results</code> (1-10).</td></tr>
<tr><td style="text-align:center"><code translate="no">recent_chats</code> <strong>инструмент</strong></td><td style="text-align:center">Извлекает недавние разговоры в указанном диапазоне времени (например, "за последние 3 дня"), результаты оформляются так же, как и <code translate="no">conversation_search</code></td><td style="text-align:center">Срабатывает, когда недавний, скопированный по времени контекст является релевантным. Параметры включают <code translate="no">n</code> (количество результатов), <code translate="no">sort_order</code>, и временной диапазон.</td></tr>
</tbody>
</table>
<p>Среди этих компонентов особенно примечателен <code translate="no">conversation_search</code>. Он может выводить релевантные результаты даже для нечетко сформулированных или многоязычных запросов, что указывает на то, что он работает на семантическом уровне, а не полагается на простое соответствие ключевым словам. Вероятно, это связано с поиском на основе встраивания или гибридным подходом, который сначала переводит или нормализует запрос в каноническую форму, а затем применяет поиск по ключевым словам или гибридный поиск.</p>
<p>В целом подход Клода к поиску по требованию имеет несколько заметных достоинств:</p>
<ul>
<li><p><strong>Поиск не является автоматическим</strong>: Вызовы инструментов инициируются собственными суждениями модели. Например, когда пользователь обращается к <em>"проекту, который мы обсуждали в прошлый раз",</em> Клод может решить вызвать <code translate="no">conversation_search</code>, чтобы получить соответствующий контекст.</p></li>
<li><p><strong>Более богатый контекст при необходимости</strong>: Полученные результаты могут включать <strong>выдержки из ответов помощника</strong>, в то время как резюме ChatGPT отражают только сообщения пользователя. Это делает Claude более подходящим для случаев, когда требуется более глубокий или точный контекст разговора.</p></li>
<li><p><strong>Более высокая эффективность по умолчанию</strong>: Поскольку исторический контекст не вводится без необходимости, система избегает переноса большого количества нерелевантной истории, сокращая ненужное потребление токенов.</p></li>
</ul>
<p>Компромиссы также очевидны. Внедрение поиска по требованию увеличивает сложность системы: необходимо создавать и поддерживать индексы, выполнять запросы, ранжировать результаты, а иногда и переранжировать их. Конечная задержка также становится менее предсказуемой, чем при использовании предварительно вычисленного, всегда вводимого контекста. Кроме того, модель должна научиться решать, когда поиск необходим. Если это решение окажется неверным, релевантный контекст может вообще не быть получен.</p>
<h2 id="The-Constraints-Behind-Claude-Style-On-Demand-Retrieval" class="common-anchor-header">Ограничения, лежащие в основе поиска по требованию в стиле Клода<button data-href="#The-Constraints-Behind-Claude-Style-On-Demand-Retrieval" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Принятие модели поиска по требованию делает векторную базу данных критически важной частью архитектуры. Поиск по разговору предъявляет необычайно высокие требования как к хранению, так и к выполнению запросов, и система должна одновременно удовлетворять четырем ограничениям.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/constraints_b6ed74e454.jpg" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<h3 id="1-Low-Latency-Tolerance" class="common-anchor-header">1. Низкая латентность</h3><p>В разговорных системах задержка P99 обычно не должна превышать ~20 мс. Задержки, превышающие это значение, сразу же становятся заметными для пользователей. Это не оставляет места для неэффективности: векторный поиск, фильтрация метаданных и ранжирование результатов должны быть тщательно оптимизированы. Узкое место в любой точке может ухудшить весь разговорный опыт.</p>
<h3 id="2-Hybrid-Search-Requirement" class="common-anchor-header">2. Требования к гибридному поиску</h3><p>Запросы пользователей часто охватывают множество измерений. Запрос типа <em>"обсуждения RAG за последнюю неделю"</em> сочетает в себе семантическую релевантность и фильтрацию по времени. Если база данных поддерживает только векторный поиск, она может вернуть 1000 семантически схожих результатов, а фильтрация на прикладном уровне сократит их до нескольких, что приведет к потере большей части вычислений. Чтобы быть практичной, база данных должна изначально поддерживать комбинированные векторные и скалярные запросы.</p>
<h3 id="3-Storage–Compute-Separation" class="common-anchor-header">3. Разделение хранения и вычислений</h3><p>История разговоров демонстрирует четкую модель доступа "горячий-холодный". Недавние разговоры запрашиваются часто, в то время как к старым разговорам обращаются редко. Если бы все векторы хранились в памяти, то для хранения десятков миллионов разговоров потребовались бы сотни гигабайт оперативной памяти - нецелесообразная для масштаба стоимость. Чтобы быть жизнеспособной, система должна поддерживать разделение хранения и вычислений, сохраняя горячие данные в памяти, а холодные - в объектном хранилище, с загрузкой векторов по требованию.</p>
<h3 id="4-Diverse-Query-Patterns" class="common-anchor-header">4. Различные шаблоны запросов</h3><p>Поиск информации в разговоре не подчиняется единому шаблону доступа. Некоторые запросы являются чисто семантическими (например, <em>"оптимизация производительности, которую мы обсуждали")</em>, другие - чисто временными (<em>"все разговоры за прошлую неделю")</em>, а многие сочетают в себе несколько ограничений (<em>"связанные с Python обсуждения, упоминающие FastAPI, за последние три месяца")</em>. Планировщик запросов к базе данных должен адаптировать стратегии выполнения к различным типам запросов, а не полагаться на универсальный поиск методом грубой силы.</p>
<p>Вместе эти четыре задачи определяют основные ограничения разговорного поиска. Любая система, стремящаяся реализовать поиск по требованию в стиле Клода, должна решать все эти проблемы согласованно.</p>
<h2 id="Why-Milvus-26-Works-Well-for-Conversational-Retrieval" class="common-anchor-header">Почему Milvus 2.6 хорошо работает для разговорного поиска<button data-href="#Why-Milvus-26-Works-Well-for-Conversational-Retrieval" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Выбор дизайна в <a href="https://milvus.io/docs/release_notes.md#v268">Milvus 2.6</a> полностью соответствует основным требованиям разговорного поиска по требованию. Ниже представлены ключевые возможности и их соответствие реальным потребностям разговорного поиска.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/milvus_2_6_ce379ff42d.jpg" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<h3 id="Hybrid-Retrieval-with-Dense-and-Sparse-Vectors" class="common-anchor-header">Гибридный поиск с плотными и разреженными векторами</h3><p>Milvus 2.6 поддерживает хранение плотных и разреженных векторов в одной коллекции и автоматическое объединение их результатов во время запроса. Плотные векторы (например, 768-мерные вкрапления, генерируемые моделями типа BGE-M3) отражают семантическое сходство, а разреженные векторы (обычно генерируемые BM25) сохраняют точные сигналы ключевых слов.</p>
<p>Для такого запроса, как <em>"обсуждения RAG за прошлую неделю",</em> Milvus выполняет семантический поиск и поиск по ключевым словам параллельно, а затем объединяет результаты с помощью ранжирования. По сравнению с использованием только одного из подходов, эта гибридная стратегия обеспечивает значительно более высокий уровень запоминания в реальных сценариях разговора.</p>
<h3 id="Storage–Compute-Separation-and-Query-Optimization" class="common-anchor-header">Разделение хранения и вычислений и оптимизация запросов</h3><p>Milvus 2.6 поддерживает многоуровневое хранение данных двумя способами:</p>
<ul>
<li><p>Горячие данные в памяти, холодные данные в объектном хранилище.</p></li>
<li><p>Индексы в памяти, необработанные векторные данные в объектном хранилище.</p></li>
</ul>
<p>При таком дизайне для хранения одного миллиона записей разговоров достаточно 2 ГБ памяти и 8 ГБ объектного хранилища. При правильной настройке задержка P99 может оставаться ниже 20 мс даже при включенном разделении хранения и вычислений.</p>
<h3 id="JSON-Shredding-and-Fast-Scalar-Filtering" class="common-anchor-header">Измельчение JSON и быстрая скалярная фильтрация</h3><p>В Milvus 2.6 по умолчанию включена функция JSON Shredding, сглаживающая вложенные поля JSON в столбчатое хранилище. Это повышает производительность скалярной фильтрации на 3-5×, согласно официальным бенчмаркам (реальный прирост зависит от шаблона запроса).</p>
<p>Разговорный поиск часто требует фильтрации по метаданным, таким как идентификатор пользователя, идентификатор сессии или временной диапазон. С помощью JSON Shredding запросы типа <em>"все разговоры пользователя A за последнюю неделю"</em> можно выполнять непосредственно по столбцовым индексам, без многократного разбора полных JSON-блобов.</p>
<h3 id="Open-Source-Control-and-Operational-Flexibility" class="common-anchor-header">Управление с открытым исходным кодом и операционная гибкость</h3><p>Будучи системой с открытым исходным кодом, Milvus предлагает такой уровень архитектурного и операционного контроля, которого нет у закрытых решений типа "черный ящик". Команды могут настраивать параметры индексов, применять стратегии ярусного размещения данных и настраивать распределенные развертывания в соответствии с рабочими нагрузками.</p>
<p>Такая гибкость снижает барьер для входа: малые и средние команды могут создавать разговорные поисковые системы масштабом от миллиона до десятка миллионов, не прибегая к огромным бюджетам на инфраструктуру.</p>
<h2 id="Why-ChatGPT-and-Claude-Took-Different-Paths" class="common-anchor-header">Почему ChatGPT и Claude пошли разными путями<button data-href="#Why-ChatGPT-and-Claude-Took-Different-Paths" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>На самом деле разница между системами памяти ChatGPT и Claude сводится к тому, как каждая из них работает с забыванием. ChatGPT предпочитает проактивное забывание: как только память превышает установленные пределы, старый контекст удаляется. В результате полнота памяти обменивается на простоту и предсказуемое поведение системы. Claude предпочитает отложенное забывание. Теоретически история разговоров может расти без ограничений, а запоминание передается системе поиска по требованию.</p>
<p>Почему же две системы выбрали разные пути? С учетом технических ограничений, описанных выше, ответ становится очевидным: <strong>каждая архитектура жизнеспособна только в том случае, если базовая инфраструктура может ее поддерживать</strong>.</p>
<p>Если бы подход Клода был применен в 2020 году, он, скорее всего, оказался бы непрактичным. В то время векторные базы данных часто работали с задержками в сотни миллисекунд, гибридные запросы плохо поддерживались, а потребление ресурсов непомерно возрастало по мере роста данных. В таких условиях поиск по требованию был бы воспринят как излишняя инженерия.</p>
<p>К 2025 году ситуация изменилась. Развитие инфраструктуры, обусловленное такими системами, как <strong>Milvus 2.6,</strong>сделало разделение хранилища и вычислений, оптимизацию запросов, гибридный поиск по плотности и разреженности и измельчение JSON-файлов жизнеспособными в производстве. Эти достижения позволили сократить время ожидания, контролировать затраты и сделать выборочный поиск практичным в масштабе. В результате инструменты по требованию и память на основе поиска стали не только возможными, но и все более привлекательными, особенно в качестве основы для систем агентского типа.</p>
<p>В конечном итоге выбор архитектуры зависит от того, что позволяет инфраструктура.</p>
<h2 id="Conclusion" class="common-anchor-header">Заключение<button data-href="#Conclusion" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>В реальных системах проектирование памяти не является бинарным выбором между предварительно вычисленным контекстом и извлечением по требованию. Наиболее эффективные архитектуры, как правило, являются гибридными, сочетающими оба подхода.</p>
<p>Чаще всего в систему вводится информация о последних событиях в разговоре через скользящее контекстное окно, стабильные предпочтения пользователя хранятся в постоянной памяти, а более старая история извлекается по запросу с помощью векторного поиска. По мере развития продукта этот баланс может постепенно меняться - от преимущественно предварительно вычисленного контекста к все более ориентированному на поиск, - не требуя разрушительной архитектурной перестройки.</p>
<p>Даже если вы начинаете с подхода, основанного на предварительных вычислениях, важно проектировать с учетом миграции. Память должна храниться с четкими идентификаторами, временными метками, категориями и ссылками на источник. Когда поиск станет целесообразным, вкрапления могут быть сгенерированы для существующей памяти и добавлены в векторную базу данных вместе с теми же метаданными, что позволит внедрять логику поиска постепенно и с минимальными нарушениями.</p>
<p>У вас есть вопросы или вы хотите получить подробную информацию о любой функции последней версии Milvus? Присоединяйтесь к нашему <a href="https://discord.com/invite/8uyFbECzPX">каналу Discord</a> или создавайте проблемы на <a href="https://github.com/milvus-io/milvus">GitHub</a>. Вы также можете заказать 20-минутный индивидуальный сеанс, чтобы получить знания, рекомендации и ответы на свои вопросы в <a href="https://milvus.io/blog/join-milvus-office-hours-to-get-support-from-vectordb-experts.md">Milvus Office Hours</a>.</p>
