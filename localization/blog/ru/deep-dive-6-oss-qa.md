---
id: deep-dive-6-oss-qa.md
title: >-
  Обеспечение качества программного обеспечения с открытым исходным кодом (OSS)
  - на примере Milvus
author: Wenxing Zhu
date: 2022-04-25T00:00:00.000Z
desc: >-
  Обеспечение качества - это процесс определения соответствия продукта или
  услуги определенным требованиям.
cover: assets.zilliz.com/Deep_Dive_6_c2cd44801d.png
tag: Engineering
tags: 'Data science, Database, Tech, Artificial Intelligence, Vector Management'
canonicalUrl: 'https://milvus.io/blog/deep-dive-6-oss-qa.md'
---
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/Deep_Dive_6_c2cd44801d.png" alt="Cover image" class="doc-image" id="cover-image" />
   </span> <span class="img-wrapper"> <span>Изображение на обложке</span> </span></p>
<blockquote>
<p>Эта статья написана <a href="https://github.com/zhuwenxing">Вэньсином Чжу</a> и переведена <a href="https://www.linkedin.com/in/yiyun-n-2aa713163/">Анжелой Ни</a>.</p>
</blockquote>
<p>Обеспечение качества (ОК) - это систематический процесс определения соответствия продукта или услуги определенным требованиям. Система обеспечения качества является неотъемлемой частью процесса НИОКР, поскольку, как следует из названия, она гарантирует качество продукта.</p>
<p>В этом посте представлена система QA, принятая при разработке векторной базы данных Milvus, с целью предоставить разработчикам и пользователям руководство по участию в этом процессе. Также будут рассмотрены основные модули тестирования в Milvus, а также методы и инструменты, которые можно использовать для повышения эффективности QA-тестирования.</p>
<p><strong>Перейти к:</strong></p>
<ul>
<li><a href="#A-general-introduction-to-the-Milvus-QA-system">Общее введение в систему контроля качества Milvus</a></li>
<li><a href="#Test-modules-in-Milvus">Тестовые модули в Milvus</a></li>
<li><a href="#Tools-and-methods-for-better-QA-efficiency">Инструменты и методы для повышения эффективности QA</a></li>
</ul>
<h2 id="A-general-introduction-to-the-Milvus-QA-system" class="common-anchor-header">Общее представление о системе контроля качества Milvus<button data-href="#A-general-introduction-to-the-Milvus-QA-system" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p><a href="https://milvus.io/blog/deep-dive-1-milvus-architecture-overview.md">Архитектура системы</a> имеет решающее значение для проведения QA-тестирований. Чем лучше QA-инженер знаком с системой, тем больше вероятность того, что он разработает разумный и эффективный план тестирования.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/Milvus_architecture_feaccc489d.png" alt="Milvus architecture" class="doc-image" id="milvus-architecture" />
   </span> <span class="img-wrapper"> <span>Архитектура Milvus</span> </span></p>
<p>Milvus 2.0 использует <a href="https://milvus.io/blog/deep-dive-1-milvus-architecture-overview.md#A-cloud-native-first-approach">облачную нативную, распределенную и многоуровневую архитектуру</a>, а SDK является <a href="https://milvus.io/blog/deep-dive-2-milvus-sdk-and-api.md">главным входом для передачи данных</a> в Milvus. Пользователи Milvus очень часто используют SDK, поэтому функциональное тестирование на стороне SDK очень необходимо. Кроме того, функциональные тесты SDK могут помочь обнаружить внутренние проблемы, которые могут существовать в системе Milvus. Помимо функциональных тестов, будут проводиться и другие виды тестирования векторной базы данных, включая модульные тесты, тесты развертывания, тесты надежности, тесты стабильности и тесты производительности.</p>
<p>Облачная нативная и распределенная архитектура привносит в QA-тестирование как удобства, так и проблемы. В отличие от систем, которые развертываются и запускаются локально, экземпляр Milvus, развернутый и запущенный на кластере Kubernetes, может обеспечить тестирование программного обеспечения в тех же условиях, что и его разработка. Однако недостатком является то, что сложность распределенной архитектуры привносит больше неопределенностей, которые могут сделать QA-тестирование системы еще более сложным и напряженным. Например, в Milvus 2.0 используются микросервисы из различных компонентов, что приводит к увеличению количества <a href="https://milvus.io/blog/deep-dive-1-milvus-architecture-overview.md#A-bare-bones-skeleton-of-the-Milvus-architecture">сервисов и узлов</a>, а также к повышению вероятности системной ошибки. Следовательно, для повышения эффективности тестирования необходим более сложный и комплексный план QA.</p>
<h3 id="QA-testings-and-issue-management" class="common-anchor-header">QA-тестирование и управление проблемами</h3><p>QA в Milvus включает в себя как проведение тестов, так и управление проблемами, возникающими в процессе разработки программного обеспечения.</p>
<h4 id="QA-testings" class="common-anchor-header">QA-тестирование</h4><p>Milvus проводит различные виды QA-тестирования в соответствии с возможностями Milvus и потребностями пользователей в порядке приоритетности, как показано на рисунке ниже.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/Frame_1_14_2aff081d41.png" alt="QA testing priority" class="doc-image" id="qa-testing-priority" />
   </span> <span class="img-wrapper"> <span>Приоритет QA-тестирования</span> </span></p>
<p>QA-тестирование в Milvus проводится по следующим аспектам в следующем порядке:</p>
<ol>
<li><strong>Функции</strong>: Проверяется, работают ли функции и возможности так, как было задумано изначально.</li>
<li><strong>Развертывание</strong>: Проверяется, может ли пользователь развернуть, переустановить и обновить как автономную версию Mivus, так и кластер Milvus с помощью различных методов (Docker Compose, Helm, APT или YUM и т. д.).</li>
<li><strong>Производительность</strong>:  Проверьте производительность вставки данных, индексации, векторного поиска и запросов в Milvus.</li>
<li><strong>Стабильность</strong>: Проверьте, может ли Milvus стабильно работать в течение 5-10 дней при нормальном уровне нагрузки.</li>
<li><strong>Надежность</strong>: Проверьте, может ли Milvus продолжать частично функционировать при возникновении определенных системных ошибок.</li>
<li><strong>Конфигурация</strong>: Проверьте, работает ли Milvus так, как ожидается, при определенной конфигурации.</li>
<li><strong>Совместимость</strong>: Проверьте, совместим ли Milvus с различными типами аппаратного или программного обеспечения.</li>
</ol>
<h4 id="Issue-management" class="common-anchor-header">Решение проблем</h4><p>В процессе разработки программного обеспечения может возникнуть множество проблем. Авторами типовых проблем могут быть сами QA-инженеры или пользователи Milvus из сообщества разработчиков с открытым исходным кодом. Команда QA отвечает за устранение проблем.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/Issue_management_workflow_12c726efa1.png" alt="Issue management workflow" class="doc-image" id="issue-management-workflow" />
   </span> <span class="img-wrapper"> <span>Рабочий процесс управления проблемами</span> </span></p>
<p>Когда <a href="https://github.com/milvus-io/milvus/issues">проблема</a> создается, она сначала проходит процедуру сортировки. Во время сортировки новые проблемы проверяются на предмет предоставления достаточной информации о них. Если проблема подтверждена, она будет принята разработчиками, и они попытаются устранить проблемы. После завершения разработки автор проблемы должен проверить, исправлена ли она. Если да, проблема будет окончательно закрыта.</p>
<h3 id="When-is-QA-needed" class="common-anchor-header">Когда необходим QA?</h3><p>Одно из распространенных заблуждений заключается в том, что QA и разработка независимы друг от друга. Однако на самом деле для обеспечения качества системы необходимы усилия как разработчиков, так и QA-инженеров. Поэтому QA необходимо вовлекать в работу на протяжении всего жизненного цикла.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/QA_lifecycle_375f4fd8a8.png" alt="QA lifecycle" class="doc-image" id="qa-lifecycle" />
   </span> <span class="img-wrapper"> <span>Жизненный цикл QA</span> </span></p>
<p>Как показано на рисунке выше, полный жизненный цикл разработки программного обеспечения включает в себя три этапа.</p>
<p>На начальном этапе разработчики публикуют проектную документацию, а QA-инженеры разрабатывают планы тестирования, определяют критерии выпуска и назначают задачи QA. Разработчики и QA-инженеры должны быть знакомы как с проектной документацией, так и с планом тестирования, чтобы у обеих команд было общее понимание цели выпуска (с точки зрения возможностей, производительности, стабильности, устранения ошибок и т. д.).</p>
<p>Во время разработки тестировщики и QA часто взаимодействуют для разработки и проверки возможностей и функций, а также исправления ошибок и проблем, о которых сообщает <a href="https://slack.milvus.io/">сообщество</a> разработчиков.</p>
<p>На заключительном этапе, если критерии релиза соблюдены, выпускается новый Docker-образ новой версии Milvus. Для официального релиза необходимо написать заметку о новых возможностях и исправленных ошибках, а также поставить метку релиза. Затем команда QA также опубликует отчет о тестировании этого релиза.</p>
<h2 id="Test-modules-in-Milvus" class="common-anchor-header">Тестовые модули в Milvus<button data-href="#Test-modules-in-Milvus" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>В Milvus есть несколько тестовых модулей, и в этом разделе мы подробно расскажем о каждом из них.</p>
<h3 id="Unit-test" class="common-anchor-header">Модульный тест</h3><p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/Unit_test_7d3d422345.png" alt="Unit test" class="doc-image" id="unit-test" />
   </span> <span class="img-wrapper"> <span>Модульный тест</span> </span></p>
<p>Юнит-тесты могут помочь выявить ошибки в программном обеспечении на ранней стадии и предоставить критерии проверки для реструктуризации кода. Согласно критериям принятия запросов на исправление (PR) в Milvus, <a href="https://app.codecov.io/gh/milvus-io/milvus/">покрытие</a> модульных тестов должно составлять 80 %.</p>
<h3 id="Function-test" class="common-anchor-header">Функциональные тесты</h3><p>Функциональные тесты в Milvus в основном организованы вокруг <a href="https://github.com/milvus-io/pymilvus">PyMilvus</a> и SDK. Основная цель функциональных тестов - проверить, могут ли интерфейсы работать так, как задумано. У функциональных тестов есть два аспекта:</p>
<ul>
<li>Проверка того, могут ли SDK возвращать ожидаемые результаты при передаче правильных параметров.</li>
<li>Проверка того, может ли SDK обрабатывать ошибки и возвращать корректные сообщения об ошибках при передаче неверных параметров.</li>
</ul>
<p>На рисунке ниже показан текущий фреймворк для функциональных тестов, который основан на основном фреймворке <a href="https://pytest.org/">pytest</a>. Этот фреймворк добавляет обертку к PyMilvus и расширяет возможности тестирования с помощью интерфейса автоматизированного тестирования.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/Function_test_41f837d3e7.png" alt="Function test" class="doc-image" id="function-test" />
   </span> <span class="img-wrapper"> <span>Функциональный тест</span> </span></p>
<p>Учитывая, что необходим общий метод тестирования и некоторые функции должны использоваться повторно, вместо прямого использования интерфейса PyMilvus используется описанный выше фреймворк тестирования. В фреймворк также включен модуль "check" для удобства проверки ожидаемых и фактических значений.</p>
<p>В каталог <code translate="no">tests/python_client/testcases</code> включено 2 700 функциональных тестов, которые полностью покрывают почти все интерфейсы PyMilvus. Эти функциональные тесты строго контролируют качество каждого PR.</p>
<h3 id="Deployment-test" class="common-anchor-header">Тест развертывания</h3><p>Milvus поставляется в двух режимах: <a href="https://milvus.io/docs/v2.0.x/install_standalone-docker.md">автономном</a> и <a href="https://milvus.io/docs/v2.0.x/install_cluster-docker.md">кластерном</a>. Есть два основных способа развертывания Milvus: с помощью Docker Compose или Helm. После развертывания Milvus пользователи также могут перезапустить или обновить службу Milvus. Существует две основные категории тестов развертывания: тест на перезапуск и тест на обновление.</p>
<p>Тест на перезапуск относится к процессу проверки сохранности данных, то есть того, остаются ли данные доступными после перезапуска. Тест обновления относится к процессу проверки совместимости данных для предотвращения ситуаций, когда в Milvus вставляются данные несовместимых форматов. Оба типа тестов развертывания имеют одинаковый рабочий процесс, как показано на рисунке ниже.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/Deployment_test_342ab3b3f5.png" alt="Deployment test" class="doc-image" id="deployment-test" />
   </span> <span class="img-wrapper"> <span>Тест развертывания</span> </span></p>
<p>В тесте перезагрузки для двух развертываний используется один и тот же образ докера. Однако в тесте обновления первая установка использует докер-образ предыдущей версии, а вторая - докер-образ более поздней версии. Результаты тестирования и данные сохраняются в файле <code translate="no">Volumes</code> или в <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/">заявке на постоянный том</a> (PVC).</p>
<p>При выполнении первого теста создается несколько коллекций, и с каждой из них производятся различные операции. При выполнении второго теста основное внимание уделяется проверке того, доступны ли созданные коллекции для CRUD-операций и можно ли в дальнейшем создавать новые коллекции.</p>
<h3 id="Reliability-test" class="common-anchor-header">Тест на надежность</h3><p>При тестировании надежности облачных распределенных систем обычно используется метод хаос-инжиниринга, цель которого - пресечь ошибки и сбои в системе в зародыше. Другими словами, при хаос-инженерном тестировании мы целенаправленно создаем системные сбои, чтобы выявить проблемы в тестах под давлением и устранить системные сбои до того, как они начнут представлять реальную опасность. Во время испытаний хаоса в Milvus мы выбираем <a href="https://chaos-mesh.org/">Chaos Mesh</a> в качестве инструмента для создания хаоса. Существует несколько типов отказов, которые необходимо создать:</p>
<ul>
<li><strong>Убийство узла</strong>: симуляция сценария, при котором узлы выходят из строя.</li>
<li><strong>Отказ узла</strong>: Проверка, если один из рабочих узлов выйдет из строя, сможет ли вся система продолжать работать.</li>
<li><strong>Стресс памяти</strong>: симуляция интенсивного потребления ресурсов памяти и процессора рабочими узлами.</li>
<li><strong>Разделение сети</strong>: Поскольку Milvus <a href="https://milvus.io/docs/v2.0.x/four_layers.md">отделяет хранение данных от вычислений</a>, система в значительной степени зависит от связи между различными компонентами. Чтобы проверить взаимозависимость различных компонентов Milvus, необходимо смоделировать сценарий, в котором связь между различными капсулами разделена.</li>
</ul>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/Reliability_test_a7331b91f4.png" alt="Reliability test" class="doc-image" id="reliability-test" />
   </span> <span class="img-wrapper"> <span>Проверка надежности</span> </span></p>
<p>На рисунке выше показан фреймворк тестирования надежности в Milvus, который позволяет автоматизировать хаос-тесты. Рабочий процесс теста надежности выглядит следующим образом:</p>
<ol>
<li>Инициализируйте кластер Milvus, прочитав конфигурации развертывания.</li>
<li>Когда кластер готов, запустите <code translate="no">test_e2e.py</code>, чтобы проверить, доступны ли функции Milvus.</li>
<li>Запустите <code translate="no">hello_milvus.py</code> для проверки сохранности данных. Создайте коллекцию с именем "hello_milvus" для вставки, промывки, создания индексов, векторного поиска и запросов. Эта коллекция не будет освобождаться или сбрасываться во время тестирования.</li>
<li>Создайте объект мониторинга, который запустит шесть потоков, выполняющих операции create, insert, flush, index, search и query.</li>
</ol>
<pre><code translate="no">checkers = {
    Op.create: CreateChecker(),
    Op.insert: InsertFlushChecker(),
    Op.flush: InsertFlushChecker(flush=<span class="hljs-literal">True</span>),
    Op.index: IndexChecker(),
    Op.search: SearchChecker(),
    Op.query: QueryChecker()
}
<button class="copy-code-btn"></button></code></pre>
<ol start="5">
<li>Сделайте первое утверждение - все операции прошли успешно, как и ожидалось.</li>
<li>Внесите в Milvus системный сбой, используя Chaos Mesh для разбора yaml-файла, определяющего сбой. Сбоем может быть, например, уничтожение узла запроса каждые пять секунд.</li>
<li>Сделайте второе утверждение при введении системного сбоя - оцените, соответствуют ли возвращаемые результаты операций в Milvus во время системного сбоя ожиданиям.</li>
<li>Устраните сбой с помощью Chaos Mesh.</li>
<li>Когда сервис Milvus восстановится (то есть все капсулы будут готовы), сделайте третье утверждение - все операции прошли успешно, как и ожидалось.</li>
<li>Запустите <code translate="no">test_e2e.py</code>, чтобы проверить, доступны ли функции Milvus. Некоторые операции во время хаоса могут быть заблокированы из-за третьего утверждения. И даже после устранения хаоса некоторые операции могут продолжать блокироваться, мешая третьему утверждению быть успешным, как ожидалось. Этот шаг призван облегчить выполнение третьего утверждения и служит в качестве стандарта для проверки того, восстановился ли сервис Milvus.</li>
<li>Запустите <code translate="no">hello_milvus.py</code>, загрузите созданную коллекцию и выполните над ней операции CRUP. Затем проверьте, доступны ли данные, существовавшие до сбоя системы, после восстановления.</li>
<li>Соберите журналы.</li>
</ol>
<h3 id="Stability-and-performance-test" class="common-anchor-header">Проверка стабильности и производительности</h3><p>На рисунке ниже описаны цели, сценарии тестирования и метрики тестирования стабильности и производительности.</p>
<table>
<thead>
<tr><th></th><th>Тест стабильности</th><th>Тест производительности</th></tr>
</thead>
<tbody>
<tr><td>Цели</td><td>- Убедиться, что Milvus может бесперебойно работать в течение определенного периода времени при нормальной нагрузке. <br> - Убедиться в стабильном потреблении ресурсов при запуске службы Milvus.</td><td>- Протестируйте производительность всех интерфейсов Milvus. <br> - Найдите оптимальную конфигурацию с помощью тестов производительности.  <br> - Служит эталоном для будущих релизов. <br> - Найдите узкое место, препятствующее повышению производительности.</td></tr>
<tr><td>Сценарии</td><td>- Сценарий с интенсивным чтением в автономном режиме, когда данные практически не обновляются после вставки, а процент обработки каждого типа запросов составляет: поисковый запрос - 90 %, запрос на вставку - 5 %, остальные - 5 %. <br> - Сценарий с интенсивной записью в режиме онлайн, когда данные вставляются и ищутся одновременно, и процент обработки каждого типа запросов составляет: запрос на вставку - 50 %, запрос на поиск - 40 %, остальные - 10 %.</td><td>- Вставка данных <br> - Построение индекса <br> - Векторный поиск</td></tr>
<tr><td>Метрики</td><td>- Использование памяти <br> - Потребление процессора <br> - Задержка ввода-вывода <br> - Состояние поддонов Milvus <br> - Время отклика службы Milvus <br> и т. д.</td><td>- Пропускная способность при вставке данных <br> - Время, необходимое для построения индекса <br> - Время отклика при векторном поиске <br> - Количество запросов в секунду (QPS) <br> - Запрос в секунду  <br> - Скорость отзыва <br> и т.д.</td></tr>
</tbody>
</table>
<p>И тест на стабильность, и тест на производительность имеют один и тот же набор рабочих процессов:</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/Stability_and_performance_test_6ed8532697.png" alt="Stability and performance test" class="doc-image" id="stability-and-performance-test" />
   </span> <span class="img-wrapper"> <span>Тест стабильности и производительности</span> </span></p>
<ol>
<li>Разбор и обновление конфигураций, определение метрик. Сайт <code translate="no">server-configmap</code> соответствует конфигурации автономного или кластерного Milvus, а сайт <code translate="no">client-configmap</code> - конфигурации тестовых примеров.</li>
<li>Настройте сервер и клиент.</li>
<li>Подготовка данных</li>
<li>Запрос взаимодействия между сервером и клиентом.</li>
<li>Отчеты и отображение метрик.</li>
</ol>
<h2 id="Tools-and-methods-for-better-QA-efficiency" class="common-anchor-header">Инструменты и методы для повышения эффективности QA<button data-href="#Tools-and-methods-for-better-QA-efficiency" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Из раздела тестирования модулей видно, что процедура большинства тестов практически одинакова, в основном она включает изменение конфигураций сервера и клиента Milvus и передачу параметров API. При наличии нескольких конфигураций, чем разнообразнее их комбинация, тем больше сценариев тестирования могут охватить эти эксперименты и тесты. В результате повторное использование кодов и процедур становится еще более важным для повышения эффективности тестирования.</p>
<h3 id="SDK-test-framework" class="common-anchor-header">Тестовый фреймворк SDK</h3><p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/SDK_test_framework_8219e28f4c.png" alt="SDK test framework" class="doc-image" id="sdk-test-framework" />
   </span> <span class="img-wrapper"> <span>Тестовый фреймворк SDK</span> </span></p>
<p>Чтобы ускорить процесс тестирования, мы можем добавить обертку <code translate="no">API_request</code> к оригинальному фреймворку тестирования и установить ее в качестве чего-то похожего на API-шлюз. Этот API-шлюз будет отвечать за сбор всех API-запросов, а затем передавать их Milvus для коллективного получения ответов. После этого ответы будут передаваться обратно клиенту. Такая конструкция значительно упрощает сбор определенной информации в журнале, например параметров и возвращаемых результатов. Кроме того, компонент проверки в тестовом фреймворке SDK может проверять и исследовать результаты, полученные от Milvus. И все методы проверки могут быть определены в этом компоненте.</p>
<p>С помощью тестового фреймворка SDK некоторые важные процессы инициализации могут быть обернуты в одну единственную функцию. Таким образом, можно избавиться от больших кусков утомительного кода.</p>
<p>Примечательно, что каждый отдельный тестовый пример связан со своей уникальной коллекцией для обеспечения изоляции данных.</p>
<p>При выполнении тестовых примеров можно использовать<code translate="no">pytest-xdist</code>, расширение pytest, для параллельного выполнения всех отдельных тестовых примеров, что значительно повышает эффективность.</p>
<h3 id="GitHub-action" class="common-anchor-header">Действие GitHub</h3><p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/Git_Hub_action_c3c1bed591.png" alt="GitHub action" class="doc-image" id="github-action" />
   </span> <span class="img-wrapper"> <span>Действия GitHub</span> </span></p>
<p><a href="https://docs.github.com/en/actions">GitHub Action</a> также используется для повышения эффективности QA благодаря следующим характеристикам:</p>
<ul>
<li>Это собственный CI/CD-инструмент, глубоко интегрированный с GitHub.</li>
<li>Он поставляется с единообразно настроенным машинным окружением и предустановленными общими инструментами разработки программного обеспечения, включая Docker, Docker Compose и т. д.</li>
<li>Он поддерживает множество операционных систем и версий, включая Ubuntu, MacOs, Windows-server и т. д.</li>
<li>В нем есть рынок, предлагающий богатые расширения и функции из коробки.</li>
<li>Матрица поддерживает одновременные задания и повторное использование одного и того же тестового потока для повышения эффективности.</li>
</ul>
<p>Помимо вышеперечисленных характеристик, еще одной причиной перехода на GitHub Action является то, что тесты развертывания и тесты надежности требуют независимой и изолированной среды. А GitHub Action идеально подходит для ежедневных инспекционных проверок на небольших наборах данных.</p>
<h3 id="Tools-for-benchmark-tests" class="common-anchor-header">Инструменты для эталонных тестов</h3><p>Чтобы сделать QA-тесты более эффективными, используется ряд инструментов.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/Frame_1_13_fbc71dfe4f.png" alt="QA tools" class="doc-image" id="qa-tools" />
   </span> <span class="img-wrapper"> <span>Инструменты QA</span> </span></p>
<ul>
<li><a href="https://argoproj.github.io/">Argo</a>: набор инструментов с открытым исходным кодом для Kubernetes для запуска рабочих процессов и управления кластерами путем планирования задач. Он также позволяет выполнять несколько задач параллельно.</li>
<li><a href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/">Kubernetes dashboard</a>: пользовательский веб-интерфейс Kubernetes для визуализации <code translate="no">server-configmap</code> и <code translate="no">client-configmap</code>.</li>
<li><a href="https://en.wikipedia.org/wiki/Network-attached_storage">NAS</a>: сетевое хранилище (NAS) - это компьютерный сервер хранения данных файлового уровня для хранения распространенных наборов данных ANN-бенчмарков.</li>
<li><a href="https://www.influxdata.com/">InfluxDB</a> и <a href="https://www.mongodb.com/">MongoDB</a>: базы данных для сохранения результатов бенчмарк-тестов.</li>
<li><a href="https://grafana.com/">Grafana</a>: Решение для аналитики и мониторинга с открытым исходным кодом для мониторинга метрик ресурсов сервера и метрик производительности клиентов.</li>
<li><a href="https://redash.io/">Redash</a>: Сервис, который помогает визуализировать данные и создавать графики для эталонных тестов.</li>
</ul>
<h2 id="About-the-Deep-Dive-Series" class="common-anchor-header">О серии глубоких погружений<button data-href="#About-the-Deep-Dive-Series" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>После <a href="https://milvus.io/blog/2022-1-25-annoucing-general-availability-of-milvus-2-0.md">официального объявления об общей доступности</a> Milvus 2.0 мы организовали эту серию блогов Milvus Deep Dive, чтобы дать глубокое толкование архитектуры и исходного кода Milvus. В этой серии блогов рассматриваются следующие темы:</p>
<ul>
<li><a href="https://milvus.io/blog/deep-dive-1-milvus-architecture-overview.md">Обзор архитектуры Milvus</a></li>
<li><a href="https://milvus.io/blog/deep-dive-2-milvus-sdk-and-api.md">API и Python SDK</a></li>
<li><a href="https://milvus.io/blog/deep-dive-3-data-processing.md">Обработка данных</a></li>
<li><a href="https://milvus.io/blog/deep-dive-4-data-insertion-and-data-persistence.md">Управление данными</a></li>
<li><a href="https://milvus.io/blog/deep-dive-5-real-time-query.md">Запрос в реальном времени</a></li>
<li><a href="https://milvus.io/blog/deep-dive-7-query-expression.md">Скалярный механизм выполнения</a></li>
<li><a href="https://milvus.io/blog/deep-dive-6-oss-qa.md">Система контроля качества</a></li>
<li><a href="https://milvus.io/blog/deep-dive-8-knowhere.md">Векторный механизм выполнения</a></li>
</ul>
