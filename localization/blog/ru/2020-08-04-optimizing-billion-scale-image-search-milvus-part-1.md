---
id: optimizing-billion-scale-image-search-milvus-part-1.md
title: Обзор
author: Rife Wang
date: 2020-08-04T20:39:09.882Z
desc: >-
  Пример из практики компании UPYUN. Узнайте, как Milvus выделяется на фоне
  традиционных решений для баз данных и помогает создать систему поиска по
  сходству изображений.
cover: assets.zilliz.com/header_23bbd76c8b.jpg
tag: Scenarios
canonicalUrl: 'https://zilliz.com/blog/optimizing-billion-scale-image-search-milvus-part-1'
---
<custom-h1>Путь к оптимизации поиска изображений в миллиардных масштабах (1/2)</custom-h1><p>Yupoo Picture Manager обслуживает десятки миллионов пользователей и управляет десятками миллиардов изображений. Поскольку галерея пользователей становится все больше, Yupoo срочно понадобилось решение, способное быстро находить изображения. Другими словами, когда пользователь вводит изображение, система должна найти его оригинал и похожие изображения в галерее. Разработка сервиса поиска по изображениям обеспечивает эффективный подход к решению этой задачи.</p>
<p>Сервис поиска по изображениям прошел две эволюции:</p>
<ol>
<li>Начало первого технического исследования в начале 2019 года и запуск системы первого поколения в марте и апреле 2019 года;</li>
<li>Начало исследования плана модернизации в начале 2020 года и начало общего обновления до системы второго поколения в апреле 2020 года.</li>
</ol>
<p>В этой статье описывается выбор технологии и основные принципы работы двух поколений системы поиска по изображениям, основанные на моем собственном опыте работы над этим проектом.</p>
<h2 id="Overview" class="common-anchor-header">Обзор<button data-href="#Overview" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><h3 id="What-is-an-image" class="common-anchor-header">Что такое изображение?</h3><p>Прежде чем работать с изображениями, мы должны знать, что такое изображение.</p>
<p>Ответ заключается в том, что изображение - это набор пикселей.</p>
<p>Например, деталь в красной рамке на этом изображении - это практически набор пикселей.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/1_what_is_an_image_021e0280cc.png" alt="1-what-is-an-image.png" class="doc-image" id="1-what-is-an-image.png" />
   </span> <span class="img-wrapper"> <span>1-what-is-an-image.png</span> </span></p>
<p>Предположим, что часть в красной рамке - это изображение, тогда каждый независимый маленький квадратик на изображении - это пиксель, основная единица информации. Тогда размер изображения составляет 11 x 11 px.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/2_what_is_an_image_602a91b4a0.png" alt="2-what-is-an-image.png" class="doc-image" id="2-what-is-an-image.png" />
   </span> <span class="img-wrapper"> <span>2-what-is-an-image.png</span> </span></p>
<h3 id="Mathematical-representation-of-images" class="common-anchor-header">Математическое представление изображений</h3><p>Каждое изображение можно представить в виде матрицы. Каждый пиксель изображения соответствует элементу матрицы.</p>
<h3 id="Binary-images" class="common-anchor-header">Бинарные изображения</h3><p>Пиксели бинарного изображения либо черные, либо белые, поэтому каждый пиксель может быть представлен 0 или 1. Например, матричное представление бинарного изображения 4 * 4:</p>
<pre><code translate="no">0 1 0 1
1 0 0 0
1 1 1 0
0 0 1 0
</code></pre>
<h3 id="RGB-images" class="common-anchor-header">RGB-изображения</h3><p>Три основных цвета (красный, зеленый и синий) могут быть смешаны для получения любого цвета. Для RGB-изображений каждый пиксель содержит основную информацию трех каналов RGB. Аналогично, если каждый канал использует 8-битное число (в 256 уровнях) для представления своей серой шкалы, то математическое представление пикселя таково:</p>
<pre><code translate="no">([0 .. 255], [0 .. 255], [0 .. 255])
</code></pre>
<p>Возьмем для примера RGB-изображение 4 * 4:</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/3_4_x_4_rgb_image_136cec77ce.png" alt="3-4-x-4-rgb-image.png" class="doc-image" id="3-4-x-4-rgb-image.png" />
   </span> <span class="img-wrapper"> <span>3-4-x-4-rgb-image.png</span> </span></p>
<p>Суть обработки изображений заключается в обработке этих матриц пикселей.</p>
<h2 id="The-technical-problem-of-search-by-image" class="common-anchor-header">Техническая проблема поиска по изображению<button data-href="#The-technical-problem-of-search-by-image" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Если вы ищете оригинальное изображение, то есть изображение с точно такими же пикселями, то вы можете напрямую сравнить их MD5-значения. Однако изображения, загружаемые в Интернет, часто бывают сжаты или снабжены водяными знаками. Даже небольшое изменение в изображении может привести к другому результату MD5. Пока существует несоответствие пикселей, найти оригинальное изображение невозможно.</p>
<p>В системе поиска по изображению мы хотим искать изображения с похожим содержанием. Для этого необходимо решить две основные проблемы:</p>
<ul>
<li>Представить или абстрагировать изображение в виде формата данных, который может быть обработан компьютером.</li>
<li>Данные должны быть сопоставимы для вычисления.</li>
</ul>
<p>Более конкретно, нам нужны следующие функции:</p>
<ul>
<li>Извлечение признаков изображения.</li>
<li>Вычисление признаков (вычисление сходства).</li>
</ul>
<h2 id="The-first-generation-search-by-image-system" class="common-anchor-header">Система поиска по изображению первого поколения<button data-href="#The-first-generation-search-by-image-system" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><h3 id="Feature-extraction--image-abstraction" class="common-anchor-header">Извлечение признаков - абстрагирование изображения</h3><p>В системе поиска по изображению первого поколения для выделения признаков используется алгоритм Perceptual hash или pHash. Каковы основы этого алгоритма?</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/4_first_generation_image_search_ffd7088158.png" alt="4-first-generation-image-search.png" class="doc-image" id="4-first-generation-image-search.png" />
   </span> <span class="img-wrapper"> <span>4-first-generation-image-search.png</span> </span></p>
<p>Как показано на рисунке выше, алгоритм pHash выполняет ряд преобразований изображения для получения хэш-значения. В процессе преобразований алгоритм постоянно абстрагирует изображения, тем самым приближая результаты похожих изображений друг к другу.</p>
<h3 id="Feature-calculation--similarity-calculation" class="common-anchor-header">Расчет характеристик - расчет сходства</h3><p>Как вычислить сходство между значениями pHash двух изображений? Ответ заключается в использовании расстояния Хэмминга. Чем меньше расстояние Хэмминга, тем больше сходство между изображениями.</p>
<p>Что такое расстояние Хэмминга? Это количество различных битов.</p>
<p>Например,</p>
<pre><code translate="no">Value 1： 0 1 0 1 0
Value 2： 0 0 0 1 1
</code></pre>
<p>В двух приведенных выше значениях есть два разных бита, поэтому расстояние Хэмминга между ними равно 2.</p>
<p>Теперь мы знаем принцип расчета сходства. Следующий вопрос - как вычислить расстояние Хэмминга между 100-миллионными данными и 100-миллионными изображениями? Короче говоря, как искать похожие изображения?</p>
<p>На ранней стадии проекта я не нашел удовлетворительного инструмента (или вычислительного движка), который мог бы быстро вычислить расстояние Хэмминга. Поэтому я изменил свой план.</p>
<p>Моя идея заключается в том, что если расстояние Хэмминга между двумя значениями pHash невелико, то я могу разрезать значения pHash, и соответствующие маленькие части, скорее всего, будут равны.</p>
<p>Например:</p>
<pre><code translate="no">Value 1： 8 a 0 3 0 3 f 6
Value 2： 8 a 0 3 0 3 d 8
</code></pre>
<p>Разделим два значения на восемь сегментов, и значения шести сегментов будут абсолютно одинаковыми. Можно сделать вывод, что их расстояние Хэмминга близко, а значит, эти два изображения похожи.</p>
<p>После преобразования можно обнаружить, что проблема вычисления расстояния Хэмминга превратилась в проблему соответствия эквивалентности. Если я разделю каждое значение pHash на восемь сегментов, то если в каждом сегменте больше пяти одинаковых значений, значит, два значения pHash похожи.</p>
<p>Таким образом, решить задачу сопоставления эквивалентности очень просто. Мы можем использовать классическую фильтрацию традиционной системы баз данных.</p>
<p>Конечно, я использую многотерминальное соответствие и задаю степень соответствия с помощью minimum_should_match в ElasticSearch (в этой статье не представлен принцип работы ES, вы можете изучить его самостоятельно).</p>
<p>Почему мы выбрали именно ElasticSearch? Во-первых, он предоставляет вышеупомянутую функцию поиска. Во-вторых, проект менеджера изображений сам по себе использует ES для обеспечения функции полнотекстового поиска, и это очень экономично с точки зрения использования имеющихся ресурсов.</p>
<h2 id="Summary-of-the-first-generation-system" class="common-anchor-header">Краткое описание системы первого поколения<button data-href="#Summary-of-the-first-generation-system" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>В качестве системы поиска по изображениям первого поколения выбрано решение pHash + ElasticSearch, которое обладает следующими особенностями:</p>
<ul>
<li>Алгоритм pHash прост в использовании и может противостоять определенной степени сжатия, водяным знакам и шуму.</li>
<li>ElasticSearch использует существующие ресурсы проекта, не добавляя дополнительных затрат на поиск.</li>
<li>Но ограничение этой системы очевидно: алгоритм pHash - это абстрактное представление всего изображения. Как только мы нарушаем целостность изображения, например, добавляем черную рамку к оригиналу, практически невозможно оценить сходство между оригиналом и другими изображениями.</li>
</ul>
<p>Чтобы преодолеть эти ограничения, возникла система поиска изображений второго поколения с совершенно иной технологией в основе.</p>
<p>Эта статья написана rifewang, пользователем Milvus и инженером-программистом UPYUN. Если вам понравилась эта статья, заходите поздороваться! https://github.com/rifewang</p>
