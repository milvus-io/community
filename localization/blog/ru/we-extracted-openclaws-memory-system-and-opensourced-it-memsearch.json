{"codeList":["~/your-project/\n└── memory/\n    ├── MEMORY.md              # Hand-written long-term memory\n    ├── 2026-02-09.md          # Today's work log\n    ├── 2026-02-08.md\n    └── 2026-02-07.md\n","## Morning\n- Fixed N+1 query issue — switched to selectinload()\n- Query count dropped from 152 to 3\n","git log memory/MEMORY.md\ngit diff HEAD~1 memory/2026-02-09.md\n","+ ## Architecture Decision\n+ - Use Kafka for event bus instead of RabbitMQ\n+ - Reason: better horizontal scaling\n","# Development\nms = MemSearch(milvus_uri=\"~/.memsearch/milvus.db\")\n\n# Production (change only this line)\nms = MemSearch(milvus_uri=\"https://xxx.zillizcloud.com\")\n","## Redis Caching\nWe use Redis for L1 cache with 5min TTL.\nThe connection pool is configured with max 100 connections.\n\n## Database\nPostgreSQL 16 is the primary database.\n","pip install memsearch\n","from openai import OpenAI\nfrom memsearch import MemSearch\n\nllm = OpenAI()\nms = MemSearch(paths=[\"./memory/\"])\n\nasync def agent_chat(user_input: str) -> str:\n    # 1. Recall — search relevant memories\n    memories = await ms.search(user_input, top_k=3)\n    context = \"\\n\".join(f\"- {m['content'][:200]}\" for m in memories)\n\n    # 2. Think — call LLM\n    resp = llm.chat.completions.create(\n        model=\"gpt-4o-mini\",\n        messages=[\n            {\"role\": \"system\", \"content\": f\"Memories:\\n{context}\"},\n            {\"role\": \"user\", \"content\": user_input},\n        ],\n    )\n\n    # 3. Remember — write to markdown, update index\n    save_memory(f\"## {user_input}\\n{resp.choices[0].message.content}\")\n    await ms.index()\n    return resp.choices[0].message.content\n","memsearch index ./docs/              # Index files\nmemsearch search \"Redis caching\"     # Search\nmemsearch watch ./docs/              # Watch for file changes\nmemsearch compact                    # Compact old memory\n"],"headingContent":"","anchorList":[{"label":"Чем отличается память OpenClaw","href":"What-Makes-OpenClaws-Memory-Different","type":2,"isActive":false},{"label":"Как работает Memsearch","href":"How-Memsearch-Works","type":2,"isActive":false},{"label":"Под капотом: memsearch работает на основе четырех рабочих процессов, которые обеспечивают быстрое, свежее и бережное использование памяти","href":"Under-the-Hood-memsearch-Runs-on-Four-Workflows-That-Keep-Memory-Fast-Fresh-and-Lean","type":2,"isActive":false},{"label":"Как начать работу с memsearch","href":"How-to-get-started-with-memsearch","type":2,"isActive":false},{"label":"Сравнение memsearch с другими решениями для работы с памятью","href":"How-memsearch-Compares-to-Other-Memory-Solutions","type":2,"isActive":false},{"label":"Попробуйте memsearch и сообщите нам о своих отзывах.","href":"Try-memsearch-and-let-us-know-your-feedback","type":2,"isActive":false},{"label":"Продолжить чтение","href":"Keep-Reading","type":2,"isActive":false}]}