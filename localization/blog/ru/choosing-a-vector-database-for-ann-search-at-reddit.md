---
id: choosing-a-vector-database-for-ann-search-at-reddit.md
title: Выбор базы данных векторов для поиска ANN на Reddit
author: Chris Fournie
date: 2025-11-28T00:00:00.000Z
cover: assets.zilliz.com/Chat_GPT_Image_Nov_29_2025_12_03_05_AM_min_1_05250269a8.png
tag: Engineering
recommend: true
publishToMedium: true
tags: 'Milvus, vector database, reddit'
meta_keywords: 'Milvus, vector database, reddit'
meta_title: |
  Choosing a vector database for ANN search at Reddit
desc: >-
  В этом посте описывается процесс, который команда Reddit использовала для
  выбора наиболее подходящей базы данных векторов, и почему они выбрали Milvus.
origin: 'https://milvus.io/blog/choosing-a-vector-database-for-ann-search-at-reddit.md'
---
<p><em>Это сообщение было написано Крисом Фурни, штатным инженером-программистом Reddit, и первоначально опубликовано на</em> <a href="https://www.reddit.com/r/RedditEng/comments/1ozxnjc/choosing_a_vector_database_for_ann_search_at/">Reddit</a>, а здесь перепощено с разрешения.</p>
<p>В 2024 году команды Reddit использовали различные решения для выполнения векторного поиска по приближенному ближайшему соседу (ANN). От <a href="https://docs.cloud.google.com/vertex-ai/docs/vector-search/overview">векторного поиска Vertex AI</a> от Google и экспериментов с использованием <a href="https://solr.apache.org/guide/solr/latest/query-guide/dense-vector-search.html">векторного поиска ANN от Apache Solr</a> для некоторых больших наборов данных до <a href="https://github.com/facebookresearch/faiss">библиотеки FAISS</a> от Facebook для небольших наборов данных (размещенных в вертикально масштабированных боковых машинах). Все больше и больше команд в Reddit хотели получить широко поддерживаемое решение для векторного поиска ANN, которое было бы экономически эффективным, обладало необходимыми функциями поиска и могло масштабироваться для данных размера Reddit. Чтобы удовлетворить эту потребность, в 2025 году мы искали идеальную базу данных векторов для команд Reddit.</p>
<p>В этом посте описан процесс, который мы использовали для выбора лучшей векторной базы данных для сегодняшних потребностей Reddit. Она не описывает лучшую векторную базу данных в целом или самый необходимый набор функциональных и нефункциональных требований для всех ситуаций. Здесь описано то, что Reddit и его инженерная культура оценили и расставили приоритеты при выборе векторной базы данных. Этот пост может послужить вдохновением для вашего собственного сбора и оценки требований, но у каждой организации своя культура, ценности и потребности.</p>
<h2 id="Evaluation-process" class="common-anchor-header">Процесс оценки<button data-href="#Evaluation-process" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>В целом, этапы выбора были следующими:</p>
<p>1. Сбор информации от команд</p>
<p>2. Качественная оценка решений</p>
<p>3. Количественная оценка лучших претендентов</p>
<p>4. Окончательный выбор</p>
<h3 id="1-Collect-context-from-teams" class="common-anchor-header">1. Сбор информации от команд</h3><p>Команды, заинтересованные в выполнении векторного поиска ANN, собирали информацию о трех аспектах контекста:</p>
<ul>
<li><p>Функциональные требования (например, гибридный векторный и лексический поиск? Диапазон поисковых запросов? Фильтрация по невекторным атрибутам?)</p></li>
<li><p>Нефункциональные требования (например, может ли он поддерживать 1B векторов? Может ли он достичь &lt;100 мс задержки P99?)</p></li>
<li><p>Векторные базы данных уже интересовали команды.</p></li>
</ul>
<p>Опрос команд на предмет требований не является тривиальным. Многие из них будут описывать свои потребности с точки зрения того, как они решают проблему в настоящее время, и ваша задача - понять и устранить эту предвзятость.</p>
<p>Например, команда уже использовала FAISS для векторного поиска ANN и заявила, что новое решение должно эффективно возвращать 10 тыс. результатов за один поисковый запрос. После дальнейшего обсуждения выяснилось, что причина 10 000 результатов в том, что им нужно было выполнить пост-специальную фильтрацию, а FAISS не предлагает фильтрацию результатов ANN во время запроса. На самом деле проблема заключалась в том, что им нужна фильтрация, поэтому подойдет любое решение, предлагающее эффективную фильтрацию, а возврат 10 тыс. результатов - это просто обходной путь, необходимый для улучшения запоминания. В идеале они хотели бы предварительно отфильтровать всю коллекцию перед поиском ближайших соседей.</p>
<p>Ценным был и вопрос о векторных базах данных, которые команды уже используют или которыми интересуются. Если хотя бы одна команда положительно отзывалась о своем текущем решении, это признак того, что векторная база данных может стать полезным решением для всей компании. Если команды высказывали только негативные мнения о решении, то нам не следует включать его в число возможных вариантов. Принятие решений, которые заинтересовали команды, также позволило убедиться, что команды чувствуют себя вовлеченными в процесс, и помогло нам сформировать первоначальный список ведущих претендентов для оценки; существует слишком много решений векторного поиска ANN в новых и существующих базах данных, чтобы исчерпывающе протестировать их все.</p>
<h3 id="2-Qualitatively-evaluate-solutions" class="common-anchor-header">2. Качественная оценка решений</h3><p>Начиная со списка решений, которые заинтересовали команды, для качественной оценки того, какое решение векторного поиска ANN лучше всего подходит для наших нужд, мы:</p>
<ul>
<li><p>Изучили каждое решение и оценили, насколько оно удовлетворяет каждому требованию в сравнении с весовой важностью этого требования.</p></li>
<li><p>Исключили решения, основываясь на качественных критериях и обсуждении</p></li>
<li><p>Отобрали N лучших решений для количественного тестирования.</p></li>
</ul>
<p>Наш начальный список решений для векторного поиска ANN включал:</p>
<ul>
<li><p><a href="https://milvus.io/">Milvus</a></p></li>
<li><p>Qdrant</p></li>
<li><p>Weviate</p></li>
<li><p>Open Search</p></li>
<li><p>Pgvector (уже использует Postgres в качестве RDBMS)</p></li>
<li><p>Redis (уже используется в качестве KV-хранилища и кэша)</p></li>
<li><p>Cassandra (уже используется для не-ANN поиска)</p></li>
<li><p>Solr (уже используется для лексического поиска и экспериментирует с векторным поиском)</p></li>
<li><p>Vespa</p></li>
<li><p>Pinecone</p></li>
<li><p>Vertex AI (уже используется для векторного поиска ANN)</p></li>
</ul>
<p>Затем мы взяли все функциональные и нефункциональные требования, которые были упомянуты командами, плюс еще несколько ограничений, представляющих наши инженерные ценности и цели, сделали эти строки в электронной таблице и взвесили, насколько они важны (от 1 до 3; показано в сокращенной таблице ниже).</p>
<p>Для каждого решения, которое мы сравнивали, мы оценивали (по шкале от 0 до 3), насколько хорошо каждая система удовлетворяет этому требованию (как показано в таблице ниже). Такая оценка была несколько субъективной, поэтому мы выбрали одну систему, привели примеры оценок с письменным обоснованием и попросили рецензентов обратиться к этим примерам. Мы также дали следующее руководство по присвоению каждой оценки: присвойте это значение, если:</p>
<ul>
<li><p>0: Нет поддержки/доказательства поддержки требований</p></li>
<li><p>1: Базовая или неадекватная поддержка требований</p></li>
<li><p>2: Требование разумно поддерживается</p></li>
<li><p>3: Надежная поддержка требований, выходящая за рамки сопоставимых решений.</p></li>
</ul>
<p>Затем мы создали общую оценку для каждого решения, взяв сумму произведения оценки требований решения и важности этого требования (например, Qdrant получил 3 балла за повторное ранжирование/сочетание баллов, которое имеет важность 2, поэтому 3 x 2 = 6, повторите это для всех строк и суммируйте). В итоге мы получаем общий балл, который можно использовать как основу для ранжирования и обсуждения решений, а также того, какие требования имеют наибольшее значение (обратите внимание, что балл используется не для принятия окончательного решения, а как инструмент для обсуждения).</p>
<p><strong><em>Примечание редактора:</em></strong> <em>этот обзор был основан на Milvus 2.4. С тех пор мы выпустили Milvus 2.5,</em> <a href="https://milvus.io/blog/introduce-milvus-2-6-built-for-scale-designed-to-reduce-costs.md"><em>Milvus 2.6</em></a><em>, а Milvus 3.0 уже не за горами, поэтому некоторые показатели могут быть устаревшими. Тем не менее, сравнение все еще предлагает сильные идеи и остается очень полезным.</em></p>
<table>
<thead>
<tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr>
</thead>
<tbody>
<tr><td><strong>Категория</strong></td><td><strong>Важность</strong></td><td><strong>Qdrant</strong></td><td><a href="https://milvus.io/"><strong>Milvus</strong></a> <strong>(2.4)</strong></td><td><strong>Cassandra</strong></td><td><strong>Weviate</strong></td><td><strong>Solr</strong></td><td><strong>Vertex AI</strong></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><strong>Тип поиска</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="https://milvus.io/blog/get-started-with-hybrid-semantic-full-text-search-with-milvus-2-5.md">Гибридный поиск</a></td><td>1</td><td>3</td><td>2</td><td>0</td><td>2</td><td>2</td><td>2</td></tr>
<tr><td>Поиск по ключевым словам</td><td>1</td><td>2</td><td>2</td><td>2</td><td>2</td><td>3</td><td>1</td></tr>
<tr><td>Приближенный поиск NN</td><td>3</td><td>3</td><td>3</td><td>2</td><td>2</td><td>2</td><td>2</td></tr>
<tr><td>Поиск по диапазону</td><td>1</td><td>3</td><td>3</td><td>2</td><td>2</td><td>0</td><td>0</td></tr>
<tr><td>Повторное ранжирование/объединение баллов</td><td>2</td><td>3</td><td>2</td><td>0</td><td>2</td><td>2</td><td>1</td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><strong>Метод индексации</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>HNSW</td><td>3</td><td>3</td><td>3</td><td>2</td><td>2</td><td>2</td><td>0</td></tr>
<tr><td>Поддержка нескольких методов индексирования</td><td>3</td><td>0</td><td>3</td><td>1</td><td>2</td><td>1</td><td>1</td></tr>
<tr><td>Квантование</td><td>1</td><td>3</td><td>3</td><td>0</td><td>3</td><td>0</td><td>0</td></tr>
<tr><td>Локально-чувствительное хэширование (LSH)</td><td>1</td><td>0</td><td>0Примечание: <a href="https://milvus.io/blog/minhash-lsh-in-milvus-the-secret-weapon-for-fighting-duplicates-in-llm-training-data.md">Milvus 2.6 поддерживает его. </a></td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><strong>Данные</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>Типы векторов, отличные от float</td><td>1</td><td>2</td><td>2</td><td>0</td><td>2</td><td>2</td><td>0</td></tr>
<tr><td>Атрибуты метаданных на векторах (поддерживает множество атрибутов, большой размер записи и т.д.)</td><td>3</td><td>3</td><td>2</td><td>2</td><td>2</td><td>2</td><td>1</td></tr>
<tr><td>Параметры фильтрации метаданных (можно фильтровать по метаданным, есть фильтрация до и после)</td><td>2</td><td>3</td><td>2</td><td>2</td><td>2</td><td>3</td><td>2</td></tr>
<tr><td>Типы данных атрибутов метаданных (надежная схема, например, bool, int, string, json, arrays)</td><td>1</td><td>3</td><td>3</td><td>2</td><td>2</td><td>3</td><td>1</td></tr>
<tr><td>Ограничения атрибутов метаданных (запросы диапазона, например, 10 &lt; x &lt; 15)</td><td>1</td><td>3</td><td>3</td><td>2</td><td>2</td><td>2</td><td>1</td></tr>
<tr><td>Разнообразие результатов по атрибутам (например, получение не более N результатов из каждого сабреддита в ответе)</td><td>1</td><td>2</td><td>1</td><td>2</td><td>3</td><td>3</td><td>0</td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><strong>Масштаб</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>Сотни миллионов векторных индексов</td><td>3</td><td>2</td><td>3</td><td></td><td>1</td><td>2</td><td>3</td></tr>
<tr><td>Индекс вектора миллиарда</td><td>1</td><td>2</td><td>2</td><td></td><td>1</td><td>2</td><td>2</td></tr>
<tr><td>Векторы поддержки не менее 2k</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>1</td><td>1</td></tr>
<tr><td>Векторы с поддержкой более 2k</td><td>2</td><td>2</td><td>2</td><td>2</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>P95 Задержка 50-100 мс при X QPS</td><td>3</td><td>2</td><td>2</td><td>2</td><td>1</td><td>1</td><td>2</td></tr>
<tr><td>Задержка P99 &lt;= 10 мс @ X QPS</td><td>3</td><td>2</td><td>2</td><td>2</td><td>3</td><td>1</td><td>2</td></tr>
<tr><td>99,9% доступности</td><td>2</td><td>2</td><td>2</td><td>3</td><td>2</td><td>2</td><td>2</td></tr>
<tr><td>Индексирование/хранение с доступностью 99,99 %</td><td>2</td><td>1</td><td>1</td><td>3</td><td>2</td><td>2</td><td>2</td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><strong>Операции хранения данных</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>Возможность размещения в AWS</td><td>3</td><td>2</td><td>2</td><td>2</td><td>2</td><td>3</td><td>0</td></tr>
<tr><td>Мультирегион</td><td>1</td><td>1</td><td>2</td><td>3</td><td>1</td><td>2</td><td>2</td></tr>
<tr><td>Обновления с нулевым временем простоя</td><td>1</td><td>2</td><td>2</td><td>3</td><td>2</td><td>2</td><td>1</td></tr>
<tr><td>Мультиоблако</td><td>1</td><td>3</td><td>3</td><td>3</td><td>2</td><td>2</td><td>0</td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><strong>API/библиотеки</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>gRPC</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>0</td><td>2</td></tr>
<tr><td>RESTful API</td><td>1</td><td>3</td><td>2</td><td>2</td><td>2</td><td>1</td><td>2</td></tr>
<tr><td>Перейти в библиотеку</td><td>3</td><td>2</td><td>2</td><td>2</td><td>2</td><td>1</td><td>2</td></tr>
<tr><td>Библиотека Java</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr>
<tr><td>Python</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr>
<tr><td>Другие языки (C++, Ruby и т.д.)</td><td>1</td><td>2</td><td>2</td><td>3</td><td>2</td><td>2</td><td>2</td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><strong>Операции во время выполнения</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>Метрики "Прометея</td><td>3</td><td>2</td><td>2</td><td>2</td><td>3</td><td>2</td><td>0</td></tr>
<tr><td>Основные операции с БД</td><td>3</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr>
<tr><td>Апсерты</td><td>2</td><td>2</td><td>2</td><td>2</td><td>1</td><td>2</td><td>2</td></tr>
<tr><td>Оператор Kubernetes</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>0</td></tr>
<tr><td>Пагинация результатов</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>0</td></tr>
<tr><td>Встраивание поиска по идентификатору</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr>
<tr><td>Возвращение вкраплений с идентификатором кандидата и его оценками</td><td>1</td><td>3</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr>
<tr><td>Идентификатор пользователя</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr>
<tr><td>Возможность поиска в крупномасштабном пакетном контексте</td><td>1</td><td>2</td><td>1</td><td>1</td><td>2</td><td>1</td><td>2</td></tr>
<tr><td>Резервное копирование / моментальные снимки: поддерживает возможность создания резервных копий всей базы данных</td><td>1</td><td>2</td><td>2</td><td>2</td><td>3</td><td>3</td><td>2</td></tr>
<tr><td>Эффективная поддержка больших индексов (различие между холодным и горячим хранением)</td><td>1</td><td>3</td><td>2</td><td>2</td><td>2</td><td>1</td><td>2</td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><strong>Поддержка/общество</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>Нейтралитет к поставщикам</td><td>3</td><td>3</td><td>2</td><td>3</td><td>2</td><td>3</td><td>0</td></tr>
<tr><td>Надежная поддержка api</td><td>3</td><td>3</td><td>3</td><td>2</td><td>2</td><td>2</td><td>2</td></tr>
<tr><td>Поддержка поставщиков</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>0</td></tr>
<tr><td>Скорость сообщества</td><td>2</td><td>3</td><td>2</td><td>2</td><td>2</td><td>2</td><td>0</td></tr>
<tr><td>База производственных пользователей</td><td>2</td><td>3</td><td>3</td><td>2</td><td>2</td><td>1</td><td>2</td></tr>
<tr><td>Ощущение сообщества</td><td>1</td><td>3</td><td>2</td><td>2</td><td>2</td><td>2</td><td>1</td></tr>
<tr><td>Звезды Github</td><td>1</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>0</td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><strong>Конфигурация</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>Обработка секретов</td><td>2</td><td>2</td><td>2</td><td>2</td><td>1</td><td>2</td><td>2</td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><strong>Источник</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>Открытый источник</td><td>3</td><td>3</td><td>3</td><td>3</td><td>2</td><td>3</td><td>0</td></tr>
<tr><td>Язык</td><td>2</td><td>3</td><td>3</td><td>2</td><td>3</td><td>2</td><td>0</td></tr>
<tr><td>Выпускает</td><td>2</td><td>3</td><td>3</td><td>2</td><td>2</td><td>2</td><td>2</td></tr>
<tr><td>Тестирование в верхнем течении</td><td>1</td><td>2</td><td>3</td><td>3</td><td>2</td><td>2</td><td>2</td></tr>
<tr><td>Наличие документации</td><td>3</td><td>3</td><td>3</td><td>2</td><td>1</td><td>2</td><td>1</td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><strong>Стоимость</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>Эффективная стоимость</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>1</td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><strong>Производительность</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>Поддержка настройки использования ресурсов процессора, памяти и диска</td><td>3</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr>
<tr><td>Разделение на несколько узлов (стручков)</td><td>3</td><td>2</td><td>2</td><td>3</td><td>2</td><td>2</td><td>2</td></tr>
<tr><td>Возможность настройки системы для баланса между задержкой и пропускной способностью</td><td>2</td><td>2</td><td>2</td><td>3</td><td>2</td><td>2</td><td>2</td></tr>
<tr><td>Пользовательское разбиение (запись)</td><td>1</td><td>3</td><td>2</td><td>3</td><td>1</td><td>2</td><td>0</td></tr>
<tr><td>Многоарендный</td><td>1</td><td>3</td><td>2</td><td>1</td><td>3</td><td>2</td><td>2</td></tr>
<tr><td>Разделы</td><td>2</td><td>2</td><td>2</td><td>3</td><td>2</td><td>2</td><td>2</td></tr>
<tr><td>Репликация</td><td>2</td><td>2</td><td>2</td><td>3</td><td>2</td><td>2</td><td>2</td></tr>
<tr><td>Резервирование</td><td>1</td><td>2</td><td>2</td><td>3</td><td>2</td><td>2</td><td>2</td></tr>
<tr><td>Автоматический отказ</td><td>3</td><td>2</td><td>0 Примечание: <a href="https://milvus.io/docs/coordinator_ha.md">Milvus 2.6 поддерживает эту функцию. </a></td><td>3</td><td>2</td><td>2</td><td>2</td></tr>
<tr><td>Балансировка нагрузки</td><td>2</td><td>2</td><td>2</td><td>3</td><td>2</td><td>2</td><td>2</td></tr>
<tr><td>Поддержка GPU</td><td>1</td><td>0</td><td>2</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td><strong>Qdrant</strong></td><td><a href="https://milvus.io/"><strong>Милвус</strong></a></td><td><strong>Кассандра</strong></td><td><strong>Weviate</strong></td><td><strong>Solr</strong></td><td><strong>Vertex AI</strong></td></tr>
<tr><td><strong>Общая оценка решений</strong></td><td></td><td>292</td><td>281</td><td>264</td><td>250</td><td>242</td><td>173</td></tr>
</tbody>
</table>
<p>Мы обсудили общую оценку и оценку требований различных систем и попытались понять, правильно ли мы взвесили важность требований и не являются ли некоторые требования настолько важными, что их следует считать основными ограничениями. Одним из таких требований было наличие или отсутствие открытого исходного кода, поскольку мы хотели получить решение, в котором мы могли бы участвовать, вносить свой вклад и быстро устранять небольшие проблемы, если бы они возникли в нашем масштабе. Вклад в разработку и использование программного обеспечения с открытым исходным кодом - важная часть инженерной культуры Reddit. Поэтому мы исключили из рассмотрения решения, работающие только на хостинге (Vertex AI, Pinecone).</p>
<p>В ходе обсуждения мы пришли к выводу, что несколько других ключевых требований имеют для нас первостепенное значение:</p>
<ul>
<li><p>Масштаб и надежность: мы хотели видеть доказательства того, что другие компании используют решение с 100М+ или даже 1В векторов.</p></li>
<li><p>Сообщество: Мы хотели получить решение, имеющее здоровое сообщество с большой динамикой развития в этом быстро развивающемся пространстве.</p></li>
<li><p>Выразительные типы метаданных и фильтрация, позволяющие реализовать большее количество наших сценариев использования (фильтрация по дате, булевым значениям и т.д.)</p></li>
<li><p>Поддержка нескольких типов индексов (не только HNSW или DiskANN), чтобы лучше соответствовать производительности для наших многочисленных уникальных случаев использования.</p></li>
</ul>
<p>В результате наших обсуждений и уточнения ключевых требований мы решили провести количественное тестирование (в порядке убывания):</p>
<ol>
<li><p>Qdrant</p></li>
<li><p>Milvus</p></li>
<li><p>Vespa и</p></li>
<li><p>Weviate .</p></li>
</ol>
<p>К сожалению, подобные решения требуют времени и ресурсов, а ни одна организация не располагает неограниченным количеством ни того, ни другого. Учитывая наш бюджет, мы решили протестировать Qdrant и Milvus, а тестирование Vespa и Weviate оставить в качестве растяжимых целей.</p>
<p>Qdrant против Milvus также был интересным тестом двух разных архитектур:</p>
<ul>
<li><p><strong>Qdrant:</strong> Однородные типы узлов, выполняющие все операции с векторной базой данных ANN.</p></li>
<li><p><strong>Milvus:</strong> <a href="https://milvus.io/docs/architecture_overview.md">гетерогенные типы узлов</a> (Milvus; один для запросов, другой для индексирования, третий для приема данных, прокси и т. д.).</p></li>
</ul>
<p>Какой из них было легко настроить (проверка документации)? Какой из них было легко запустить (тест на отказоустойчивость и отлаженность)? И какой из них лучше всего подходит для тех случаев использования и масштабов, которые нас интересовали? На эти вопросы мы пытались ответить в ходе количественного сравнения решений.</p>
<h3 id="3-Quantitatively-evaluate-top-contenders" class="common-anchor-header">3. Количественная оценка лучших претендентов</h3><p>Мы хотели лучше понять, насколько масштабируемым является каждое из решений, и в процессе работы получить представление о том, каково это - устанавливать, настраивать, поддерживать и запускать каждое из них в масштабе. Для этого мы собрали три набора данных с векторами документов и запросов для трех разных сценариев использования, настроили каждое решение с аналогичными ресурсами в Kubernetes, загрузили документы в каждое решение и отправили идентичные запросы с помощью <a href="https://k6.io/">Grafana K6</a> с исполнителем с нарастающей скоростью поступления, чтобы разогреть системы перед достижением целевой пропускной способности (например, 100 QPS).</p>
<p>Мы проверяли пропускную способность, точку разрыва каждого решения, соотношение между пропускной способностью и задержкой, а также реакцию на потерю узлов под нагрузкой (количество ошибок, влияние на задержку и т. д.). Ключевой интерес представляло <strong>влияние фильтрации на задержку</strong>. Также мы проводили простые тесты "да/нет", чтобы проверить, что возможности, описанные в документации, работают так, как описано (например, апсерт, удаление, получение по ID, администрирование пользователей и т. д.), и оценить эргономику этих API.</p>
<p><strong>Тестирование проводилось на Milvus v2.4 и Qdrant v1.12.</strong> Из-за нехватки времени мы не стали настраивать и тестировать все типы индексов; в каждом решении использовались схожие настройки, с уклоном на высокий уровень запоминания ANN, а тесты были сфокусированы на производительности индексов HNSW. Каждому решению также были выделены одинаковые ресурсы процессора и памяти.</p>
<p>В ходе экспериментов мы обнаружили несколько интересных различий между двумя решениями. В следующих экспериментах каждое решение имело примерно 340 М пост-векторов Reddit 384 размеров каждый, для HNSW, M=16, и efConstruction=100.</p>
<p>В одном из экспериментов мы обнаружили, что при одинаковой пропускной способности запросов (100 QPS без одновременного ввода данных) добавление фильтрации повлияло на задержку Milvus сильнее, чем Qdrant.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/Post_query_latency_with_filtering_2cb4c03d5b.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p>Латентность запросов с фильтрацией</p>
<p>В другом случае мы обнаружили, что взаимодействие между ингестированием и нагрузкой на запросы на Qdrant гораздо сильнее, чем на Milvus (показано ниже при постоянной пропускной способности). Вероятно, это связано с их архитектурой: Milvus разделяет большую часть своего ингестирования на отдельные типы узлов и узлы, обслуживающие трафик запросов, в то время как Qdrant обслуживает и ингестирование, и трафик запросов с одних и тех же узлов.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/Posts_query_latency_100_QPS_during_ingest_e919a448cb.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p>Задержка запроса при 100 QPS во время захвата</p>
<p>При тестировании разнообразия результатов по атрибутам (например, получение не более N результатов из каждого сабреддита в ответе) мы обнаружили, что при одинаковой пропускной способности Milvus имеет худшую задержку, чем Qdrant (при 100 QPS).</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/Post_query_latency_with_result_diversity_b126f562cd.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p>Задержка после запроса с учетом разнообразия результатов</p>
<p>Мы также хотели посмотреть, насколько эффективно каждое решение масштабируется при добавлении большего количества реплик данных (т. е. фактор репликации, RF, был увеличен с 1 до 2). Изначально, при RF=1, Qdrant смог обеспечить удовлетворительную задержку при большей пропускной способности, чем Milvus (более высокий QPS не показан, поскольку тесты не завершились без ошибок).</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/Qdrant_posts_RF_1_latency_for_varying_throughput_bc161c8b1c.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p>Qdrant показывает задержку RF=1 при различной пропускной способности</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/Milvus_posts_RF_1_latency_for_varying_throughput_e81775b3af.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p>Milvus показывает задержку RF=1 при различной пропускной способности</p>
<p>Однако при увеличении коэффициента репликации задержка p99 у Qdrant улучшилась, но Milvus смог выдержать более высокую пропускную способность, чем Qdrant, при приемлемой задержке (Qdrant 400 QPS не показан, так как тест не был завершен из-за высокой задержки и ошибок).</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/Milvus_posts_RF_2_latency_for_varying_throughput_7737dfb8a3.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p>Milvus показывает задержку RF=2 при различной пропускной способности</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/Qdrant_posts_RF_2_latency_for_varying_throughput_13fb26aaa1.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p>Qdrant показывает задержку RF=2 при различной пропускной способности</p>
<p>Из-за нехватки времени у нас не было достаточно времени, чтобы сравнить отзыв ANN между решениями на наших наборах данных, но мы приняли во внимание измерения отзыва ANN для решений, предоставленных <a href="https://ann-benchmarks.com/">https://ann-benchmarks.com/</a>, на общедоступных наборах данных.</p>
<h3 id="4-Final-selection" class="common-anchor-header">4. Окончательный выбор</h3><p><strong>С точки зрения производительности</strong>, без особых настроек и с использованием только HNSW, Qdrant во многих тестах оказался лучше, чем Milvus. Однако Milvus, похоже, лучше масштабируется при увеличении репликации и имеет лучшую изоляцию между вводом данных и нагрузкой на запросы благодаря архитектуре с несколькими узлами.</p>
<p>Несмотря на сложность архитектуры Milvus (несколько типов узлов, опора на внешний журнал с возможностью записи, как у Kafka, и хранилище метаданных, как у etcd)<strong>,</strong> нам было легче отлаживать и исправлять Milvus, чем Qdrant, когда оба решения входили в плохое состояние. Milvus также имеет автоматическую ребалансировку при увеличении коэффициента репликации коллекции, в то время как в Qdrant с открытым исходным кодом для увеличения коэффициента репликации требуется вручную создавать или удалять шарды (эту функцию нам пришлось бы создавать самим или использовать версию без открытого исходного кода).</p>
<p>Milvus - более "реддитовская" технология, чем Qdrant; у нее больше сходства с остальными частями нашего технологического стека. Milvus написан на Golang, нашем предпочтительном языке программирования бэкенда, и поэтому нам легче вносить в него свой вклад, чем в Qdrant, который написан на Rust. По сравнению с Qdrant, Milvus отличается высокой скоростью реализации проектов с открытым исходным кодом и отвечает большему числу наших ключевых требований.</p>
<p>В итоге оба решения удовлетворили большинство наших требований, и в некоторых случаях Qdrant имел преимущество в производительности, но мы почувствовали, что можем масштабировать Milvus дальше, нам было удобнее работать с ним, и он лучше подходил для нашей организации, чем Qdrant. Жаль, что у нас не было больше времени на тестирование Vespa и Weaviate, но они тоже могли быть выбраны по организационным причинам (Vespa основана на Java) и архитектуре (Weaviate - одноузловая, как Qdrant).</p>
<h2 id="Key-takeaways" class="common-anchor-header">Основные выводы<button data-href="#Key-takeaways" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><ul>
<li><p>Оспорьте полученные требования и постарайтесь устранить существующие предубеждения в отношении решений.</p></li>
<li><p>Оценивайте решения-кандидаты и используйте это для обсуждения основных требований, а не как абсолютную истину.</p></li>
<li><p>Оценивайте решения количественно, но по ходу дела обращайте внимание на то, каково это - работать с решением.</p></li>
<li><p>Выбирайте решение, которое лучше всего подходит вашей организации с точки зрения обслуживания, стоимости, удобства использования и производительности, а не только потому, что оно работает лучше всех.</p></li>
</ul>
<h2 id="Acknowledgements" class="common-anchor-header">Благодарности<button data-href="#Acknowledgements" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Эту работу по оценке выполнили Бен Кочи, Чарльз Нджороге, Амит Кумар и я. Спасибо также другим людям, которые внесли свой вклад в эту работу, в том числе Энни Янг, Конраду Райхе, Сабрине Конг и Эндрю Джонсону за качественное исследование решений.</p>
<h2 id="Editor’s-Notes" class="common-anchor-header">Примечания редактора<button data-href="#Editor’s-Notes" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Мы хотим выразить искреннюю благодарность команде инженеров Reddit - не только за то, что они выбрали Milvus для своих рабочих нагрузок векторного поиска, но и за то, что нашли время для публикации такой подробной и справедливой оценки. Редко можно увидеть такой уровень прозрачности в сравнении реальных инженерных команд с базами данных, и их статья будет полезна всем членам сообщества Milvus (и не только), которые пытаются разобраться в растущем ландшафте векторных баз данных.</p>
<p>Как отметил Крис в своем посте, не существует какой-то одной "лучшей" векторной базы данных. Важно то, соответствует ли система вашей рабочей нагрузке, ограничениям и философии работы. Сравнение Reddit хорошо отражает эту реальность. Milvus не возглавляет все категории, и это вполне ожидаемо, учитывая компромиссы между различными моделями данных и целями производительности.</p>
<p>Стоит уточнить один момент: В оценке Reddit использовалась версия <strong>Milvus 2.4</strong>, которая на тот момент была стабильным релизом. Некоторые функции - например, LSH и несколько оптимизаций индексов - в версии 2.4 либо еще не существовали, либо не были зрелыми, поэтому некоторые оценки, естественно, отражают более ранний базовый уровень. С тех пор мы выпустили Milvus 2.5, а затем <a href="https://milvus.io/blog/introduce-milvus-2-6-built-for-scale-designed-to-reduce-costs.md"><strong>Milvus 2.6</strong></a>, и это уже совсем другая система с точки зрения производительности, эффективности и гибкости. Сообщество отреагировало на это очень бурно, и многие команды уже обновились.</p>
<p><strong>Вот краткий обзор того, что нового появилось в Milvus 2.6:</strong></p>
<ul>
<li><p><strong>Снижение использования памяти на 72 %</strong> и <strong>ускорение запросов в 4 раза</strong> благодаря 1-битному квантованию RaBitQ</p></li>
<li><p><strong>Снижение затрат на 50 %</strong> благодаря интеллектуальному многоуровневому хранению</p></li>
<li><p><strong>4× более быстрый полнотекстовый поиск BM25</strong> по сравнению с Elasticsearch</p></li>
<li><p><strong>100× более быстрая фильтрация JSON</strong> с помощью нового индекса Path.</p></li>
<li><p>Новая архитектура с нулевым диском для более свежего поиска при меньших затратах</p></li>
<li><p>Упрощенный рабочий процесс "данные - внутрь, данные - наружу" для встраивания конвейеров</p></li>
<li><p>Поддержка <strong>100K+ коллекций</strong> для работы с большими многопользовательскими средами.</p></li>
</ul>
<p>Если вам нужен полный обзор, вот несколько хороших продолжений:</p>
<ul>
<li><p>Блог: <a href="https://milvus.io/blog/introduce-milvus-2-6-built-for-scale-designed-to-reduce-costs.md">Представляем Milvus 2.6: доступный векторный поиск в миллиардных масштабах</a></p></li>
<li><p><a href="https://milvus.io/docs/release_notes.md">Примечания к выпуску Milvus 2.6: </a></p></li>
<li><p><a href="https://milvus.io/blog/vdbbench-1-0-benchmarking-with-your-real-world-production-workloads.md">VDBBench 1.0: Бенчмаркинг реального мира для векторных баз данных - Блог Milvus</a></p></li>
</ul>
<p>У вас есть вопросы или вы хотите получить подробную информацию о какой-либо функции? Присоединяйтесь к нашему<a href="https://discord.com/invite/8uyFbECzPX"> каналу Discord</a> или создавайте проблемы на<a href="https://github.com/milvus-io/milvus"> GitHub</a>. Вы также можете заказать 20-минутную индивидуальную сессию, чтобы получить знания, рекомендации и ответы на свои вопросы в<a href="https://milvus.io/blog/join-milvus-office-hours-to-get-support-from-vectordb-experts.md"> Milvus Office Hours</a>.</p>
