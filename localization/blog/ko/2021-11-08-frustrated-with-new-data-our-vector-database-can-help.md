---
id: 2021-11-08-frustrated-with-new-data-our-vector-database-can-help.md
title: 소개
author: Zilliz
date: 2021-11-08T00:00:00.000Z
desc: AI 지향 범용 벡터 데이터베이스 시스템의 설계 및 실습
cover: assets.zilliz.com/Frustrated_with_new_data_5051d3ad15.png
tag: Engineering
---
<custom-h1>새로운 데이터에 좌절하셨나요? 벡터 데이터베이스가 도와드립니다.</custom-h1><p>빅데이터 시대에는 어떤 데이터베이스 기술과 애플리케이션이 각광받을까요? 다음 게임 체인저는 무엇일까요?</p>
<p>비정형 데이터가 전체 저장 데이터의 약 80~90%를 차지하고 있는 상황에서, 이렇게 증가하는 데이터 레이크에 어떻게 대처해야 할까요? 전통적인 분석 방법을 사용할 수도 있겠지만, 이러한 방법으로는 유용한 정보를 찾아내지 못할 수도 있습니다. 이 질문에 답하기 위해 Zilliz 연구 개발팀의 '삼총사'인 렌통 궈 박사, 샤오판 루안 박사, 샤오멍 이 박사는 범용 벡터 데이터베이스 시스템을 구축할 때 직면하는 설계와 과제에 대해 논의하는 기사를 공동 집필했습니다.</p>
<p>이 기사는 중국 최대 소프트웨어 개발자 커뮤니티인 CSDN에서 발행하는 저널인 Programmer에 수록되었습니다. 이번 프로그래머 호에는 2020년 튜링상 수상자인 제프리 울만, 2018년 튜링상 수상자인 얀 르쿤, 몽고DB의 CTO 마크 포터, 오션베이스의 설립자 젠쿤 양, 핑캡의 설립자 동수 황 등의 기사도 수록되어 있습니다.</p>
<p>아래에서 전체 기사를 공유해 드립니다:</p>
<custom-h1>AI 지향 범용 벡터 데이터베이스 시스템의 설계 및 실습</custom-h1><h2 id="Introduction" class="common-anchor-header">소개<button data-href="#Introduction" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>현대의 데이터 애플리케이션은 오늘날 데이터의 약 20%를 차지하는 구조화된 데이터를 쉽게 처리할 수 있습니다. 그 도구 상자에는 관계형 데이터베이스, NoSQL 데이터베이스 등과 같은 시스템이 있습니다. 반면 전체 데이터의 약 80%를 차지하는 비정형 데이터는 신뢰할 수 있는 시스템이 마련되어 있지 않습니다. 이 글에서는 이러한 문제를 해결하기 위해 기존 데이터 분석이 비정형 데이터에 대해 가지고 있는 문제점을 살펴보고, 자체 범용 벡터 데이터베이스 시스템을 구축하면서 직면했던 아키텍처와 과제에 대해 자세히 설명합니다.</p>
<h2 id="Data-Revolution-in-the-AI-era" class="common-anchor-header">AI 시대의 데이터 혁명<button data-href="#Data-Revolution-in-the-AI-era" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>5G와 IoT 기술의 급속한 발전으로 업계에서는 데이터 수집 채널을 늘리고 현실 세계를 디지털 공간에 더 많이 투영하고자 노력하고 있습니다. 이는 엄청난 도전 과제를 안겨주기도 했지만, 성장하는 산업에 엄청난 이점을 가져다주기도 했습니다. 이러한 어려운 과제 중 하나는 이렇게 새롭게 유입되는 데이터에 대한 심층적인 인사이트를 얻는 방법입니다.</p>
<p>IDC 통계에 따르면 2020년에만 전 세계적으로 40,000엑사바이트가 넘는 새로운 데이터가 생성되었습니다. 이 중 20%만이 정형 데이터, 즉 수치 계산과 관계대수를 통해 고도로 정돈되고 정리 및 분석이 용이한 데이터입니다. 반면, 나머지 80%를 차지하는 비정형 데이터는 데이터 유형이 매우 다양하기 때문에 기존의 데이터 분석 방법으로는 깊은 의미를 파악하기 어렵습니다.</p>
<p>다행히도, 그림 1과 같이 다양한 유형의 신경망을 통해 데이터를 더 잘 이해할 수 있는 AI가 등장하면서 비정형 데이터와 AI가 동시에 빠르게 진화하고 있습니다.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/newdata1_d5c34497d0.jpeg" alt="newdata1.jpeg" class="doc-image" id="newdata1.jpeg" />
   </span> <span class="img-wrapper"> <span>newdata1.jpeg</span> </span></p>
<p>임베딩 기술은 Word2vec의 데뷔 이후 빠르게 인기를 얻었으며, '모든 것을 임베딩한다'는 개념이 머신 러닝의 모든 분야에 적용되었습니다. 이로 인해 원시 데이터 레이어와 벡터 데이터 레이어라는 두 가지 주요 데이터 레이어가 등장하게 되었습니다. 원시 데이터 계층은 비정형 데이터와 특정 유형의 정형 데이터로 구성되며, 벡터 데이터 계층은 원시 계층에서 시작하여 머신 러닝 모델을 통과하는 쉽게 분석 가능한 임베딩의 모음입니다.</p>
<p>원시 데이터와 비교할 때, 벡터화된 데이터는 다음과 같은 장점이 있습니다:</p>
<ul>
<li>임베딩 벡터는 추상적인 유형의 데이터이므로 비정형 데이터의 복잡성을 줄이기 위한 통합된 대수 시스템을 구축할 수 있습니다.</li>
<li>임베딩 벡터는 고밀도 부동소수점 벡터를 통해 표현되므로 애플리케이션이 SIMD를 활용할 수 있습니다. GPU와 거의 모든 최신 CPU에서 SIMD를 지원하므로, 벡터 연산은 비교적 저렴한 비용으로 고성능을 달성할 수 있습니다.</li>
<li>머신 러닝 모델을 통해 인코딩된 벡터 데이터는 원본 비정형 데이터보다 저장 공간을 덜 차지하므로 처리량을 높일 수 있습니다.</li>
<li>임베딩된 벡터에 대해 산술 연산도 수행할 수 있습니다. 그림 2는 크로스 모달 시맨틱 근사치 매칭의 예를 보여줍니다. 그림에 표시된 그림은 단어 임베딩과 이미지 임베딩을 매칭한 결과입니다.</li>
</ul>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/newdata2_14e0554305.png" alt="newdata2.png" class="doc-image" id="newdata2.png" />
   </span> <span class="img-wrapper"> <span>newdata2.png</span> </span></p>
<p>그림 3에서 볼 수 있듯이 이미지와 단어 시맨틱을 결합하는 것은 해당 임베딩에서 간단한 벡터 덧셈과 뺄셈을 통해 수행할 수 있습니다.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/newdata3_3c71fc56b9.png" alt="newdata3.png" class="doc-image" id="newdata3.png" />
   </span> <span class="img-wrapper"> <span>newdata3.png</span> </span></p>
<p>위의 기능 외에도 이러한 연산자는 실제 시나리오에서 더 복잡한 쿼리 문을 지원합니다. 콘텐츠 추천이 잘 알려진 예입니다. 일반적으로 시스템은 콘텐츠와 사용자의 보기 선호도를 모두 임베드합니다. 그런 다음, 시스템은 의미적 유사성 분석을 통해 임베드된 사용자의 선호도와 가장 유사한 임베드된 콘텐츠를 매칭하여 사용자의 선호도와 유사한 새로운 콘텐츠를 생성합니다. 이 벡터 데이터 레이어는 추천 시스템에만 국한되지 않고 이커머스, 멀웨어 분석, 데이터 분석, 생체 인증, 화학 공식 분석, 금융, 보험 등 다양한 분야에서 활용되고 있습니다.</p>
<h2 id="Unstructured-data-requires-a-complete-basic-software-stack" class="common-anchor-header">비정형 데이터에는 완벽한 기본 소프트웨어 스택이 필요합니다.<button data-href="#Unstructured-data-requires-a-complete-basic-software-stack" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>시스템 소프트웨어는 모든 데이터 지향 애플리케이션의 근간을 이루지만, 데이터베이스, 데이터 분석 엔진 등 지난 수십 년 동안 구축된 데이터 시스템 소프트웨어는 정형 데이터를 처리하기 위한 것입니다. 최신 데이터 애플리케이션은 거의 전적으로 비정형 데이터에 의존하며 기존의 데이터베이스 관리 시스템의 이점을 누리지 못합니다.</p>
<p>이 문제를 해결하기 위해 저희는 <em>Milvus</em> (참고자료 1~2)라는 AI 지향 범용 벡터 데이터베이스 시스템을 개발하여 오픈소스화했습니다. 기존 데이터베이스 시스템과 비교할 때 Milvus는 다른 데이터 계층에서 작동합니다. 관계형 데이터베이스, KV 데이터베이스, 텍스트 데이터베이스, 이미지/비디오 데이터베이스 등과 같은 전통적인 데이터베이스는 원시 데이터 레이어에서 작동하는 반면, Milvus는 벡터 데이터 레이어에서 작동합니다.</p>
<p>다음 장에서는 Milvus를 구축할 때 직면했던 새로운 기능, 아키텍처 설계 및 기술적 과제에 대해 설명합니다.</p>
<h2 id="Major-attributes-of-vector-database" class="common-anchor-header">벡터 데이터베이스의 주요 속성<button data-href="#Major-attributes-of-vector-database" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>벡터 데이터베이스는 벡터를 저장, 검색, 분석하며, 다른 데이터베이스와 마찬가지로 CRUD 작업을 위한 표준 인터페이스도 제공합니다. 이러한 "표준" 기능 외에도 아래 나열된 속성도 벡터 데이터베이스의 중요한 특성입니다:</p>
<ul>
<li><strong>고효율 벡터 연산자 지원</strong></li>
</ul>
<p>분석 엔진에서 벡터 연산자에 대한 지원은 두 가지 수준에 중점을 둡니다. 첫째, 벡터 데이터베이스는 위에서 언급한 의미적 유사성 일치와 의미적 산술과 같은 다양한 유형의 연산자를 지원해야 합니다. 이 외에도 기본 유사도 계산을 위한 다양한 유사도 메트릭을 지원해야 합니다. 이러한 유사성은 일반적으로 벡터 간의 공간 거리로 정량화되며, 일반적인 메트릭은 유클리드 거리, 코사인 거리, 내적 곱 거리입니다.</p>
<ul>
<li><strong>벡터 인덱싱 지원</strong></li>
</ul>
<p>기존 데이터베이스의 B-트리 또는 LSM-트리 기반 인덱스와 비교할 때, 고차원 벡터 인덱스는 일반적으로 훨씬 더 많은 컴퓨팅 리소스를 소비합니다. 따라서 클러스터링 및 그래프 인덱스 알고리즘을 사용하고 행렬 및 벡터 연산에 우선순위를 부여하여 앞서 언급한 하드웨어 벡터 계산 가속 기능을 최대한 활용하는 것이 좋습니다.</p>
<ul>
<li><strong>다양한 배포 환경 전반에서 일관된 사용자 경험 제공</strong></li>
</ul>
<p>벡터 데이터베이스는 일반적으로 서로 다른 환경에서 개발 및 배포됩니다. 예비 단계에서 데이터 과학자와 알고리즘 엔지니어는 검증 효율성과 반복 속도에 더 많은 주의를 기울이기 때문에 주로 노트북과 워크스테이션에서 작업합니다. 검증이 완료되면 프라이빗 클러스터나 클라우드에 전체 크기의 데이터베이스를 배포할 수 있습니다. 따라서 검증된 벡터 데이터베이스 시스템은 다양한 배포 환경에서 일관된 성능과 사용자 경험을 제공해야 합니다.</p>
<ul>
<li><strong>하이브리드 검색 지원</strong></li>
</ul>
<p>벡터 데이터베이스가 보편화됨에 따라 새로운 애플리케이션이 등장하고 있습니다. 이러한 모든 요구 중에서 가장 자주 언급되는 것은 벡터와 다른 유형의 데이터에 대한 하이브리드 검색입니다. 스칼라 필터링 후 근사 근접 이웃 검색(ANNS), 전체 텍스트 검색과 벡터 검색의 다중 채널 리콜, 시공간 데이터와 벡터 데이터의 하이브리드 검색 등이 그 예입니다. 이러한 과제는 벡터 검색 엔진과 KV, 텍스트 및 기타 검색 엔진을 효과적으로 융합하기 위한 탄력적인 확장성과 쿼리 최적화를 요구합니다.</p>
<ul>
<li><strong>클라우드 네이티브 아키텍처</strong></li>
</ul>
<p>데이터 수집이 기하급수적으로 증가함에 따라 벡터 데이터의 양이 기하급수적으로 증가하고 있습니다. 조 단위의 고차원 벡터 데이터는 수천 TB의 스토리지에 해당하며, 이는 단일 노드의 한계를 훨씬 뛰어넘는 규모입니다. 따라서 수평적 확장성은 벡터 데이터베이스의 핵심 기능이며, 탄력성과 배포 민첩성에 대한 사용자의 요구를 충족시켜야 합니다. 또한, 클라우드 인프라의 지원을 통해 시스템 운영 및 유지 관리의 복잡성을 낮추고 통합 가시성을 향상시켜야 합니다. 이러한 요구 사항 중 일부는 기존 데이터베이스에서 흔히 볼 수 있는 멀티테넌트 격리, 데이터 스냅샷 및 백업, 데이터 암호화, 데이터 시각화 등의 형태로 나타납니다.</p>
<h2 id="Vector-database-system-architecture" class="common-anchor-header">벡터 데이터베이스 시스템 아키텍처<button data-href="#Vector-database-system-architecture" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Milvus 2.0은 &quot;데이터로서의 로그&quot;, &quot;통합 배치 및 스트림 처리&quot;, &quot;스테이트리스&quot;, &quot;마이크로 서비스&quot;라는 설계 원칙을 따릅니다. 그림 4는 Milvus 2.0의 전체 아키텍처를 보여줍니다.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/newdata4_b7f3ab6969.png" alt="newdata4.png" class="doc-image" id="newdata4.png" />
   </span> <span class="img-wrapper"> <span>newdata4.png</span> </span></p>
<p><strong>데이터로 로그</strong>: Milvus 2.0은 물리적 테이블을 유지하지 않습니다. 대신 로그 지속성과 로그 스냅샷을 통해 데이터 안정성을 보장합니다. 로그 브로커(시스템의 백본)는 로그를 저장하고 로그 게시-구독(pub-sub) 메커니즘을 통해 구성 요소와 서비스를 분리합니다. 그림 5에서 보듯이 로그 브로커는 &quot;로그 시퀀스&quot;와 &quot;로그 구독자&quot;로 구성됩니다. 로그 시퀀스는 컬렉션(관계형 데이터베이스의 테이블에 해당)의 상태를 변경하는 모든 작업을 기록하고, 로그 구독자는 로그 시퀀스를 구독하여 로컬 데이터를 업데이트하고 읽기 전용 복사본 형태로 서비스를 제공합니다. 또한 게시-구독 메커니즘은 변경 데이터 캡처(CDC) 및 전 세계에 분산된 배포 측면에서 시스템 확장성을 위한 공간을 제공합니다.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/newdata5_853dd38bc3.png" alt="newdata5.png" class="doc-image" id="newdata5.png" />
   </span> <span class="img-wrapper"> <span>newdata5.png</span> </span></p>
<p><strong>통합 배치 및 스트림 처리</strong>: 로그 스트리밍을 통해 Milvus는 실시간으로 데이터를 업데이트하여 실시간 전송 가능성을 보장합니다. 또한, 데이터 배치를 로그 스냅샷으로 변환하고 스냅샷에 인덱스를 구축함으로써 Milvus는 쿼리 효율성을 높일 수 있습니다. 쿼리 중에 Milvus는 증분 데이터와 과거 데이터의 쿼리 결과를 병합하여 반환되는 데이터의 무결성을 보장합니다. 이러한 설계는 실시간 성능과 효율성의 균형을 더 잘 유지하여 기존 람다 아키텍처에 비해 온라인 및 오프라인 시스템의 유지 관리 부담을 덜어줍니다.</p>
<p><strong>상태 비저장</strong>: 클라우드 인프라와 오픈 소스 스토리지 구성 요소 덕분에 Milvus는 자체 구성 요소 내에서 데이터를 유지하지 않아도 됩니다. Milvus 2.0은 메타데이터 스토리지, 로그 스토리지, 오브젝트 스토리지의 세 가지 유형의 스토리지로 데이터를 보존합니다. 메타데이터 스토리지는 메타데이터를 저장할 뿐만 아니라 서비스 검색과 노드 관리도 처리합니다. 로그 스토리지는 증분 데이터 지속성 및 데이터 게시-구독을 실행합니다. 객체 스토리지는 로그 스냅샷, 인덱스, 일부 중간 계산 결과를 저장합니다.</p>
<p><strong>마이크로서비스</strong>: Milvus는 데이터 플레인과 제어 플레인 분리, 읽기/쓰기 분리, 온라인/오프라인 작업 분리의 원칙을 따릅니다. 액세스 레이어, 코디네이터 레이어, 워커 레이어, 스토리지 레이어의 네 가지 서비스 레이어로 구성되어 있습니다. 이러한 계층은 확장 및 재해 복구와 관련하여 상호 독립적입니다. 최전방 레이어이자 사용자 엔드포인트인 액세스 레이어는 클라이언트 연결을 처리하고 클라이언트 요청의 유효성을 검사하며 쿼리 결과를 결합합니다. 시스템의 '두뇌'인 코디네이터 계층은 클러스터 토폴로지 관리, 로드 밸런싱, 데이터 선언, 데이터 관리 등의 작업을 수행합니다. 작업자 계층은 시스템의 '팔다리'로서 데이터 업데이트, 쿼리, 인덱스 구축 작업을 실행합니다. 마지막으로 스토리지 계층은 데이터 지속성 및 복제를 담당합니다. 전반적으로 이 마이크로서비스 기반 설계는 각 구성 요소가 해당 기능을 담당함으로써 제어 가능한 시스템 복잡성을 보장합니다. Milvus는 잘 정의된 인터페이스를 통해 서비스 경계를 명확히 하고, 더 세분화된 세분성을 기반으로 서비스를 분리하여 탄력적인 확장성과 리소스 분배를 더욱 최적화합니다.</p>
<h2 id="Technical-challenges-faced-by-vector-databases" class="common-anchor-header">벡터 데이터베이스가 직면한 기술적 과제<button data-href="#Technical-challenges-faced-by-vector-databases" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>벡터 데이터베이스에 대한 초기 연구는 주로 고효율 인덱스 구조와 쿼리 방법의 설계에 집중되었으며, 그 결과 다양한 벡터 검색 알고리즘 라이브러리가 탄생했습니다(참고자료 3~5). 지난 몇 년 동안 점점 더 많은 학계와 엔지니어링 팀이 시스템 설계 관점에서 벡터 검색 문제를 새롭게 바라보고 몇 가지 체계적인 해결책을 제안했습니다. 기존 연구와 사용자 요구를 요약하면, 벡터 데이터베이스의 주요 기술적 과제는 다음과 같이 분류할 수 있습니다:</p>
<ul>
<li><strong>부하 대비 비용 대비 성능 비율의 최적화</strong></li>
</ul>
<p>벡터 데이터의 분석은 기존 데이터 유형에 비해 차원이 높기 때문에 훨씬 더 많은 저장 공간과 컴퓨팅 리소스를 필요로 합니다. 게다가 사용자들은 벡터 검색 솔루션의 부하 특성과 비용 대비 성능 최적화에 대해 다양한 선호도를 보여 왔습니다. 예를 들어, 매우 큰 데이터 세트(수백억 또는 수천억 개의 벡터)로 작업하는 사용자는 데이터 저장 비용과 검색 지연 시간의 편차가 적은 솔루션을 선호하는 반면, 다른 사용자는 더 높은 검색 성능과 평균 지연 시간이 변하지 않는 것을 요구할 수 있습니다. 이러한 다양한 선호도를 만족시키기 위해서는 벡터 데이터베이스의 핵심 인덱스 구성 요소가 다양한 유형의 스토리지 및 컴퓨팅 하드웨어를 통해 인덱스 구조와 검색 알고리즘을 지원할 수 있어야 합니다.</p>
<p>예를 들어, 스토리지 비용을 낮추기 위해서는 벡터 데이터와 해당 인덱스 데이터를 저렴한 저장 매체(예: NVM 및 SSD)에 저장하는 것을 고려해야 합니다. 그러나 대부분의 기존 벡터 검색 알고리즘은 메모리에서 직접 읽은 데이터에서 작동합니다. 디스크 드라이브 사용으로 인한 성능 손실을 피하려면 벡터 데이터베이스는 벡터 데이터 및 인덱스 구조를 위한 스토리지 솔루션에 적응할 수 있을 뿐만 아니라 검색 알고리즘과 결합된 데이터 액세스의 로컬리티를 활용할 수 있어야 합니다(참조 6~8번). 성능 향상을 위해 최근의 연구는 GPU, NPU, FPGA 등과 관련된 하드웨어 가속 기술에 집중되고 있습니다(참고자료 9). 그러나 가속에 특화된 하드웨어와 칩은 아키텍처 설계가 다양하며, 서로 다른 하드웨어 가속기 간 가장 효율적인 실행 문제는 아직 해결되지 않았습니다.</p>
<ul>
<li><strong>자동화된 시스템 구성 및 튜닝</strong></li>
</ul>
<p>벡터 검색 알고리즘에 대한 대부분의 기존 연구는 스토리지 비용, 계산 성능, 검색 정확도 간의 유연한 균형을 추구합니다. 일반적으로 알고리즘 매개변수와 데이터 특징이 알고리즘의 실제 성능에 영향을 미칩니다. 비용과 성능에 대한 사용자의 요구가 다양하기 때문에, 사용자의 요구와 데이터 특징에 맞는 벡터 쿼리 방법을 선택하는 것은 상당한 도전 과제입니다.</p>
<p>그럼에도 불구하고 데이터 분포가 검색 알고리즘에 미치는 영향을 수동으로 분석하는 방법은 벡터 데이터의 높은 차원성으로 인해 효과적이지 않습니다. 이 문제를 해결하기 위해 학계와 업계에서는 머신 러닝에 기반한 알고리즘 추천 솔루션을 모색하고 있습니다(참고자료 10).</p>
<p>머신러닝 기반의 지능형 벡터 검색 알고리즘의 설계도 연구 분야입니다. 일반적으로 기존의 벡터 검색 알고리즘은 다양한 차원과 분포 패턴을 가진 벡터 데이터를 위해 범용적으로 개발되었습니다. 따라서 데이터 특성에 따른 특정 인덱스 구조를 지원하지 않아 최적화할 수 있는 여지가 적습니다. 향후 연구에서는 다양한 데이터 특징에 맞게 인덱스 구조를 조정할 수 있는 효과적인 머신 러닝 기술도 연구해야 합니다(참고자료 11-12).</p>
<ul>
<li><strong>고급 쿼리 의미론 지원</strong></li>
</ul>
<p>최신 애플리케이션은 종종 벡터 전반에 걸친 고급 쿼리에 의존합니다. 기존의 가장 가까운 이웃 검색 의미론은 더 이상 벡터 데이터 검색에 적용되지 않습니다. 게다가 여러 벡터 데이터베이스 또는 벡터와 비벡터 데이터에 대한 결합 검색에 대한 수요가 증가하고 있습니다(참고자료 13).</p>
<p>특히, 벡터 유사도에 대한 거리 메트릭의 변화는 빠르게 증가하고 있습니다. 유클리드 거리, 내적 곱 거리, 코사인 거리와 같은 전통적인 유사성 점수는 모든 애플리케이션의 요구를 충족시킬 수 없습니다. 인공지능 기술이 대중화되면서 많은 업계에서 타니모토 거리, 마하라노비스 거리, 상부 구조, 하부 구조와 같은 분야별 벡터 유사성 지표를 자체적으로 개발하고 있습니다. 이러한 평가 지표를 기존 검색 알고리즘에 통합하는 것과 이를 활용한 새로운 알고리즘을 설계하는 것은 모두 어려운 연구 과제입니다.</p>
<p>사용자 서비스의 복잡성이 증가함에 따라 애플리케이션은 벡터 데이터와 비벡터 데이터를 모두 검색해야 할 것입니다. 예를 들어, 콘텐츠 추천 기능은 사용자의 선호도, 사회적 관계를 분석하고 이를 현재 인기 있는 주제와 매칭하여 사용자에게 적합한 콘텐츠를 제공합니다. 이러한 검색에는 일반적으로 여러 데이터 유형 또는 여러 데이터 처리 시스템에 대한 쿼리가 포함됩니다. 이러한 하이브리드 검색을 효율적이고 유연하게 지원하는 것은 또 다른 시스템 설계 과제입니다.</p>
<h2 id="Authors" class="common-anchor-header">저자<button data-href="#Authors" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>렌통 구오 박사(화중과학기술대학교 컴퓨터 소프트웨어 및 이론 박사), Zilliz의 파트너 겸 R&amp;D 디렉터. 그는 중국 컴퓨터 연맹 분산 컴퓨팅 및 처리 기술 위원회(CCF TCDCP)의 위원입니다. 그의 연구는 데이터베이스, 분산 시스템, 캐싱 시스템, 이기종 컴퓨팅에 중점을 두고 있습니다. 그의 연구 결과는 Usenix ATC, ICS, DATE, TPDS를 비롯한 여러 최고 수준의 컨퍼런스 및 저널에 게재되었습니다. Milvus의 설계자인 Guo 박사는 확장성이 뛰어나고 비용 효율적인 AI 기반 데이터 분석 시스템을 개발하기 위한 솔루션을 모색하고 있습니다.</p>
<p>샤오판 루안, Zilliz의 파트너 겸 엔지니어링 디렉터이자 LF AI &amp; Data Foundation의 기술 자문위원회 위원. 오라클 미국 본사와 소프트웨어 정의 스토리지 스타트업인 Hedvig에서 연이어 근무했습니다. 알리바바 클라우드 데이터베이스 팀에 합류하여 NoSQL 데이터베이스 HBase와 Lindorm의 개발을 담당했습니다. Luan은 코넬대학교에서 전자 컴퓨터 공학 석사 학위를 취득했습니다.</p>
<p>이샤오멍 박사(화중과학기술대학교 컴퓨터 아키텍처 박사), Zilliz의 수석 연구원 겸 연구팀 리더. 그의 연구는 고차원 데이터 관리, 대규모 정보 검색, 분산 시스템에서의 리소스 할당에 중점을 두고 있습니다. 이 박사의 연구 성과는 IEEE 네트워크 매거진, IEEE/ACM TON, ACM SIGMOD, IEEE ICDCS, ACM TOMPECS 등 주요 학술지 및 국제 컨퍼런스에 게재되었습니다.</p>
<p>필리프 홀트마이어는 캘리포니아 대학교 산타크루즈 캠퍼스에서 컴퓨터 과학 학사 학위를 취득했습니다. Zilliz에 입사한 후 대부분의 시간을 클라우드 배포, 클라이언트 상호 작용, 기술 강연 및 AI 애플리케이션 개발 업무에 투자하고 있습니다.</p>
<h2 id="References" class="common-anchor-header">참고 자료<button data-href="#References" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><ol>
<li>Milvus 프로젝트: https://github.com/milvus-io/milvus</li>
<li>Milvus: 특수 목적의 벡터 데이터 관리 시스템, SIGMOD'21</li>
<li>Faiss 프로젝트: https://github.com/facebookresearch/faiss</li>
<li>Annoy 프로젝트: https://github.com/spotify/annoy</li>
<li>SPTAG 프로젝트: https://github.com/microsoft/SPTAG</li>
<li>GRIP: 벡터 검색 엔진을 위한 멀티스토어 용량 최적화 고성능 최인접 이웃 검색, CIKM'19</li>
<li>DiskANN: 단일 노드에서 빠르고 정확한 10억 개 포인트 최인접 이웃 검색, NIPS'19</li>
<li>HM-ANN: 이기종 메모리에서 효율적인 10억 개 포인트 최접근 이웃 검색, NIPS'20</li>
<li>SONG: GPU에서의 근사 최인접 이웃 검색, ICDE'20</li>
<li>데이터베이스 자동 관리 시스템 튜닝 서비스인 오터튠의 데모, VLDB'18</li>
<li>학습된 인덱스 구조의 사례, SIGMOD'18</li>
<li>학습된 적응형 조기 종료를 통한 근사 근접 이웃 검색 개선, SIGMOD'20</li>
<li>AnalyticDB-V: 정형 및 비정형 데이터를 위한 쿼리 융합을 위한 하이브리드 분석 엔진, VLDB'20</li>
</ol>
<h2 id="Engage-with-our-open-source-community" class="common-anchor-header">오픈 소스 커뮤니티에 참여하세요:<button data-href="#Engage-with-our-open-source-community" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><ul>
<li><a href="https://bit.ly/3khejQB">GitHub에서</a> Milvus를 찾거나 기여하세요.</li>
<li><a href="https://bit.ly/307HVsY">포럼을</a> 통해 커뮤니티와 소통하세요.</li>
<li><a href="https://bit.ly/3wn5aek">트위터에서</a> 소통하세요.</li>
</ul>
