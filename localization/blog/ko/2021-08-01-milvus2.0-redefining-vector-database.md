---
id: milvus2.0-redefining-vector-database.md
title: Milvus 2.0 벡터 데이터베이스 재정의
author: Xiaofan Luan
date: 2021-08-01T00:00:00.000Z
desc: >-
  Milvus 2.0은 지금 사용 가능합니다. 리팩터링된 이 클라우드 네이티브 버전은 이미지/비디오 검색, 챗봇, 그리고 더 많은 AI
  애플리케이션을 지원합니다.
cover: assets.zilliz.com/2_0_cover_bbc582b347.jpg
tag: Engineering
origin: null
---
<custom-h1>Milvus 2.0: 벡터 데이터베이스의 재정의</custom-h1><p>2018년 10월에 Milvus의 첫 코드를 작성한 것이 엊그제 같습니다. 2021년 3월, 전 세계 1,000명 이상의 사용자가 19번의 반복 테스트를 거친 끝에 장기적인 지원을 받는 첫 번째 공식 릴리스인 Milvus 1.0을 출시했습니다. 세계에서 가장 인기 있는 오픈 소스 벡터 데이터베이스로서 Milvus 1.0은 CRUD 작업 및 데이터 지속성과 같은 벡터 관리의 근본적인 문제를 해결했습니다. 하지만 새로운 시나리오와 요구사항이 등장하면서 아직 해결해야 할 문제가 훨씬 더 많다는 것을 깨닫기 시작했습니다. 이 글에서는 지난 3년간의 관찰 결과와 Milvus 2.0이 해결해야 할 과제, 그리고 Milvus 2.0이 이러한 과제에 대한 더 나은 솔루션으로 간주되는 이유를 요약하여 설명합니다. Milvus 2.0의 기능에 대해 자세히 알아보려면 Milvus 2. <a href="https://milvus.io/docs/v2.0.x/release_notes.md">0 릴리스 노트를</a> 확인하세요.</p>
<h2 id="Challenges-Milvus-1x-is-faced-with" class="common-anchor-header">Milvus 1.x가 직면한 과제<button data-href="#Challenges-Milvus-1x-is-faced-with" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p><strong>데이터 사일로:</strong> Milvus 1.0은 비정형 데이터에서 생성된 벡터 임베딩만 처리할 수 있으며, 스칼라 쿼리를 거의 지원하지 않습니다. 데이터 스토리지의 분리 설계로 인해 데이터가 중복되고 애플리케이션 개발의 복잡성이 가중되며, 통합된 최적화 도구가 없어 벡터 데이터와 스칼라 데이터 간의 하이브리드 검색이 만족스럽지 못합니다.</p>
<p><strong>적시성과 효율성 사이의 딜레마:</strong> Milvus 1.0은 거의 실시간에 가까운 시스템으로, 데이터 가시성을 보장하기 위해 정기적 또는 강제 플러시에 의존합니다. 이러한 접근 방식은 여러 수준에서 스트림 데이터 처리의 복잡성과 불확실성을 가중시킵니다. 게다가 이러한 일괄 삽입 방식은 처리 효율을 개선한다고는 하지만 여전히 많은 리소스를 소모합니다. 따라서 벌크로드 접근 방식이 필요합니다.</p>
<p><strong>확장성 및 탄력성 부족:</strong> Milvus 1.0은 확장성을 위해 샤딩 미들웨어 솔루션인 Mishards에 의존하고, 데이터 지속성을 위해 NAS(네트워크 연결 스토리지)를 사용합니다. 공유 스토리지를 기반으로 구축된 이 고전적인 아키텍처는 다음과 같은 이유로 전체 확장성에 크게 기여하지 못합니다:</p>
<ol>
<li>미샤드에서는 하나의 쓰기 노드만 지원되며 확장이 불가능합니다.</li>
<li>미샤드에서 읽기 노드의 확장은 일관된 해시 기반 라우팅을 사용해 구현됩니다. 일관된 해시는 구현하기 쉽고 데이터 배포 균일성 문제를 해결하는 데 도움이 되지만, 데이터 스케줄링이 충분히 유연하지 않으며 데이터 크기와 계산 능력 간의 불일치를 해결하기에는 부족합니다.</li>
<li>Milvus 1.0은 메타데이터 관리를 위해 MySQL에 의존하지만, 독립형 MySQL 서버가 처리할 수 있는 쿼리 및 데이터 세트 크기는 상당히 제한적입니다.</li>
</ol>
<p><strong>고가용성 부족:</strong> 저희가 관찰한 바에 따르면 대부분의 Milvus 사용자는 일관성보다 가용성을 선호하는 경향이 있는 반면, Milvus 1.x는 인메모리 복제본 및 재해 복구와 같은 기능이 부족하고 고가용성 측면에서는 기대에 미치지 못한다는 것입니다. 따라서 저희는 고가용성을 달성하기 위해 어느 정도의 정확성을 희생할 가능성을 모색하고 있습니다.</p>
<p><strong>엄청나게 높은 비용:</strong> Milvus 1.0은 데이터 지속성을 위해 NAS에 의존하는데, 이 비용은 일반적으로 로컬 또는 오브젝트 스토리지의 10배에 달합니다. 벡터 검색은 컴퓨팅 리소스와 메모리에 크게 의존하기 때문에 발생하는 높은 비용은 대규모 데이터 세트나 복잡한 비즈니스 시나리오에서 추가 탐색을 가로막는 장애물이 될 수 있습니다.</p>
<p><strong>직관적이지 않은 사용자 경험:</strong></p>
<ol>
<li>복잡한 분산 배포는 높은 운영 비용을 발생시킵니다.</li>
<li>잘 설계된 그래픽 사용자 인터페이스(GUI)를 사용할 수 없습니다.</li>
<li>직관적이지 않은 API는 애플리케이션 개발의 걸림돌이 되고 있습니다.</li>
</ol>
<p>패치에서 계속 진행할지 아니면 처음부터 다시 시작할지는 큰 문제입니다. Milvus의 아버지인 Charles Xie는 많은 전통적인 자동차 제조업체가 점진적으로 Tesla를 만들 수 없었던 것처럼, Milvus가 성공하려면 비정형 데이터 처리 및 분석 분야에서 게임 체인저가 되어야 한다고 믿습니다. 이러한 확신이 바로 리팩터링된 클라우드 네이티브 벡터 데이터베이스인 Milvus 2.0을 시작하게 된 원동력이었습니다.</p>
<h2 id="The-Making-of-Milvus-20" class="common-anchor-header">Milvus 2.0의 제작<button data-href="#The-Making-of-Milvus-20" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><h3 id="Design-principles" class="common-anchor-header">설계 원칙</h3><p>차세대 클라우드 네이티브 벡터 데이터베이스인 Milvus 2.0은 다음 세 가지 원칙을 중심으로 구축되었습니다:</p>
<p><strong>클라우드 네이티브 우선:</strong> 스토리지와 컴퓨팅 분리를 지원하는 아키텍처만이 필요에 따라 확장하고 클라우드의 탄력성을 최대한 활용할 수 있다고 믿습니다. 또한 읽기 및 쓰기 분리, 증분 및 기록 데이터 분리, CPU 집약적, 메모리 집약적, IO 집약적 작업 분리를 특징으로 하는 Milvus 2.0의 마이크로서비스 설계에 주목해 주시기 바랍니다. 마이크로서비스는 끊임없이 변화하는 이기종 워크로드에 대한 리소스 할당을 최적화하는 데 도움이 됩니다.</p>
<p><strong>데이터로서의 로그:</strong> Milvus 2.0에서는 로그 브로커가 시스템의 백본 역할을 합니다: 모든 데이터 삽입 및 업데이트 작업은 로그 브로커를 거쳐야 하며, 워커 노드는 로그를 구독하고 소비하여 CRUD 작업을 실행합니다. 이 설계는 데이터 지속성 및 플래시백과 같은 핵심 기능을 스토리지 계층으로 이동시켜 시스템 복잡성을 줄이고, 로그 퍼브-서브는 시스템을 더욱 유연하게 만들어 향후 확장에 대비할 수 있게 해줍니다.</p>
<p><strong>통합 배치 및 스트림 처리:</strong> Milvus 2.0은 증분 데이터와 기록 데이터의 처리를 통합하는 통합 람다 아키텍처를 구현합니다. Kappa 아키텍처에 비해 Milvus 2.0은 로그 스냅샷과 인덱스를 오브젝트 스토리지에 저장하는 로그 백필을 도입하여 장애 복구 효율과 쿼리 성능을 개선합니다. 무제한(스트림) 데이터를 제한된 창으로 나누기 위해 Milvus는 쓰기 시간 또는 이벤트 시간에 따라 스트림 데이터를 여러 메시지 팩으로 분할하고 사용자가 시간별로 쿼리할 수 있는 타임라인을 유지하는 새로운 워터마크 메커니즘을 채택했습니다.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/2_0_image_1_59d7316324.png" alt="2.0 image 1.png" class="doc-image" id="2.0-image-1.png" />
   </span> <span class="img-wrapper"> <span>2.0 이미지 1.png</span> </span></p>
<h3 id="System-architecture" class="common-anchor-header">시스템 아키텍처</h3><p>위에서 언급했듯이 Milvus 2.0의 설계는 스토리지와 컴퓨팅 분리, 제어 및 데이터 플레인 분리의 원칙을 엄격하게 따릅니다. 시스템은 액세스 레이어, 코디네이터 서비스, 워커 노드, 스토리지의 네 가지 계층으로 나뉩니다.</p>
<p><strong>액세스 계층:</strong> 인터페이스: 액세스 레이어는 시스템의 최전방 레이어이자 사용자에 대한 엔드포인트입니다. 요청을 전달하고 결과를 수집하는 역할을 담당합니다.</p>
<p><strong>코디네이터 서비스:</strong> 코디네이터 서비스는 작업자 노드에 작업을 할당하고 시스템의 두뇌 역할을 합니다. 코디네이터 유형에는 루트 코디네이터(루트 코디), 데이터 코디네이터(데이터 코디), 쿼리 코디네이터(쿼리 코디), 인덱스 코디네이터(인덱스 코디)의 네 가지가 있습니다.</p>
<p><strong>작업자 노드:</strong> 팔과 다리입니다. 작업자 노드는 코디네이터 서비스의 지시를 따르고 액세스 계층의 읽기/쓰기 요청에 응답하는 덤 실행기입니다. 워커 노드에는 데이터 노드, 쿼리 노드, 인덱스 노드의 세 가지 유형이 있습니다.</p>
<p><strong>저장소:</strong> 뼈대. 스토리지에는 메타 스토리지, 로그 브로커, 객체 스토리지의 세 가지 유형이 있습니다.</p>
<ul>
<li>etcd에 의해 구현된 메타 스토리지는 코디네이터 서비스를 위한 수집 및 체크포인트와 같은 메타데이터를 저장하는 데 사용됩니다.</li>
<li>Pulsar에서 구현하는 로그 브로커는 주로 증분 로그를 저장하고 안정적인 비동기 알림을 구현하는 데 사용됩니다.</li>
<li>MinIO 또는 S3로 구현되는 객체 스토리지는 주로 로그 스냅샷과 인덱스 파일을 저장하는 데 사용됩니다.</li>
</ul>
<p>다음은 Milvus 2.0의 시스템 아키텍처 다이어그램입니다: <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/2_0_image_2_2cc7d7fc9c.png" alt="2.0 image 2.png" class="doc-image" id="2.0-image-2.png" /><span>2.0 이미지 2.png</span> </span></p>
<h3 id="Key-features" class="common-anchor-header">주요 기능</h3><p>데이터베이스 운영 비용에는 런타임 리소스 소비뿐만 아니라 잠재적인 학습 비용과 운영 및 유지보수 비용도 포함됩니다. 실제로 사용자 친화적인 데이터베이스일수록 이러한 잠재적 비용을 절감할 수 있는 가능성이 높습니다. Milvus는 개발 초기부터 사용 편의성을 최우선으로 고려했으며, 최신 Milvus 2.0은 이러한 비용을 절감할 수 있는 여러 가지 기능을 제공합니다.</p>
<h4 id="Always-online" class="common-anchor-header">항상 온라인 상태</h4><p>데이터 안정성과 서비스 지속 가능성은 데이터베이스의 기본 요건이며, 저희의 전략은 &quot;저렴하게 실패하고, 작게 실패하고, 자주 실패하는 것&quot;입니다.</p>
<ul>
<li>"저렴하게 실패"란 스토리지와 컴퓨팅을 분리하여 노드 장애 복구를 간단하고 저렴한 비용으로 처리하는 것을 말합니다.</li>
<li>"작게 실패하기"는 각 코디네이터 서비스가 읽기/쓰기/증분/기록 데이터의 일부만 처리하도록 하여 설계 복잡성을 단순화하는 "분할 및 정복" 전략을 말합니다.</li>
<li>"자주 실패하기"는 테스트 환경에서 오류 주입을 사용하여 하드웨어 오류 및 종속성 오류와 같은 상황을 시뮬레이션하고 버그 발견을 가속화하는 카오스 테스트의 도입을 의미합니다.</li>
</ul>
<h4 id="Hybrid-search-between-scalar-and-vector-data" class="common-anchor-header">스칼라 데이터와 벡터 데이터 간의 하이브리드 검색</h4><p>정형 데이터와 비정형 데이터 간의 시너지를 활용하기 위해 Milvus 2.0은 스칼라 데이터와 벡터 데이터를 모두 지원하며, 이들 간의 하이브리드 검색을 가능하게 합니다. 하이브리드 검색은 사용자가 필터 조건과 일치하는 가장 가까운 이웃을 찾을 수 있도록 도와줍니다. 현재 Milvus는 같음, 같음보다 큼, 같음보다 작음과 같은 관계 연산과 NOT, AND, OR, IN과 같은 논리 연산을 지원합니다.</p>
<h4 id="Tunable-consistency" class="common-anchor-header">조정 가능한 일관성</h4><p>PACELC 정리를 준수하는 분산 데이터베이스로서 Milvus 2.0은 일관성과 가용성 및 지연 시간 사이에서 균형을 맞춰야 합니다. 대부분의 시나리오에서, 데이터의 일부가 보이지 않도록 허용하는 것은 전체 리콜에 거의 영향을 미치지 않지만 쿼리 성능을 크게 향상시킬 수 있기 때문에 운영 환경에서 데이터 일관성을 지나치게 강조하는 것은 과잉일 수 있습니다. 하지만 <em>강력하고 경계가 있는 유효기간, 세션과</em> 같은 일관성 수준에는 고유한 용도가 있다고 생각합니다. 따라서 Milvus는 요청 수준에서 일관성을 조정할 수 있도록 지원합니다. 테스트를 예로 들면, 사용자는 테스트 결과가 절대적으로 정확한지 확인하기 위해 <em>강력한</em> 일관성을 요구할 수 있습니다.</p>
<h4 id="Time-travel" class="common-anchor-header">시간 여행</h4><p>데이터 엔지니어는 종종 더티 데이터와 코드 버그를 수정하기 위해 데이터 롤백을 수행해야 합니다. 기존 데이터베이스는 일반적으로 스냅샷이나 데이터 재훈련을 통해 데이터 롤백을 구현합니다. 이는 과도한 오버헤드와 유지보수 비용을 초래할 수 있습니다. Milvus는 모든 데이터 삽입 및 삭제 작업에 대한 타임라인을 유지하며, 사용자는 쿼리에서 타임스탬프를 지정하여 지정된 시점의 데이터 보기를 검색할 수 있습니다. 시간 여행을 통해 Milvus는 경량 데이터 백업 또는 데이터 복제도 구현할 수 있습니다.</p>
<h4 id="ORM-Python-SDK" class="common-anchor-header">ORM Python SDK</h4><p>ORM(객체 관계 매핑)을 사용하면 사용자가 기본 데이터 모델보다 상위 수준의 비즈니스 모델에 더 집중할 수 있으므로 개발자가 컬렉션, 필드, 프로그램 간의 관계를 더 쉽게 관리할 수 있습니다. AI 알고리즘에 대한 개념 증명(PoC)과 프로덕션 배포 간의 격차를 줄이기 위해 임베디드 라이브러리, 독립형 배포, 분산 클러스터 또는 클라우드 서비스와 함께 작동할 수 있는 PyMilvus ORM API를 설계했습니다. 통합된 API 세트를 통해 사용자에게 일관된 사용자 경험을 제공하고 코드 마이그레이션 또는 적응 비용을 절감할 수 있습니다.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="https://assets.zilliz.com/2_0_image_3_55394d6e80.png" alt="2.0 image 3.png" class="doc-image" id="2.0-image-3.png" />
   </span> <span class="img-wrapper"> <span>2.0 이미지 3.png</span> </span></p>
<h4 id="Supporting-tools" class="common-anchor-header">지원 도구</h4><ul>
<li>Milvus Insight는 클러스터 상태 관리, 메타 관리, 데이터 쿼리와 같은 실용적인 기능을 제공하는 Milvus의 그래픽 사용자 인터페이스입니다. Milvus Insight의 소스 코드도 독립적인 프로젝트로 오픈 소스화될 예정입니다. 저희는 이 노력에 동참할 더 많은 기여자를 찾고 있습니다.</li>
<li>즉시 사용 가능한 경험(OOBE), 더 빠른 배포: Milvus 2.0은 헬름 또는 도커 컴포즈를 사용하여 배포할 수 있습니다.</li>
<li>Milvus 2.0은 성능을 저장하고 데이터를 모니터링하기 위해 오픈 소스 시계열 데이터베이스인 Prometheus를 사용하고, 메트릭 시각화를 위해 개방형 통합 가시성 플랫폼인 Grafana를 사용합니다.</li>
</ul>
<h2 id="Looking-to-the-future" class="common-anchor-header">미래를 바라보며<button data-href="#Looking-to-the-future" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>돌이켜보면 빅데이터 + AI 애플리케이션을 기반으로 한 시스템 아키텍처가 지나치게 복잡하다고 생각합니다. 밀버스 커뮤니티의 최우선 과제는 항상 밀버스를 더 쉽게 사용할 수 있도록 만드는 것이었습니다. 앞으로 Milvus 프로젝트는 다음 영역에 집중할 것입니다:</p>
<p><strong>AI용 DB:</strong> 데이터베이스 시스템으로서 Milvus는 기본적인 CRUD 기능 외에도 더 스마트한 쿼리 최적화 도구, 더 강력한 데이터 쿼리 기능, 더 포괄적인 데이터 관리 기능을 갖춰야 합니다. 다음 단계에서는 삭제 및 업데이트 작업 추가, 문자열 데이터 유형 지원 등 Milvus 2.0에서 아직 제공되지 않는 데이터 조작 언어(DML) 기능과 데이터 유형에 중점을 두고 작업할 예정입니다.</p>
<p><strong>DB용 AI:</strong> 인덱스 유형, 시스템 구성, 사용자 워크로드, 하드웨어 유형과 같은 매개변수의 노브 튜닝은 Milvus 사용을 복잡하게 만들므로 가급적 피해야 합니다. 시스템 부하를 분석하고 데이터의 액세스 빈도를 수집하여 학습 비용을 줄이기 위해 향후 자동 튜닝을 도입할 계획입니다.</p>
<p><strong>비용 최적화:</strong> 벡터 검색의 가장 큰 과제는 제한된 시간 내에 대규모 데이터 세트를 처리해야 한다는 점입니다. 이는 CPU와 메모리 집약적인 작업입니다. 물리 계층에 GPU와 FPGA 이기종 하드웨어 가속을 도입하면 CPU 오버헤드를 크게 줄일 수 있습니다. 또한 제한된 메모리로 대규모 데이터 세트에 대한 고성능 쿼리를 구현하기 위해 하이브리드 온디스크 및 인메모리 ANN 인덱싱 알고리즘을 개발 중입니다. 또한, ScaNN과 NGT와 같은 기존 오픈 소스 벡터 인덱싱 알고리즘의 성능도 평가하고 있습니다.</p>
<p><strong>사용 편의성:</strong> Milvus는 클러스터 관리 도구, 다국어 SDK, 배포 도구, 운영 도구 등을 제공하여 사용 편의성을 지속적으로 개선하고 있습니다.</p>
<p>Milvus의 출시 계획에 대해 자세히 알아보려면 <a href="https://milvus.io/docs/v2.0.x/roadmap.md">Milvus 로드맵을</a> 확인하세요.</p>
<p>Milvus 2.0은 Milvus 커뮤니티의 모든 기여자분들께 감사의 말씀을 전합니다. Milvus 커뮤니티에 <a href="https://github.com/milvus-io/milvus">이슈를 제출하거나</a> <a href="https://github.com/milvus-io/milvus">코드를 기여해</a> 주세요!</p>
<p><br/></p>
<p><em>저자 소개</em></p>
<p><em>샤오판 루안은 현재 Zilliz에서 Milvus 프로젝트의 R&amp;D를 관리하는 엔지니어링 디렉터로 일하고 있습니다. 그는 데이터베이스/스토리지 시스템 구축에 중점을 둔 7년간의 경력을 가지고 있습니다. 코넬 대학교를 졸업한 후 오라클, HEDVIG, Alibaba Cloud에서 연이어 근무했습니다.</em></p>
